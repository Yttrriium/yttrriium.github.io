#include <iostream>
#include <graphics.h>
#define iesire exit(0);
using namespace std;
int XE, YE, pct = 0, lc = 0, iesilec, pga, fnc, punctaj;
int a[6] = {1, 1, 1, 1, 1, 1}; // rezultate test 0 - rosu 1 - galben 2 - verde
void mainmenu();

void lectii();
int pag11();
int lectii2();
void exitlec();

int apas(int x, int y, int x1, int y1) //Schimbare culoare + operatie apasare
{
if(mousex()>x && mousex()<x1 && mousey()>y && mousey()<y1 && ismouseclick(WM_LBUTTONDOWN))
    {clearmouseclick(WM_LBUTTONDOWN);
    return 1;}
else
    {return 0;
    clearmouseclick(WM_LBUTTONDOWN);}
}


int test(int nr)
{int hp=3, pct1 = 0;
char h[5], ih[5];
clearmouseclick(WM_LBUTTONDOWN);
if(nr==1)
    for(int i=1;i<=5;i++)
        {if(hp==0)
            {cleardevice();
            setcolor(RED);
            settextstyle(10,0,7);
            outtextxy(XE/2-220,YE/2-60,"Nu ai reusit!");
            outtextxy(XE/2-220,YE/2,"Mai incearca!");
            return 0;}
        sprintf(h, "%d", hp);
        readimagefile("brickback.jpg",0,0,XE/2,YE);
        readimagefile("brickback.jpg",XE/2,0,XE,YE);
        readimagefile("door.jpg",XE/2-126,YE/2-94,XE/2+126,YE/2+350 ); //usa1
        readimagefile("2.jpg",XE/2-80,YE/4-94,XE/2+80,YE/4+35);
        readimagefile("door.jpg",XE/4-126,YE/2-94,XE/4+126,YE/2+350 ); //usa2
        readimagefile("1.jpg",XE/4-80,YE/4-94,XE/4+80,YE/4+35);
        readimagefile("door.jpg",XE*3/4-126,YE/2-94,XE*3/4+126,YE/2+350 ); //usa3
        readimagefile("3.jpg",XE*3/4-80,YE/4-94,XE*3/4+80,YE/4+35);
        readimagefile("exitd.jpg",XE-161,YE-200,XE-10,YE-10);
        setbkcolor(RGB(121,79,41)); // Afisam viata
        settextstyle(8,0,3);
        setcolor(WHITE);
        outtextxy(14,15,h);
        for(int j=1;j<=hp;j++)
            readimagefile("bheart.jpg", 30*j, 15, 30*j+30, 38);

        settextstyle(10,0,4); // Afisam numarul intrebarii
        outtextxy(XE/2-100,15,"Intrebarea");
        sprintf(ih,"%d",i);
        outtextxy(XE/2+92,15,ih);
        outtextxy(XE/2+112,15,"/5");

        settextstyle(3,0,5);
        if(i==1)
            while(true)
            {outtextxy(XE/2-185,59,"Tipurile reale sunt:");
            outtextxy(XE/4-128,YE/2+430,"float,double");
            outtextxy(XE/4-128,YE/2+470,"long double");
            outtextxy(XE/2-140,YE/2+450,"float,int,char");
            outtextxy(XE*3/4-126,YE/2+430,"long double");
            outtextxy(XE*3/4-126,YE/2+470,"double,char");
             if(apas(XE-161,YE-200,XE-10,YE-10)){ // Apasare buton iesire
                cleardevice();
                return 0;
            }
            if(apas(XE/2-126,YE/2-94,XE/2+126,YE/2+350) || apas(XE*3/4-126,YE/2-94,XE*3/4+126,YE/2+350)) // 1-3
                {hp--;
                readimagefile("cdoor.jpg",XE/2-126,YE/2-94,XE/2+126,YE/2+350);
                readimagefile("cdoor.jpg",XE*3/4-126,YE/2-94,XE*3/4+126,YE/2+350);
                readimagefile("odoor.jpg",XE/4-126,YE/2-94,XE/4+126,YE/2+350);
                break;}
            else if(apas(XE/4-126,YE/2-94,XE/4+126,YE/2+350))
                {readimagefile("odoor.jpg",XE/4-126,YE/2-94,XE/4+126,YE/2+350);
                pct1+=10;
                break;}
            }
        if(i==2)
            while(true)
            {outtextxy(XE/2-360,59,"O data de tip pointer memoreaza:");
            outtextxy(XE/4-128,YE/2+430,"o valoare");
            outtextxy(XE/4-98,YE/2+470,"reala");
            outtextxy(XE/2-100,YE/2+430,"o adresa");
            outtextxy(XE/2-140,YE/2+470,"de memorie");
            outtextxy(XE*3/4-126,YE/2+430,"o valoare");
            outtextxy(XE*3/4-96,YE/2+470,"ireala");
            if(apas(XE-161,YE-200,XE-10,YE-10)){ // Apasare buton iesire
                cleardevice();
                return 0;
            }
            if(apas(XE/4-126,YE/2-94,XE/4+126,YE/2+350) || apas(XE*3/4-126,YE/2-94,XE*3/4+126,YE/2+350)) // 2-3
                {hp--;
                readimagefile("cdoor.jpg",XE/4-126,YE/2-94,XE/4+126,YE/2+350);
                readimagefile("cdoor.jpg",XE*3/4-126,YE/2-94,XE*3/4+126,YE/2+350);
                readimagefile("odoor.jpg",XE/2-126,YE/2-94,XE/2+126,YE/2+350);
                break;}
            else if(apas(XE/2-126,YE/2-94,XE/2+126,YE/2+350))
                {readimagefile("odoor.jpg",XE/2-126,YE/2-94,XE/2+126,YE/2+350);
                pct1+=10;
                break;}
            }
        if(i==3)
            while(true)
            {outtextxy(XE/2-330,59,"Reprezentare unei date long int:");
            outtextxy(XE/4-98,YE/2+430,"8 octeti");
            outtextxy(XE/4-108,YE/2+470,"cu semn");
            outtextxy(XE/2-90,YE/2+430,"4 octeti");
            outtextxy(XE/2-120,YE/2+470,"fara semn");
            outtextxy(XE*3/4-96,YE/2+430,"4 octeti");
            outtextxy(XE*3/4-106,YE/2+470,"cu semn");
             if(apas(XE-161,YE-200,XE-10,YE-10)){ // Apasare buton iesire
                cleardevice();
                return 0;
            }
            if(apas(XE/2-126,YE/2-94,XE/2+126,YE/2+350) || apas(XE/4-126,YE/2-94,XE/4+126,YE/2+350)) // 1-2
                {hp--;
                readimagefile("cdoor.jpg",XE/2-126,YE/2-94,XE/2+126,YE/2+350);
                readimagefile("cdoor.jpg",XE/4-126,YE/2-94,XE/4+126,YE/2+350);
                readimagefile("odoor.jpg",XE*3/4-126,YE/2-94,XE*3/4+126,YE/2+350);
                break;}
            else if(apas(XE*3/4-126,YE/2-94,XE*3/4+126,YE/2+350))
                {readimagefile("odoor.jpg",XE*3/4-126,YE/2-94,XE*3/4+126,YE/2+350);
                pct1+=10;
                break;}
            }
        if(i==4)
            while(true)
            {outtextxy(XE/2-185,59,"Tipul bool contine:");
            outtextxy(XE/4-98,YE/2+450,"O valoare");
            outtextxy(XE/2-90,YE/2+450,"4 valori");
            outtextxy(XE*3/4-96,YE/2+450,"2 valori");
            if(apas(XE-161,YE-200,XE-10,YE-10)){ // Apasare buton iesire
                cleardevice();
                return 0;
            }
            if(apas(XE/2-126,YE/2-94,XE/2+126,YE/2+350) || apas(XE/4-126,YE/2-94,XE/4+126,YE/2+350)) //1-2
                {hp--;
                readimagefile("cdoor.jpg",XE/2-126,YE/2-94,XE/2+126,YE/2+350);
                readimagefile("cdoor.jpg",XE/4-126,YE/2-94,XE/4+126,YE/2+350);
                readimagefile("odoor.jpg",XE*3/4-126,YE/2-94,XE*3/4+126,YE/2+350);
                break;}
            else if(apas(XE*3/4-126,YE/2-94,XE*3/4+126,YE/2+350))
                {readimagefile("odoor.jpg",XE*3/4-126,YE/2-94,XE*3/4+126,YE/2+350);
                pct1+=10;
                break;}
            }
        if(i==5)
            while(true)
            {outtextxy(XE/2-300,59,"O data de tipul char afiseaza:");
            outtextxy(XE/4-108,YE/2+430,"Un cod");
            outtextxy(XE/4-95,YE/2+470,"ASCII");
            outtextxy(XE/2-100,YE/2+430,"Un cod");
            outtextxy(XE/2-80,YE/2+470,"binar");
            outtextxy(XE*3/4-96,YE/2+450,"Un caracter");
             if(apas(XE-161,YE-200,XE-10,YE-10)){ // Apasare buton iesire
                cleardevice();
                return 0;
            }
            if(apas(XE/2-126,YE/2-94,XE/2+126,YE/2+350) || apas(XE*3/4-126,YE/2-94,XE*3/4+126,YE/2+350)) //1-3
                {hp--;
                readimagefile("cdoor.jpg",XE/2-126,YE/2-94,XE/2+126,YE/2+350);
                readimagefile("cdoor.jpg",XE*3/4-126,YE/2-94,XE*3/4+126,YE/2+350);
                readimagefile("odoor.jpg",XE/4-126,YE/2-94,XE/4+126,YE/2+350);
                break;}
            else if(apas(XE/4-126,YE/2-94,XE/4+126,YE/2+350))
                {readimagefile("odoor.jpg",XE/4-126,YE/2-94,XE/4+126,YE/2+350);
                pct1+=10;
                break;}
            }
        delay(1500);}
if(nr==2)
    for(int i=1;i<=5;i++)
        {if(hp==0)
            {cleardevice();
            setcolor(RED);
            settextstyle(10,0,7);
            outtextxy(XE/2-220,YE/2-60,"Nu ai reusit!");
            outtextxy(XE/2-220,YE/2,"Mai incearca!");
            return 0;}
        sprintf(h, "%d", hp);
        readimagefile("brickback.jpg",0,0,XE/2,YE);
        readimagefile("brickback.jpg",XE/2,0,XE,YE);
        readimagefile("door.jpg",XE/2-126,YE/2-94,XE/2+126,YE/2+350 ); //usa1
        readimagefile("door.jpg",XE/4-126,YE/2-94,XE/4+126,YE/2+350 ); //usa2
        readimagefile("door.jpg",XE*3/4-126,YE/2-94,XE*3/4+126,YE/2+350 ); //usa3
        readimagefile("exitd.jpg",XE-161,YE-200,XE-10,YE-10);
        setbkcolor(RGB(121,79,41));
        settextstyle(8,0,3);
        setcolor(WHITE);
        outtextxy(14,15,h);
        for(int j=1;j<=hp;j++)
            readimagefile("bheart.jpg", 30*j, 15, 30*j+30, 38);

        settextstyle(10,0,4);
        outtextxy(XE/2-100,15,"Intrebarea");
        sprintf(ih,"%d",i);
        outtextxy(XE/2+92,15,ih);
        outtextxy(XE/2+112,15,"/5");

        settextstyle(3,0,5);
        if(i==1)
            while(true)
            {outtextxy(XE/2-280,59,"Instructiunea return este o:");
            readimagefile("2.jpg",XE/2-80,YE/4-94,XE/2+80,YE/4+35);
            readimagefile("1.jpg",XE/4-80,YE/4-94,XE/4+80,YE/4+35);
            readimagefile("3.jpg",XE*3/4-80,YE/4-94,XE*3/4+80,YE/4+35);
            outtextxy(XE/4-95,YE/2+430,"Structura");
            outtextxy(XE/4-110,YE/2+470,"alternativa");
            outtextxy(XE/2-100,YE/2+430,"Structura");
            outtextxy(XE/2-80,YE/2+470,"liniara");
            outtextxy(XE*3/4-96,YE/2+430,"Structura");
            outtextxy(XE*3/4-94,YE/2+470,"repetitiva");
             if(apas(XE-161,YE-200,XE-10,YE-10)){ // Apasare buton iesire
                cleardevice();
                return 0;
            }
            if(apas(XE/4-126,YE/2-94,XE/4+126,YE/2+350) || apas(XE*3/4-126,YE/2-94,XE*3/4+126,YE/2+350)) //2-3
                {hp--;
                readimagefile("cdoor.jpg",XE/4-126,YE/2-94,XE/4+126,YE/2+350);
                readimagefile("cdoor.jpg",XE*3/4-126,YE/2-94,XE*3/4+126,YE/2+350);
                readimagefile("odoor.jpg",XE/2-126,YE/2-94,XE/2+126,YE/2+350);
                break;}
            else if(apas(XE/2-126,YE/2-94,XE/2+126,YE/2+350))
                {readimagefile("odoor.jpg",XE/2-126,YE/2-94,XE/2+126,YE/2+350);
                pct1+=10;
                break;}
            }
        if(i==2)
            while(true)
            {outtextxy(XE/2-310,59,"Urmatorul program calculeaza:");
            readimagefile("probl1.jpg",XE/2-126,150,XE/2+126,330);
            readimagefile("2.jpg",XE/2-75,YE/2-50,XE/2+65,YE/2+65);
            readimagefile("1.jpg",XE/4-75,YE/2-50,XE/4+65,YE/2+65);
            readimagefile("3.jpg",XE*3/4-75,YE/2-50,XE*3/4+65,YE/2+65);
            outtextxy(XE/4-140,YE/2+430,"Suma primelor");
            outtextxy(XE/4-100,YE/2+470,"i numere");
            outtextxy(XE/2-100,YE/2+430,"Produsul a");
            outtextxy(XE/2-85,YE/2+470,"n numere");
            outtextxy(XE*3/4-140,YE/2+430,"Suma primelor");
            outtextxy(XE*3/4-94,YE/2+470,"n numere");
             if(apas(XE-161,YE-200,XE-10,YE-10)){ // Apasare buton iesire
                cleardevice();
                return 0;
            }
            if(apas(XE/2-126,YE/2-94,XE/2+126,YE/2+350) || apas(XE/4-126,YE/2-94,XE/4+126,YE/2+350)) //1-2
                {hp--;
                readimagefile("cdoor.jpg",XE/2-126,YE/2-94,XE/2+126,YE/2+350);
                readimagefile("cdoor.jpg",XE/4-126,YE/2-94,XE/4+126,YE/2+350);
                readimagefile("odoor.jpg",XE*3/4-126,YE/2-94,XE*3/4+126,YE/2+350);
                break;}
            else if(apas(XE*3/4-126,YE/2-94,XE*3/4+126,YE/2+350))
                {readimagefile("odoor.jpg",XE*3/4-126,YE/2-94,XE*3/4+126,YE/2+350);
                pct1+=10;
                break;}
            }
        if(i==3)
            while(true)
            {outtextxy(XE/2-310,59,"O instructiune de decizie este:");
            readimagefile("2.jpg",XE/2-80,YE/4-94,XE/2+80,YE/4+35);
            readimagefile("1.jpg",XE/4-80,YE/4-94,XE/4+80,YE/4+35);
            readimagefile("3.jpg",XE*3/4-80,YE/4-94,XE*3/4+80,YE/4+35);
            outtextxy(XE/4-60,YE/2+450,"While");
            outtextxy(XE/2-40,YE/2+450,"For");
            outtextxy(XE*3/4-80,YE/2+450,"Switch");
             if(apas(XE-161,YE-200,XE-10,YE-10)){ // Apasare buton iesire
                cleardevice();
                return 0;
            }
            if(apas(XE/2-126,YE/2-94,XE/2+126,YE/2+350) || apas(XE/4-126,YE/2-94,XE/4+126,YE/2+350)) //1-2
                {hp--;
                readimagefile("cdoor.jpg",XE/2-126,YE/2-94,XE/2+126,YE/2+350);
                readimagefile("cdoor.jpg",XE/4-126,YE/2-94,XE/4+126,YE/2+350);
                readimagefile("odoor.jpg",XE*3/4-126,YE/2-94,XE*3/4+126,YE/2+350);
                break;}
            else if(apas(XE*3/4-126,YE/2-94,XE*3/4+126,YE/2+350))
                {readimagefile("odoor.jpg",XE*3/4-126,YE/2-94,XE*3/4+126,YE/2+350);
                pct1+=10;
                break;}
            }
        if(i==4)
            while(true)
            {outtextxy(XE/2-400,59,"Instructiunea continue poate fi folosita cu:");
            readimagefile("2.jpg",XE/2-80,YE/4-94,XE/2+80,YE/4+35);
            readimagefile("1.jpg",XE/4-80,YE/4-94,XE/4+80,YE/4+35);
            readimagefile("3.jpg",XE*3/4-80,YE/4-94,XE*3/4+80,YE/4+35);
            outtextxy(XE/4-120,YE/2+430,"Instructiunea");
            outtextxy(XE/4-20,YE/2+470,"for");
            outtextxy(XE/2-120,YE/2+430,"Instructiunea");
            outtextxy(XE/2-10,YE/2+470,"if");
            outtextxy(XE*3/4-120,YE/2+430,"Instructiunea");
            outtextxy(XE*3/4-50,YE/2+470,"break");
             if(apas(XE-161,YE-200,XE-10,YE-10)){ // Apasare buton iesire
                cleardevice();
                return 0;
            }
            if(apas(XE/2-126,YE/2-94,XE/2+126,YE/2+350) || apas(XE*3/4-126,YE/2-94,XE*3/4+126,YE/2+350)) //1-3
                {hp--;
                readimagefile("cdoor.jpg",XE/2-126,YE/2-94,XE/2+126,YE/2+350);
                readimagefile("cdoor.jpg",XE*3/4-126,YE/2-94,XE*3/4+126,YE/2+350);
                readimagefile("odoor.jpg",XE/4-126,YE/2-94,XE/4+126,YE/2+350);
                break;}
            else if(apas(XE/4-126,YE/2-94,XE/4+126,YE/2+350))
                {readimagefile("odoor.jpg",XE/4-126,YE/2-94,XE/4+126,YE/2+350);
                pct1+=10;
                break;}
            }
        if(i==5)
            while(true)
            {outtextxy(XE/2-390,59,"Instructiunea for este echivalenta cu:");
            readimagefile("2.jpg",XE/2-80,YE/4-94,XE/2+80,YE/4+35);
            readimagefile("1.jpg",XE/4-80,YE/4-94,XE/4+80,YE/4+35);
            readimagefile("3.jpg",XE*3/4-80,YE/4-94,XE*3/4+80,YE/4+35);
            outtextxy(XE/4-120,YE/2+430,"Instructiunea");
            outtextxy(XE/4-70,YE/2+470,"continue");
            outtextxy(XE/2-120,YE/2+430,"Instructiunea");
            outtextxy(XE/2-50,YE/2+470,"while");
            outtextxy(XE*3/4-120,YE/2+430,"Instructiunea");
            outtextxy(XE*3/4-50,YE/2+470,"switch");
             if(apas(XE-161,YE-200,XE-10,YE-10)){ // Apasare buton iesire
                cleardevice();
                return 0;
            }
            if(apas(XE/4-126,YE/2-94,XE/4+126,YE/2+350) || apas(XE*3/4-126,YE/2-94,XE*3/4+126,YE/2+350)) //2-3
                {hp--;
                readimagefile("cdoor.jpg",XE/4-126,YE/2-94,XE/4+126,YE/2+350);
                readimagefile("cdoor.jpg",XE*3/4-126,YE/2-94,XE*3/4+126,YE/2+350);
                readimagefile("odoor.jpg",XE/2-126,YE/2-94,XE/2+126,YE/2+350);
                break;}
            else if(apas(XE/2-126,YE/2-94,XE/2+126,YE/2+350))
                {readimagefile("odoor.jpg",XE/2-126,YE/2-94,XE/2+126,YE/2+350);
                pct1+=10;
                break;}
            }
        delay(1500);}
if(nr==3)
    for(int i=1;i<=5;i++)
        {if(hp==0)
            {cleardevice();
            setcolor(RED);
            settextstyle(10,0,7);
            outtextxy(XE/2-220,YE/2-60,"Nu ai reusit!");
            outtextxy(XE/2-220,YE/2,"Mai incearca!");
            return 0;}
        sprintf(h, "%d", hp);
        readimagefile("mossback.jpg",0,0,XE/2,YE);
        readimagefile("mossback.jpg",XE/2,0,XE,YE);
        readimagefile("door.jpg",XE/2-126,YE/2-94,XE/2+126,YE/2+350 ); //usa1
        readimagefile("door.jpg",XE/4-126,YE/2-94,XE/4+126,YE/2+350 ); //usa2
        readimagefile("door.jpg",XE*3/4-126,YE/2-94,XE*3/4+126,YE/2+350 ); //usa3
        readimagefile("exitd.jpg",XE-161,YE-200,XE-10,YE-10);
        setbkcolor(RGB(129,130,132));
        settextstyle(8,0,3);
        setcolor(WHITE);
        outtextxy(14,5,h);
        for(int j=1;j<=hp;j++)
            readimagefile("mheart.jpg", 30*j, 5, 30*j+30, 28);

        settextstyle(10,0,4);
        outtextxy(XE/2-100,15,"Intrebarea");
        sprintf(ih,"%d",i);
        outtextxy(XE/2+92,15,ih);
        outtextxy(XE/2+112,15,"/5");

        settextstyle(3,0,5);
        if(i==1)
            while(true)
            {outtextxy(XE/2-400,59,"Afisarea unui elem. din vector se face cu:");
            readimagefile("2.jpg",XE/2-80,YE/4-94,XE/2+80,YE/4+35);
            readimagefile("1.jpg",XE/4-80,YE/4-94,XE/4+80,YE/4+35);
            readimagefile("3.jpg",XE*3/4-80,YE/4-94,XE*3/4+80,YE/4+35);
            outtextxy(XE/4-100,YE/2+450,"cout<<a;");
            outtextxy(XE/2-100,YE/2+450,"cin>>a[x];");
            outtextxy(XE*3/4-100,YE/2+450,"cout<<a[x];");
             if(apas(XE-161,YE-200,XE-10,YE-10)){ // Apasare buton iesire
                cleardevice();
                return 0;
            }
            if(apas(XE/2-126,YE/2-94,XE/2+126,YE/2+350) || apas(XE/4-126,YE/2-94,XE/4+126,YE/2+350)) //1-2
                {hp--;
                readimagefile("cdoor.jpg",XE/2-126,YE/2-94,XE/2+126,YE/2+350);
                readimagefile("cdoor.jpg",XE/4-126,YE/2-94,XE/4+126,YE/2+350);
                readimagefile("odoor.jpg",XE*3/4-126,YE/2-94,XE*3/4+126,YE/2+350);
                break;}
            else if(apas(XE*3/4-126,YE/2-94,XE*3/4+126,YE/2+350))
                {readimagefile("odoor.jpg",XE*3/4-126,YE/2-94,XE*3/4+126,YE/2+350);
                pct1+=10;
                break;}
            }
        if(i==2)
            while(true)
            {outtextxy(XE/2-280,59,"Ce face urmatorul algoritm?");
            readimagefile("probl2.jpg",XE/2-126,150,XE/2+126,380);
            readimagefile("2.jpg",XE/2-75,YE/2-50,XE/2+65,YE/2+65);
            readimagefile("1.jpg",XE/4-75,YE/2-50,XE/4+65,YE/2+65);
            readimagefile("3.jpg",XE*3/4-75,YE/2-50,XE*3/4+65,YE/2+65);
            outtextxy(XE/4-100,YE/2+430,"Ordoneaza");
            outtextxy(XE/4-90,YE/2+470,"crescator");
            outtextxy(XE/2-100,YE/2+430,"Ordoneaza");
            outtextxy(XE/2-120,YE/2+470,"descrescator");
            outtextxy(XE*3/4-100,YE/2+430,"Ordoneaza");
            outtextxy(XE*3/4-75,YE/2+470,"aleatoriu");
             if(apas(XE-161,YE-200,XE-10,YE-10)){ // Apasare buton iesire
                cleardevice();
                return 0;
            }
            if(apas(XE/2-126,YE/2-94,XE/2+126,YE/2+350) || apas(XE*3/4-126,YE/2-94,XE*3/4+126,YE/2+350)) //1-3
                {hp--;
                readimagefile("cdoor.jpg",XE/2-126,YE/2-94,XE/2+126,YE/2+350);
                readimagefile("cdoor.jpg",XE*3/4-126,YE/2-94,XE*3/4+126,YE/2+350);
                readimagefile("odoor.jpg",XE/4-126,YE/2-94,XE/4+126,YE/2+350);
                break;}
            else if(apas(XE/4-126,YE/2-94,XE/4+126,YE/2+350))
                {readimagefile("odoor.jpg",XE/4-126,YE/2-94,XE/4+126,YE/2+350);
                pct1+=10;
                break;}
            }
        if(i==3)
            while(true)
            {outtextxy(XE/2-400,59,"Un tablou cu 100 elem. intregi se declara:");
            readimagefile("2.jpg",XE/2-80,YE/4-94,XE/2+80,YE/4+35);
            readimagefile("1.jpg",XE/4-80,YE/4-94,XE/4+80,YE/4+35);
            readimagefile("3.jpg",XE*3/4-80,YE/4-94,XE*3/4+80,YE/4+35);
            outtextxy(XE/4-110,YE/2+450,"float a[100]");
            outtextxy(XE/2-110,YE/2+450,"int a[100];");
            outtextxy(XE*3/4-70,YE/2+450,"int a;");
             if(apas(XE-161,YE-200,XE-10,YE-10)){ // Apasare buton iesire
                cleardevice();
                return 0;
            }
            if(apas(XE/4-126,YE/2-94,XE/4+126,YE/2+350) || apas(XE*3/4-126,YE/2-94,XE*3/4+126,YE/2+350)) //2-3
                {hp--;
                readimagefile("cdoor.jpg",XE/4-126,YE/2-94,XE/4+126,YE/2+350);
                readimagefile("cdoor.jpg",XE*3/4-126,YE/2-94,XE*3/4+126,YE/2+350);
                readimagefile("odoor.jpg",XE/2-126,YE/2-94,XE/2+126,YE/2+350);
                break;}
            else if(apas(XE/2-126,YE/2-94,XE/2+126,YE/2+350))
                {readimagefile("odoor.jpg",XE/2-126,YE/2-94,XE/2+126,YE/2+350);
                pct1+=10;
                break;}
            }
        if(i==4)
            while(true)
            {outtextxy(XE/2-400,59,"Care tablou memoreaza maxim 4 elemente");
            readimagefile("probl3.jpg",XE/2-150,150,XE/2+150,330);
            readimagefile("2.jpg",XE/2-75,YE/2-50,XE/2+65,YE/2+65);
            readimagefile("1.jpg",XE/4-75,YE/2-50,XE/4+65,YE/2+65);
            readimagefile("3.jpg",XE*3/4-75,YE/2-50,XE*3/4+65,YE/2+65);
            outtextxy(XE/4-110,YE/2+450,"Tabloul A");
            outtextxy(XE/2-110,YE/2+450,"Tabloul B");
            outtextxy(XE*3/4-100,YE/2+450,"Tabloul C");
             if(apas(XE-161,YE-200,XE-10,YE-10)){ // Apasare buton iesire
                cleardevice();
                return 0;
            }
            if(apas(XE/2-126,YE/2-94,XE/2+126,YE/2+350) || apas(XE*3/4-126,YE/2-94,XE*3/4+126,YE/2+350)) //1-3
                {hp--;
                readimagefile("cdoor.jpg",XE/2-126,YE/2-94,XE/2+126,YE/2+350);
                readimagefile("cdoor.jpg",XE*3/4-126,YE/2-94,XE*3/4+126,YE/2+350);
                readimagefile("odoor.jpg",XE/4-126,YE/2-94,XE/4+126,YE/2+350);
                break;}
            else if(apas(XE/4-126,YE/2-94,XE/4+126,YE/2+350))
                {readimagefile("odoor.jpg",XE/4-126,YE/2-94,XE/4+126,YE/2+350);
                pct1+=10;
                break;}
            }
        if(i==5)
            while(true)
            {outtextxy(XE/2-300,59,"Parcurgerea unui vector se face:");
            readimagefile("2.jpg",XE/2-80,YE/4-94,XE/2+80,YE/4+35);
            readimagefile("1.jpg",XE/4-80,YE/4-94,XE/4+80,YE/4+35);
            readimagefile("3.jpg",XE*3/4-80,YE/4-94,XE*3/4+80,YE/4+35);
            outtextxy(XE/4-70,YE/2+430,"De la");
            outtextxy(XE/4-70,YE/2+470,"0 la n");
            outtextxy(XE/2-70,YE/2+430,"De la");
            outtextxy(XE/2-90,YE/2+470,"1 la n-1");
            outtextxy(XE*3/4-70,YE/2+430,"De la");
            outtextxy(XE*3/4-85,YE/2+470,"0 la n-1");
             if(apas(XE-161,YE-200,XE-10,YE-10)){ // Apasare buton iesire
                cleardevice();
                return 0;
            }
            if(apas(XE/2-126,YE/2-94,XE/2+126,YE/2+350) || apas(XE/4-126,YE/2-94,XE/4+126,YE/2+350)) //1-2
                {hp--;
                readimagefile("cdoor.jpg",XE/2-126,YE/2-94,XE/2+126,YE/2+350);
                readimagefile("cdoor.jpg",XE/4-126,YE/2-94,XE/4+126,YE/2+350);
                readimagefile("odoor.jpg",XE*3/4-126,YE/2-94,XE*3/4+126,YE/2+350);
                break;}
            else if(apas(XE*3/4-126,YE/2-94,XE*3/4+126,YE/2+350))
                {readimagefile("odoor.jpg",XE*3/4-126,YE/2-94,XE*3/4+126,YE/2+350);
                pct1+=10;
                break;}
            }
        delay(1500);}
if(nr==4)
    for(int i=1;i<=5;i++)
        {if(hp==0)
            {cleardevice();
            setcolor(RED);
            settextstyle(10,0,7);
            outtextxy(XE/2-220,YE/2-60,"Nu ai reusit!");
            outtextxy(XE/2-220,YE/2,"Mai incearca!");
            return 0;}
        sprintf(h, "%d", hp);
        readimagefile("mossback.jpg",0,0,XE/2,YE);
        readimagefile("mossback.jpg",XE/2,0,XE,YE);
        readimagefile("door.jpg",XE/2-126,YE/2-94,XE/2+126,YE/2+350 );
        readimagefile("door.jpg",XE/4-126,YE/2-94,XE/4+126,YE/2+350 );
        readimagefile("door.jpg",XE*3/4-126,YE/2-94,XE*3/4+126,YE/2+350 );
        readimagefile("exitd.jpg",XE-161,YE-200,XE-10,YE-10);
        setbkcolor(RGB(129,130,132));
        settextstyle(8,0,3);
        setcolor(WHITE);
        outtextxy(14,5,h);
        for(int j=1;j<=hp;j++)
            readimagefile("mheart.jpg", 30*j, 5, 30*j+30, 28);

        settextstyle(10,0,4);
        outtextxy(XE/2-100,15,"Intrebarea");
        sprintf(ih,"%d",i);
        outtextxy(XE/2+92,15,ih);
        outtextxy(XE/2+112,15,"/5");

        settextstyle(3,0,5);
        if(i==1)
            while(true)
            {outtextxy(XE/2-200,59,"Matricea A[5][10] are:");
            readimagefile("2.jpg",XE/2-80,YE/4-94,XE/2+80,YE/4+35);
            readimagefile("1.jpg",XE/4-80,YE/4-94,XE/4+80,YE/4+35);
            readimagefile("3.jpg",XE*3/4-80,YE/4-94,XE*3/4+80,YE/4+35);
            outtextxy(XE/4-120,YE/2+450,"50 elemente");
            outtextxy(XE/2-120,YE/2+450,"10 elemente");
            outtextxy(XE*3/4-120,YE/2+450,"15 elemente");
             if(apas(XE-161,YE-200,XE-10,YE-10)){ // Apasare buton iesire
                cleardevice();
                return 0;
            }
            if(apas(XE/2-126,YE/2-94,XE/2+126,YE/2+350) || apas(XE*3/4-126,YE/2-94,XE*3/4+126,YE/2+350)) //1-3
                {hp--;
                readimagefile("cdoor.jpg",XE/2-126,YE/2-94,XE/2+126,YE/2+350);
                readimagefile("cdoor.jpg",XE*3/4-126,YE/2-94,XE*3/4+126,YE/2+350);
                readimagefile("odoor.jpg",XE/4-126,YE/2-94,XE/4+126,YE/2+350);
                break;}
            else if(apas(XE/4-126,YE/2-94,XE/4+126,YE/2+350))
                {readimagefile("odoor.jpg",XE/4-126,YE/2-94,XE/4+126,YE/2+350);
                pct1+=10;
                break;}
            }
        if(i==2)
            while(true)
            {outtextxy(XE/2-400,59,"Unde gasim numarul 3 in matricea alaturata?");
            readimagefile("probl4.jpg",XE/2-150,150,XE/2+150,380);
            readimagefile("2.jpg",XE/2-75,YE/2-50,XE/2+65,YE/2+65);
            readimagefile("1.jpg",XE/4-75,YE/2-50,XE/4+65,YE/2+65);
            readimagefile("3.jpg",XE*3/4-75,YE/2-50,XE*3/4+65,YE/2+65);
            outtextxy(XE/4-140,YE/2+450,"V[4][2];V[5][4]");
            outtextxy(XE/2-140,YE/2+450,"V[4][2];V[4][5]");
            outtextxy(XE*3/4-140,YE/2+450,"V[2][4];V[5][4]");
             if(apas(XE-161,YE-200,XE-10,YE-10)){ // Apasare buton iesire
                cleardevice();
                return 0;
            }
            if(apas(XE/4-126,YE/2-94,XE/4+126,YE/2+350) || apas(XE*3/4-126,YE/2-94,XE*3/4+126,YE/2+350)) //2-3
                {hp--;
                readimagefile("cdoor.jpg",XE/4-126,YE/2-94,XE/4+126,YE/2+350);
                readimagefile("cdoor.jpg",XE*3/4-126,YE/2-94,XE*3/4+126,YE/2+350);
                readimagefile("odoor.jpg",XE/2-126,YE/2-94,XE/2+126,YE/2+350);
                break;}
            else if(apas(XE/2-126,YE/2-94,XE/2+126,YE/2+350))
                {readimagefile("odoor.jpg",XE/2-126,YE/2-94,XE/2+126,YE/2+350);
                pct1+=10;
                break;}
            }
        if(i==3)
            while(true)
            {outtextxy(XE/2-400,59,"Ce numere se afla in V[2][4] si V[4][1]?");
            readimagefile("probl5.jpg",XE/2-150,150,XE/2+150,380);
            readimagefile("2.jpg",XE/2-75,YE/2-50,XE/2+65,YE/2+65);
            readimagefile("1.jpg",XE/4-75,YE/2-50,XE/4+65,YE/2+65);
            readimagefile("3.jpg",XE*3/4-75,YE/2-50,XE*3/4+65,YE/2+65);
            outtextxy(XE/4-50,YE/2+450,"2 ; 4");
            outtextxy(XE/2-50,YE/2+450,"3 ; 8");
            outtextxy(XE*3/4-50,YE/2+450,"7 ; -8");
             if(apas(XE-161,YE-200,XE-10,YE-10)){ // Apasare buton iesire
                cleardevice();
                return 0;
            }
            if(apas(XE/2-126,YE/2-94,XE/2+126,YE/2+350) || apas(XE*3/4-126,YE/2-94,XE*3/4+126,YE/2+350)) //1-3
                {hp--;
                readimagefile("cdoor.jpg",XE/2-126,YE/2-94,XE/2+126,YE/2+350);
                readimagefile("cdoor.jpg",XE*3/4-126,YE/2-94,XE*3/4+126,YE/2+350);
                readimagefile("odoor.jpg",XE/4-126,YE/2-94,XE/4+126,YE/2+350);
                break;}
            else if(apas(XE/4-126,YE/2-94,XE/4+126,YE/2+350))
                {readimagefile("odoor.jpg",XE/4-126,YE/2-94,XE/4+126,YE/2+350);
                pct1+=10;
                break;}
            }
        if(i==4)
            while(true)
            {outtextxy(XE/2-300,59,"Ce face algoritmul de mai jos?");
            readimagefile("probl6.jpg",XE/2-150,150,XE/2+150,330);
            readimagefile("2.jpg",XE/2-75,YE/2-50,XE/2+65,YE/2+65);
            readimagefile("1.jpg",XE/4-75,YE/2-50,XE/4+65,YE/2+65);
            readimagefile("3.jpg",XE*3/4-75,YE/2-50,XE*3/4+65,YE/2+65);
            outtextxy(XE/4-135,YE/2+430,"Parcurgerea");
            outtextxy(XE/4-130,YE/2+470,"unei matrici");
            outtextxy(XE/2-80,YE/2+430,"Afisarea");
            outtextxy(XE/2-120,YE/2+470,"unei matrici");
            outtextxy(XE*3/4-60,YE/2+430,"Citirea");
            outtextxy(XE*3/4-115,YE/2+470,"unei matrici");
             if(apas(XE-161,YE-200,XE-10,YE-10)){ // Apasare buton iesire
                cleardevice();
                return 0;
            }
            if(apas(XE/2-126,YE/2-94,XE/2+126,YE/2+350) || apas(XE/4-126,YE/2-94,XE/4+126,YE/2+350)) //1-2
                {hp--;
                readimagefile("cdoor.jpg",XE/2-126,YE/2-94,XE/2+126,YE/2+350);
                readimagefile("cdoor.jpg",XE/4-126,YE/2-94,XE/4+126,YE/2+350);
                readimagefile("odoor.jpg",XE*3/4-126,YE/2-94,XE*3/4+126,YE/2+350);
                break;}
            else if(apas(XE*3/4-126,YE/2-94,XE*3/4+126,YE/2+350))
                {readimagefile("odoor.jpg",XE*3/4-126,YE/2-94,XE*3/4+126,YE/2+350);
                pct1+=10;
                break;}
            }
        if(i==5)
            while(true)
            {outtextxy(XE/2-400,59,"A[i][j] este o matrice patratica,atunci:");
            readimagefile("2.jpg",XE/2-80,YE/4-94,XE/2+80,YE/4+35);
            readimagefile("1.jpg",XE/4-80,YE/4-94,XE/4+80,YE/4+35);
            readimagefile("3.jpg",XE*3/4-80,YE/4-94,XE*3/4+80,YE/4+35);
            outtextxy(XE/4-30,YE/2+450,"i<j");
            outtextxy(XE/2-30,YE/2+450,"i=j");
            outtextxy(XE*3/4-30,YE/2+450,"i>j");
             if(apas(XE-161,YE-200,XE-10,YE-10)){ // Apasare buton iesire
                cleardevice();
                return 0;
            }
            if(apas(XE/4-126,YE/2-94,XE/4+126,YE/2+350) || apas(XE*3/4-126,YE/2-94,XE*3/4+126,YE/2+350)) //2-3
                {hp--;
                readimagefile("cdoor.jpg",XE/4-126,YE/2-94,XE/4+126,YE/2+350);
                readimagefile("cdoor.jpg",XE*3/4-126,YE/2-94,XE*3/4+126,YE/2+350);
                readimagefile("odoor.jpg",XE/2-126,YE/2-94,XE/2+126,YE/2+350);
                break;}
            else if(apas(XE/2-126,YE/2-94,XE/2+126,YE/2+350))
                {readimagefile("odoor.jpg",XE/2-126,YE/2-94,XE/2+126,YE/2+350);
                pct1+=10;
                break;}
            }
        delay(1500);}
if(nr==5)
    for(int i=1;i<=5;i++)
        {if(hp==0)
            {cleardevice();
            setcolor(RED);
            settextstyle(10,0,7);
            outtextxy(XE/2-220,YE/2-60,"Nu ai reusit!");
            outtextxy(XE/2-220,YE/2,"Mai incearca!");
            return 0;}
        sprintf(h, "%d", hp);
        readimagefile("iceback.jpg",0,0,XE/2,YE);
        readimagefile("iceback.jpg",XE/2,0,XE,YE);
        readimagefile("door.jpg",XE/2-126,YE/2-94,XE/2+126,YE/2+350 ); //usa1
        readimagefile("door.jpg",XE/4-126,YE/2-94,XE/4+126,YE/2+350 ); //usa2
        readimagefile("door.jpg",XE*3/4-126,YE/2-94,XE*3/4+126,YE/2+350 ); //usa3
        readimagefile("exitd.jpg",XE-161,YE-200,XE-10,YE-10);
        setbkcolor(RGB(225,243,253));
        settextstyle(8,0,3);
        setcolor(BLACK);
        outtextxy(14,5,h);
        for(int j=1;j<=hp;j++)
            readimagefile("iheart.jpg", 30*j, 5, 30*j+30, 28);

        settextstyle(10,0,4);
        outtextxy(XE/2-100,10,"Intrebarea");
        sprintf(ih,"%d",i);
        outtextxy(XE/2+92,10,ih);
        outtextxy(XE/2+112,10,"/5");

        settextstyle(3,0,5);
        if(i==1)
            while(true)
            {outtextxy(XE/2-400,59,"Cu ce operator se face referirea unui camp:");
            readimagefile("2.jpg",XE/2-80,YE/4-94,XE/2+80,YE/4+35);
            readimagefile("1.jpg",XE/4-80,YE/4-94,XE/4+80,YE/4+35);
            readimagefile("3.jpg",XE*3/4-80,YE/4-94,XE*3/4+80,YE/4+35);
            outtextxy(XE/4-130,YE/2+450,"Operatorul , ");
            outtextxy(XE/2-150,YE/2+450,"Operatorul -> ");
            outtextxy(XE*3/4-130,YE/2+450,"Operatorul . ");
             if(apas(XE-161,YE-200,XE-10,YE-10)){ // Apasare buton iesire
                cleardevice();
                return 0;
            }
            if(apas(XE/2-126,YE/2-94,XE/2+126,YE/2+350) || apas(XE/4-126,YE/2-94,XE/4+126,YE/2+350)) //1-2
                {hp--;
                readimagefile("cdoor.jpg",XE/2-126,YE/2-94,XE/2+126,YE/2+350);
                readimagefile("cdoor.jpg",XE/4-126,YE/2-94,XE/4+126,YE/2+350);
                readimagefile("odoor.jpg",XE*3/4-126,YE/2-94,XE*3/4+126,YE/2+350);
                break;}
            else if(apas(XE*3/4-126,YE/2-94,XE*3/4+126,YE/2+350))
                {readimagefile("odoor.jpg",XE*3/4-126,YE/2-94,XE*3/4+126,YE/2+350);
                pct1+=10;
                break;}
            }
        if(i==2)
            while(true)
            {outtextxy(XE/2-350,59,"Care din urm. operatii este corecta?");
            readimagefile("2.jpg",XE/2-80,YE/4-94,XE/2+80,YE/4+35);
            readimagefile("1.jpg",XE/4-80,YE/4-94,XE/4+80,YE/4+35);
            readimagefile("3.jpg",XE*3/4-80,YE/4-94,XE*3/4+80,YE/4+35);
            outtextxy(XE/4-150,YE/2+450,"cin>>A.varsta;");
            outtextxy(XE/2-130,YE/2+450,"cin>>varsta;");
            outtextxy(XE*3/4-150,YE/2+450,"cin>>varsta.A;");
             if(apas(XE-161,YE-200,XE-10,YE-10)){ // Apasare buton iesire
                cleardevice();
                return 0;
            }
            if(apas(XE/2-126,YE/2-94,XE/2+126,YE/2+350) || apas(XE*3/4-126,YE/2-94,XE*3/4+126,YE/2+350)) //1-3
                {hp--;
                readimagefile("cdoor.jpg",XE/2-126,YE/2-94,XE/2+126,YE/2+350);
                readimagefile("cdoor.jpg",XE*3/4-126,YE/2-94,XE*3/4+126,YE/2+350);
                readimagefile("odoor.jpg",XE/4-126,YE/2-94,XE/4+126,YE/2+350);
                break;}
            else if(apas(XE/4-126,YE/2-94,XE/4+126,YE/2+350))
                {readimagefile("odoor.jpg",XE/4-126,YE/2-94,XE/4+126,YE/2+350);
                pct1+=10;
                break;}
            }
        if(i==3)
            while(true)
            {outtextxy(XE/2-350,59,"Operatia posibila cu o data struct este:");
            readimagefile("2.jpg",XE/2-80,YE/4-94,XE/2+80,YE/4+35);
            readimagefile("1.jpg",XE/4-80,YE/4-94,XE/4+80,YE/4+35);
            readimagefile("3.jpg",XE*3/4-80,YE/4-94,XE*3/4+80,YE/4+35);
            outtextxy(XE/4-80,YE/2+450,"Afisare");
            outtextxy(XE/2-60,YE/2+450,"Citire");
            outtextxy(XE*3/4-80,YE/2+450,"Atribuire");
             if(apas(XE-161,YE-200,XE-10,YE-10)){ // Apasare buton iesire
                cleardevice();
                return 0;
            }
            if(apas(XE/2-126,YE/2-94,XE/2+126,YE/2+350) || apas(XE/4-126,YE/2-94,XE/4+126,YE/2+350)) //1-2
                {hp--;
                readimagefile("cdoor.jpg",XE/2-126,YE/2-94,XE/2+126,YE/2+350);
                readimagefile("cdoor.jpg",XE/4-126,YE/2-94,XE/4+126,YE/2+350);
                readimagefile("odoor.jpg",XE*3/4-126,YE/2-94,XE*3/4+126,YE/2+350);
                break;}
            else if(apas(XE*3/4-126,YE/2-94,XE*3/4+126,YE/2+350))
                {readimagefile("odoor.jpg",XE*3/4-126,YE/2-94,XE*3/4+126,YE/2+350);
                pct1+=10;
                break;}
            }
        if(i==4)
            while(true)
            {outtextxy(XE/2-400,59,"Persoana este un tip de date similar cu:");
            readimagefile("2.jpg",XE/2-80,YE/4-94,XE/2+80,YE/4+35);
            readimagefile("1.jpg",XE/4-80,YE/4-94,XE/4+80,YE/4+35);
            readimagefile("3.jpg",XE*3/4-80,YE/4-94,XE*3/4+80,YE/4+35);
            outtextxy(XE/4-100,YE/2+450,"Int si float");
            outtextxy(XE/2-100,YE/2+450,"Int si char");
            outtextxy(XE*3/4-150,YE/2+450,"Float si double");
             if(apas(XE-161,YE-200,XE-10,YE-10)){ // Apasare buton iesire
                cleardevice();
                return 0;
            }
            if(apas(XE/4-126,YE/2-94,XE/4+126,YE/2+350) || apas(XE*3/4-126,YE/2-94,XE*3/4+126,YE/2+350)) //2-3
                {hp--;
                readimagefile("cdoor.jpg",XE/4-126,YE/2-94,XE/4+126,YE/2+350);
                readimagefile("cdoor.jpg",XE*3/4-126,YE/2-94,XE*3/4+126,YE/2+350);
                readimagefile("odoor.jpg",XE/2-126,YE/2-94,XE/2+126,YE/2+350);
                break;}
            else if(apas(XE/2-126,YE/2-94,XE/2+126,YE/2+350))
                {readimagefile("odoor.jpg",XE/2-126,YE/2-94,XE/2+126,YE/2+350);
                pct1+=10;
                break;}
            }
        if(i==5)
            while(true)
            {outtextxy(XE/2-250,59,"Aceasta declarare este:");
            readimagefile("probl7.jpg",XE/2-150,230,XE/2+150,300);
            outtextxy(XE/4-160,YE/2+430,"Corecta in C++");
            outtextxy(XE/4-110,YE/2+470,"dar nu in C");
            outtextxy(XE/2-200,YE/2+430,"Gresita atat in C++");
            outtextxy(XE/2-110,YE/2+470,"cat si in C");
            outtextxy(XE*3/4-190,YE/2+430,"Corecta atat in C++");
            outtextxy(XE*3/4-110,YE/2+470,"cat si in C");
             if(apas(XE-161,YE-200,XE-10,YE-10)){ // Apasare buton iesire
                cleardevice();
                return 0;
            }
            if(apas(XE/2-126,YE/2-94,XE/2+126,YE/2+350) || apas(XE*3/4-126,YE/2-94,XE*3/4+126,YE/2+350)) //1-3
                {hp--;
                readimagefile("cdoor.jpg",XE/2-126,YE/2-94,XE/2+126,YE/2+350);
                readimagefile("cdoor.jpg",XE*3/4-126,YE/2-94,XE*3/4+126,YE/2+350);
                readimagefile("odoor.jpg",XE/4-126,YE/2-94,XE/4+126,YE/2+350);
                break;}
            else if(apas(XE/4-126,YE/2-94,XE/4+126,YE/2+350))
                {readimagefile("odoor.jpg",XE/4-126,YE/2-94,XE/4+126,YE/2+350);
                pct1+=10;
                break;}
            }
        delay(1500);}
if(nr==6)
    for(int i=1;i<=5;i++)
        {if(hp==0)
            {cleardevice();
            setcolor(RED);
            settextstyle(10,0,7);
            outtextxy(XE/2-220,YE/2-60,"Nu ai reusit!");
            outtextxy(XE/2-220,YE/2,"Mai incearca!");
            return 0;}
        sprintf(h, "%d", hp);
        readimagefile("iceback.jpg",0,0,XE/2,YE);
        readimagefile("iceback.jpg",XE/2,0,XE,YE);
        readimagefile("door.jpg",XE/2-126,YE/2-94,XE/2+126,YE/2+350 );
        readimagefile("2.jpg",XE/2-80,YE/4-94,XE/2+80,YE/4+35);
        readimagefile("door.jpg",XE/4-126,YE/2-94,XE/4+126,YE/2+350 );
        readimagefile("1.jpg",XE/4-80,YE/4-94,XE/4+80,YE/4+35);
        readimagefile("door.jpg",XE*3/4-126,YE/2-94,XE*3/4+126,YE/2+350 );
        readimagefile("3.jpg",XE*3/4-80,YE/4-94,XE*3/4+80,YE/4+35);

        readimagefile("exitd.jpg",XE-161,YE-200,XE-10,YE-10);
        setbkcolor(RGB(225,243,253));
        settextstyle(8,0,3);
        setcolor(BLACK);
        outtextxy(14,5,h);
        for(int j=1;j<=hp;j++)
            readimagefile("iheart.jpg", 30*j, 5, 30*j+30, 28);

        settextstyle(10,0,4);
        outtextxy(XE/2-100,10,"Intrebarea");
        sprintf(ih,"%d",i);
        outtextxy(XE/2+92,10,ih);
        outtextxy(XE/2+112,10,"/5");

        settextstyle(3,0,5);
        if(i==1)
            while(true)
            {outtextxy(XE/2-350,59,"De cate tipuri poate fi un subprogram:");
            outtextxy(XE/4-90,YE/2+430,"3 Tipuri");
            outtextxy(XE/2-90,YE/2+430,"2 Tipuri");
            outtextxy(XE*3/4-90,YE/2+430,"1 Tipuri");
             if(apas(XE-161,YE-200,XE-10,YE-10)){ // Apasare buton iesire
                cleardevice();
                return 0;
            }
            if(apas(XE/4-126,YE/2-94,XE/4+126,YE/2+350) || apas(XE*3/4-126,YE/2-94,XE*3/4+126,YE/2+350)) //2-3
                {hp--;
                readimagefile("cdoor.jpg",XE/4-126,YE/2-94,XE/4+126,YE/2+350);
                readimagefile("cdoor.jpg",XE*3/4-126,YE/2-94,XE*3/4+126,YE/2+350);
                readimagefile("odoor.jpg",XE/2-126,YE/2-94,XE/2+126,YE/2+350);
                break;}
            else if(apas(XE/2-126,YE/2-94,XE/2+126,YE/2+350))
                {readimagefile("odoor.jpg",XE/2-126,YE/2-94,XE/2+126,YE/2+350);
                pct1+=10;
                break;}
            }
        if(i==2)
            while(true)
            {outtextxy(XE/2-350,59,"Variabila __ este specifica O.O.P.:");
            outtextxy(XE/4-120,YE/2+430,"La nivel de");
            outtextxy(XE/4-70,YE/2+470,"clasa");
            outtextxy(XE/2-130,YE/2+430,"La nivel de");
            outtextxy(XE/2-70,YE/2+470,"fisier");
            outtextxy(XE*3/4-110,YE/2+430,"La nivel de");
            outtextxy(XE*3/4-50,YE/2+470,"bloc");
            if(apas(XE-161,YE-200,XE-10,YE-10)){ // Apasare buton iesire
                cleardevice();
                return 0;
            }
            if(apas(XE/2-126,YE/2-94,XE/2+126,YE/2+350) || apas(XE*3/4-126,YE/2-94,XE*3/4+126,YE/2+350)) //1-3
                {hp--;
                readimagefile("cdoor.jpg",XE/2-126,YE/2-94,XE/2+126,YE/2+350);
                readimagefile("cdoor.jpg",XE*3/4-126,YE/2-94,XE*3/4+126,YE/2+350);
                readimagefile("odoor.jpg",XE/4-126,YE/2-94,XE/4+126,YE/2+350);
                break;}
            else if(apas(XE/4-126,YE/2-94,XE/4+126,YE/2+350))
                {readimagefile("odoor.jpg",XE/4-126,YE/2-94,XE/4+126,YE/2+350);
                pct1+=10;
                break;}
            }
        if(i==3)
            while(true)
            {outtextxy(XE/2-400,59,"__ are alocat spatiu doar in timpul executiei:");
            outtextxy(XE/4-140,YE/2+430,"Durata statica");
            outtextxy(XE/2-150,YE/2+430,"Durata locala");
            outtextxy(XE*3/4-170,YE/2+430,"Durata dinamica");
             if(apas(XE-161,YE-200,XE-10,YE-10)){ // Apasare buton iesire
                cleardevice();
                return 0;
            }
            if(apas(XE/4-126,YE/2-94,XE/4+126,YE/2+350) || apas(XE*3/4-126,YE/2-94,XE*3/4+126,YE/2+350)) //2-3
                {hp--;
                readimagefile("cdoor.jpg",XE/4-126,YE/2-94,XE/4+126,YE/2+350);
                readimagefile("cdoor.jpg",XE*3/4-126,YE/2-94,XE*3/4+126,YE/2+350);
                readimagefile("odoor.jpg",XE/2-126,YE/2-94,XE/2+126,YE/2+350);
                break;}
            else if(apas(XE/2-126,YE/2-94,XE/2+126,YE/2+350))
                {readimagefile("odoor.jpg",XE/2-126,YE/2-94,XE/2+126,YE/2+350);
                pct1+=10;
                break;}
            }
        if(i==4)
            while(true)
            {outtextxy(XE/2-350,59,"Care dintre urm. se numeste heap:");
            outtextxy(XE/4-140,YE/2+430,"Zona de date");
            outtextxy(XE/2-130,YE/2+430,"Zona de stiva");
            outtextxy(XE*3/4-110,YE/2+430,"Zona libera");
             if(apas(XE-161,YE-200,XE-10,YE-10)){ // Apasare buton iesire
                cleardevice();
                return 0;
            }
            if(apas(XE/2-126,YE/2-94,XE/2+126,YE/2+350) || apas(XE/4-126,YE/2-94,XE/4+126,YE/2+350)) //1-2
                {hp--;
                readimagefile("cdoor.jpg",XE/2-126,YE/2-94,XE/2+126,YE/2+350);
                readimagefile("cdoor.jpg",XE/4-126,YE/2-94,XE/4+126,YE/2+350);
                readimagefile("odoor.jpg",XE*3/4-126,YE/2-94,XE*3/4+126,YE/2+350);
                break;}
            else if(apas(XE*3/4-126,YE/2-94,XE*3/4+126,YE/2+350))
                {readimagefile("odoor.jpg",XE*3/4-126,YE/2-94,XE*3/4+126,YE/2+350);
                pct1+=10;
                break;}
            }
        if(i==5)
            while(true)
            {outtextxy(XE/2-300,59,"Ce e un registru al procesorului:");
            outtextxy(XE/4-180,YE/2+430,"O memorie speciala");
            outtextxy(XE/4-165,YE/2+470,"de mici dimensiuni");
            outtextxy(XE/2-180,YE/2+430,"O memorie normala");
            outtextxy(XE/2-165,YE/2+470,"de mari dimensiuni");
            outtextxy(XE*3/4-180,YE/2+430,"O memorie normala");
            outtextxy(XE*3/4-165,YE/2+470,"de mici dimensiuni");
             if(apas(XE-161,YE-200,XE-10,YE-10)){ // Apasare buton iesire
                cleardevice();
                return 0;
            }
            if(apas(XE/2-126,YE/2-94,XE/2+126,YE/2+350) || apas(XE*3/4-126,YE/2-94,XE*3/4+126,YE/2+350)) //1-3
                {hp--;
                readimagefile("cdoor.jpg",XE/2-126,YE/2-94,XE/2+126,YE/2+350);
                readimagefile("cdoor.jpg",XE*3/4-126,YE/2-94,XE*3/4+126,YE/2+350);
                readimagefile("odoor.jpg",XE/4-126,YE/2-94,XE/4+126,YE/2+350);
                break;}
            else if(apas(XE/4-126,YE/2-94,XE/4+126,YE/2+350))
                {readimagefile("odoor.jpg",XE/4-126,YE/2-94,XE/4+126,YE/2+350);
                pct1+=10;
                break;}
            }
        delay(1500);}
cleardevice();
setcolor(GREEN);
settextstyle(10,0,7);
outtextxy(XE/2-220,YE/2-80,"Felicitari!");
outtextxy(XE/2-350,YE/2-20,"Ai terminat testul cu");
hp=pct1/10;
sprintf(ih,"%d",hp);
outtextxy(XE/2-350,YE/2+40,ih);
outtextxy(XE/2-310,YE/2+40,"/5 intrebari corecte.");
delay(1500);
pct+=pct1;
setbkcolor(RGB(196,192,251));
cleardevice();
return 1;
}

void text(string s, char a[100], int &h){

    setcolor(WHITE);
    settextstyle(9, 0, 3);
    if(s == "da")
        outtextxy(100, h, a);
    else if(s == "nu")
        outtextxy(50, h, a);
    h += 25;
}

int intoarcere(){
    settextstyle(6, 0 , 3);
    int yes =XE - 305 + textwidth("Iesire din lectie") + 10;
    setcolor(WHITE);
    lc = 1;
    outtextxy(XE - 300, YE - 125, "Iesire din lectie");
    rectangle(XE - 305, YE - 135, yes, YE - 90);
    if(!(mousex() > XE - 305 && mousex() < yes && mousey() > YE - 135 && mousey() < YE - 90) && GetAsyncKeyState(VK_LBUTTON))
        clearmouseclick(WM_LBUTTONDOWN);
    while(mousex() > XE - 305 && mousex() < yes && mousey() > YE - 135 && mousey() < YE - 90){
        setcolor(RGB(118,47,5));
        outtextxy(XE - 300, YE - 125, "Iesire din lectie");
        rectangle(XE - 305, YE - 135, yes, YE - 90);
        if(GetAsyncKeyState(VK_LBUTTON)){
            pga = 1;
            return 1;
        }
    }
    return 0;
    setcolor(WHITE);
}

int pag14();
int pag16();
int pag26();
int pag36();
int pag46();
int pag56();
int pag66();
int pag76();
int pag12();
int pag22();
int pag32();
int pag42();
int pag52();
int pag62();
int pag72();
int pag82();
int pag92();
int pag102();

int pag55(){
    int h = YE / 3 - 210;
    clearmouseclick(WM_LBUTTONDOWN);
    delay(200);
    setbkcolor(RGB(196,192,251));
    cleardevice();
        setcolor(RGB(65,0,36));
    settextstyle(6, 0, 17);
    outtextxy(XE / 2 - 240, 50, "Tipul inregistrare");
    setcolor(WHITE);
    rectangle(XE / 2 - 105, YE - 150, XE / 2 + 113, YE - 100);
    settextstyle(6, 0 , 3);
    outtextxy(XE / 2 - 100, YE - 135, "Pagina 5 din 5");
    h+=50;
    setcolor(RGB(65,0,36));
    settextstyle(6, 0, 17);
    outtextxy( 30, h, "Citirea si afisarea");
    h += 50;
    text("da", "O variabila de tip structura nu poate fi nici citita, nici afisata. Putem in schimb sa realizam", h);
    text("da", "aceste operatii cu campurile structurii, folosind operatorul de access (.).", h);
    text("da", "CORECT!", h);
    text("da", "cin >> A.nume >> A.prenume >> A.sex >> A.varsta >> A.salariu;", h);
    text("da", "cout << A.nume << " " << A.prenume << " " << A.sex << " " << A.varsta", h);
    text("da", "GRESIT!", h);
    text("da", "cin >> A;", h);
    text("da", "cout << B;", h);
    h+=50;
    setcolor(RGB(65,0,36));
    settextstyle(6, 0, 17);
    outtextxy( 30, h, "Atribuirea");
    h += 50;
    text("da", "Singura operatie uzuala care se poate efectua cu o variabila de tip structura este atribuirea:", h);
    text("da", "A = B", h);
    text("da", "Unde A si B sunt doua variabile de acelasi tip structura. Atribuirea se face bit cu bit – fiecare bit", h);
    text("nu", "din reprezentarea in memorie a variabilei B se copiaza corespunzator in reprezentarea in memorie", h);
    text("nu", "a variabilei A.", h);
    text("da", "", h);
    text("da", "", h);
    text("da", "", h);
    text("da", "", h);

    while(true){
        setcolor(WHITE);
        rectangle(XE / 2 - 105, YE - 150, XE / 2 + 113, YE - 100);
        settextstyle(6, 0 , 3);
        outtextxy(XE / 2 - 100, YE - 135, "Pagina 5 din 5");
        if(pga == 0)
           pga = intoarcere();
        if(pga == 1){
            return 2;
        }
        clearmouseclick(WM_LBUTTONDOWN);
        //sageata stanga
        line(XE / 2 - 150, YE - 125, XE / 2 - 125, YE - 100);
        line(XE / 2 - 150, YE - 125, XE / 2 - 125, YE - 150);
        if(!(mousex() > XE / 2 - 150 && mousex() < XE / 2 - 125 && mousey() > YE - 150 && mousey() < YE - 100) && GetAsyncKeyState(VK_LBUTTON))
            clearmouseclick(WM_LBUTTONDOWN);
        while(mousex() > XE / 2 - 150 && mousex() < XE / 2 - 125 && mousey() > YE - 150 && mousey() < YE - 100){
            setcolor(RGB(118,47,5));
            line(XE / 2 - 150, YE - 125, XE / 2 - 125, YE - 100);
            line(XE / 2 - 150, YE - 125, XE / 2 - 125, YE - 150);
            if(GetAsyncKeyState(VK_LBUTTON)){
                clearmouseclick(WM_LBUTTONDOWN);
                return 1;
            }
        }

    }
}

int pag45(){
    int h = YE / 3 - 150;
    clearmouseclick(WM_LBUTTONDOWN);
    delay(200);
    setbkcolor(RGB(196,192,251));
    cleardevice();
       setcolor(RGB(65,0,36));
    settextstyle(6, 0, 17);
    outtextxy(XE / 2 - 240, 50, "Tipul inregistrare");
    h+=50;
    text("da", "Exemplu:", h);
    text("da", "Consideram urmatoarea secventa:", h);
    text("da", "struct Persoana{", h);
    text("da", "    char nume[21], prenume[21], sex;", h);
    text("da", "    int varsta;", h);
    text("da", "    double salariu;};", h);
    text("da", "Persoana A, B;", h);
    text("da", "Urmatoarele operatii sunt corecte:", h);
    text("da", "cin >> A.varsta;", h);
    text("da", "strcpy(A.nume, 'Popescu');", h);
    text("da", "strcpy(B.nume, A.nume);", h);
    text("da", "A.sex = 'M';", h);
    text("da", "A.salariu = B.salariu + 125.80;", h);
    text("da", "B.varsta ++;", h);
    text("da", "Urmatoarele operatii sunt gresite:", h);
    text("da", "Persoana.nume	", h);
    text("da", "Persoana.A", h);
    text("da", "varsta.persoana", h);


    while(true){
        setcolor(WHITE);
        rectangle(XE / 2 - 105, YE - 150, XE / 2 + 113, YE - 100);
        settextstyle(6, 0 , 3);
        outtextxy(XE / 2 - 100, YE - 135, "Pagina 4 din 5");

        if(pga == 0)
           pga = intoarcere();
        if(pga == 1){
            return 2;
        }
        clearmouseclick(WM_LBUTTONDOWN);
        //sageata stanga
        line(XE / 2 - 150, YE - 125, XE / 2 - 125, YE - 100);
        line(XE / 2 - 150, YE - 125, XE / 2 - 125, YE - 150);
        if(!(mousex() > XE / 2 - 150 && mousex() < XE / 2 - 125 && mousey() > YE - 150 && mousey() < YE - 100) && GetAsyncKeyState(VK_LBUTTON))
            clearmouseclick(WM_LBUTTONDOWN);
        while(mousex() > XE / 2 - 150 && mousex() < XE / 2 - 125 && mousey() > YE - 150 && mousey() < YE - 100){
            setcolor(RGB(118,47,5));
            line(XE / 2 - 150, YE - 125, XE / 2 - 125, YE - 100);
            line(XE / 2 - 150, YE - 125, XE / 2 - 125, YE - 150);
            if(GetAsyncKeyState(VK_LBUTTON)){
                clearmouseclick(WM_LBUTTONDOWN);
                return 1;
            }
        }
        //sageata dreapta
        setcolor(WHITE);
        line(XE / 2 + 158, YE - 125, XE / 2 + 133, YE - 100);
        line(XE / 2 + 158, YE - 125, XE / 2 + 133, YE - 150);
        if(!(mousex() > XE / 2 + 133 && mousex() < XE / 2 + 158 && mousey() > YE - 150 && mousey() < YE - 100) && GetAsyncKeyState(VK_LBUTTON))
            clearmouseclick(WM_LBUTTONDOWN);
        while(mousex() > XE / 2 + 133 && mousex() < XE / 2 + 158 && mousey() > YE - 150 && mousey() < YE - 100){
            if(GetAsyncKeyState(VK_LBUTTON)){
                fnc = pag55();
                if(fnc == 1){
                    fnc = 0;
                    h = YE / 3 - 150;
                    clearmouseclick(WM_LBUTTONDOWN);
                    delay(200);
                        setcolor(RGB(65,0,36));
    settextstyle(6, 0, 17);
    outtextxy(XE / 2 - 240, 50, "Tipul inregistrare");
    text("da", "Exemplu:", h);
    text("da", "Consideram urmatoarea secventa:", h);
    text("da", "struct Persoana{", h);
    text("da", "    char nume[21], prenume[21], sex;", h);
    text("da", "    int varsta;", h);
    text("da", "    double salariu;};", h);
    text("da", "Persoana A, B;", h);
    text("da", "Urmatoarele operatii sunt corecte:", h);
    text("da", "cin >> A.varsta;", h);
    text("da", "strcpy(A.nume, 'Popescu');", h);
    text("da", "strcpy(B.nume, A.nume);", h);
    text("da", "A.sex = 'M';", h);
    text("da", "A.salariu = B.salariu + 125.80;", h);
    text("da", "B.varsta ++;", h);
    text("da", "Urmatoarele operatii sunt gresite:", h);
    text("da", "Persoana.nume	", h);
    text("da", "Persoana.A", h);
    text("da", "varsta.persoana", h);

                    break;
                }
                else if(fnc == 2){
                    return 2;
                }
            }
            setcolor(RGB(118,47,5));
            line(XE / 2 + 158, YE - 125, XE / 2 + 133, YE - 100);
            line(XE / 2 + 158, YE - 125, XE / 2 + 133, YE - 150);
        }
        setcolor(WHITE);
    }
}

int pag35(){
    int h = YE / 3 - 150;
    clearmouseclick(WM_LBUTTONDOWN);
    delay(200);
    setbkcolor(RGB(196,192,251));
    cleardevice();
       setcolor(RGB(65,0,36));
    settextstyle(6, 0, 17);
    outtextxy(XE / 2 - 240, 50, "Tipul inregistrare");
    text("da", "In declararile de mai sus avem urmatoarele:", h);
    text("da", "•	Persoana – este un tip de date, similar cu int sau char;", h);
    text("da", "•	A si B – sunt nume de variabile. Tipul acestor variabile este Persoana sau, mai explicit, struct", h);
    text("da", " Persoana;", h);
    text("da", "•	nume, prenume, sex, varsta, salariu – sunt numele unor campuri ale structurii", h);
    text("da", " Persoana. Ele pot fi utilizate intr-un program doar daca exista variabile de tip Persoana!", h);
    setcolor(RGB(65,0,36));
    settextstyle(6, 0, 17);
    outtextxy( 30, h, "Operatii cu structuri");
    h+=60;
    text("da", "Cea mai importanta operatie cu structuri este referirea unui camp.", h);
    text("da", "Referirea unui camp", h);
    text("da", "Se face cu ajutorul operatorului . (punct), numit si operator de acces la membrii unei structuri.", h);
    text("nu", "Forma generala a acestei operatii este:", h);
    text("da", "variabila_de_tip_structura.camp", h);
    text("da", "Observatii:", h);
    text("da", "•	Rezultatul acestei operatii este campul referit si este lvalue (poate fi supus unei atribuiri) ;", h);
    text("da", "•	Operatia nu este comutativa;", h);


    while(true){
        setcolor(WHITE);
        rectangle(XE / 2 - 105, YE - 150, XE / 2 + 113, YE - 100);
        settextstyle(6, 0 , 3);
        outtextxy(XE / 2 - 100, YE - 135, "Pagina 3 din 5");
        if(pga == 0)
           pga = intoarcere();
        if(pga == 1){
            return 2;
        }
        clearmouseclick(WM_LBUTTONDOWN);
        //sageata stanga
        line(XE / 2 - 150, YE - 125, XE / 2 - 125, YE - 100);
        line(XE / 2 - 150, YE - 125, XE / 2 - 125, YE - 150);
        if(!(mousex() > XE / 2 - 150 && mousex() < XE / 2 - 125 && mousey() > YE - 150 && mousey() < YE - 100) && GetAsyncKeyState(VK_LBUTTON))
            clearmouseclick(WM_LBUTTONDOWN);
        while(mousex() > XE / 2 - 150 && mousex() < XE / 2 - 125 && mousey() > YE - 150 && mousey() < YE - 100){
            setcolor(RGB(118,47,5));
            line(XE / 2 - 150, YE - 125, XE / 2 - 125, YE - 100);
            line(XE / 2 - 150, YE - 125, XE / 2 - 125, YE - 150);
            if(GetAsyncKeyState(VK_LBUTTON)){
                clearmouseclick(WM_LBUTTONDOWN);
                return 1;
            }
        }
        //sageata dreapta
        setcolor(WHITE);
        line(XE / 2 + 158, YE - 125, XE / 2 + 133, YE - 100);
        line(XE / 2 + 158, YE - 125, XE / 2 + 133, YE - 150);
        if(!(mousex() > XE / 2 + 133 && mousex() < XE / 2 + 158 && mousey() > YE - 150 && mousey() < YE - 100) && GetAsyncKeyState(VK_LBUTTON))
            clearmouseclick(WM_LBUTTONDOWN);
        while(mousex() > XE / 2 + 133 && mousex() < XE / 2 + 158 && mousey() > YE - 150 && mousey() < YE - 100){
            if(GetAsyncKeyState(VK_LBUTTON)){
                fnc = pag45();
                if(fnc == 1){
                    h = YE / 3 - 150;
                    clearmouseclick(WM_LBUTTONDOWN);
                    delay(200);
                    setbkcolor(RGB(196,192,251));
                    cleardevice();
                        setcolor(RGB(65,0,36));
    settextstyle(6, 0, 17);
    outtextxy(XE / 2 - 240, 50, "Tipul inregistrare");
    text("da", "In declararile de mai sus avem urmatoarele:", h);
    text("da", "•	Persoana – este un tip de date, similar cu int sau char;", h);
    text("da", "•	A si B – sunt nume de variabile. Tipul acestor variabile este Persoana sau, mai explicit, struct", h);
    text("da", " Persoana;", h);
    text("da", "•	nume, prenume, sex, varsta, salariu – sunt numele unor campuri ale structurii", h);
    text("da", " Persoana. Ele pot fi utilizate intr-un program doar daca exista variabile de tip Persoana!", h);
    setcolor(RGB(65,0,36));
    settextstyle(6, 0, 17);
    outtextxy( 30, h, "Operatii cu structuri");
    h+=60;
    text("da", "Cea mai importanta operatie cu structuri este referirea unui camp.", h);
    text("da", "Referirea unui camp", h);
    text("da", "Se face cu ajutorul operatorului . (punct), numit si operator de acces la membrii unei structuri.", h);
    text("nu", "Forma generala a acestei operatii este:", h);
    text("da", "variabila_de_tip_structura.camp", h);
    text("da", "Observatii:", h);
    text("da", "•	Rezultatul acestei operatii este campul referit si este lvalue (poate fi supus unei atribuiri) ;", h);
    text("da", "•	Operatia nu este comutativa;", h);

                    break;
                }
                else if(fnc == 2){
                    return 2;
                }
            }
            setcolor(RGB(118,47,5));
            line(XE / 2 + 158, YE - 125, XE / 2 + 133, YE - 100);
            line(XE / 2 + 158, YE - 125, XE / 2 + 133, YE - 150);
        }
        setcolor(WHITE);
    }
}

int pag25(){
    int h = YE / 3 - 150;
    clearmouseclick(WM_LBUTTONDOWN);
    delay(200);
    setbkcolor(RGB(196,192,251));
    cleardevice();
   setcolor(RGB(65,0,36));
    settextstyle(6, 0, 17);
    outtextxy(XE / 2 - 240, 50, "Tipul inregistrare");

    text("da", "In acest mod s-a declarat un tip de date cu numele NUME_STRUCTURA si eventual niste ", h);
    text("nu", "variabile de acest tip. In continuare NUME_STRUCTURA poate fi folosit ca un tip de date oarecare,", h);
    text("nu", "de exemplu pentru a declara variabile sau in lista parametrilor formali ai unei functii.", h);
    text("da", "Pentru exemplul dat mai sus, declararea va fi:", h);
    text("da", "struct Persoana{", h);
    text("da", "    char nume[21], prenume[21], sex;", h);
    text("da", "    int varsta;", h);
    text("da", "    double salariu;};", h);
    text("da", "S-a declarat o structura cu numele Persoana, dar nu s-a declarat nicio variabila de acest ", h);
    text("da", "tip. Pentru a declara variabile de tip Persoana putem sa le adaugam la declararea structurii:", h);
    text("da", "struct Persoana{", h);
    text("da", "    char nume[21], prenume[21], sex;", h);
    text("da", "    char nume[21], prenume[21], sex;", h);
    text("da", "    double salariu;} A, B;", h);
    text("da", "(am declarat odata cu tipul de date Persoana si doua variable A si B de acest tip), sau", h);
    text("nu", "putem sa le declaram ulterior declararii tipului de date, astfel:", h);
    text("da", "Aceasta declarare este corecta in C++, dar nu este corecta in C:", h);
    text("da", "Persoana A, B;", h);
    text("da", "sau", h);
    text("da", "Aceasta declarare este corecta atat in C++ cat si in C:", h);
    text("da", "struct Persoana A, B;", h);



    while(true){
             setcolor(WHITE);
    rectangle(XE / 2 - 105, YE - 150, XE / 2 + 113, YE - 100);
    settextstyle(6, 0 , 3);
    outtextxy(XE / 2 - 100, YE - 135, "Pagina 2 din 5");
    setcolor(WHITE);
        if(pga == 0)
           pga = intoarcere();
        if(pga == 1){
            return 2;
        }
        //sageata stanga
        line(XE / 2 - 150, YE - 125, XE / 2 - 125, YE - 100);
        line(XE / 2 - 150, YE - 125, XE / 2 - 125, YE - 150);
        if(!(mousex() > XE / 2 - 150 && mousex() < XE / 2 - 125 && mousey() > YE - 150 && mousey() < YE - 100) && GetAsyncKeyState(VK_LBUTTON))
            clearmouseclick(WM_LBUTTONDOWN);
        while(mousex() > XE / 2 - 150 && mousex() < XE / 2 - 125 && mousey() > YE - 150 && mousey() < YE - 100){
            setcolor(RGB(118,47,5));
            line(XE / 2 - 150, YE - 125, XE / 2 - 125, YE - 100);
            line(XE / 2 - 150, YE - 125, XE / 2 - 125, YE - 150);
            if(GetAsyncKeyState(VK_LBUTTON)){
                clearmouseclick(WM_LBUTTONDOWN);
                return 1;
            }
        }
        //sageata dreapta
        setcolor(WHITE);
        line(XE / 2 + 158, YE - 125, XE / 2 + 133, YE - 100);
        line(XE / 2 + 158, YE - 125, XE / 2 + 133, YE - 150);
        if(!(mousex() > XE / 2 + 133 && mousex() < XE / 2 + 158 && mousey() > YE - 150 && mousey() < YE - 100) && GetAsyncKeyState(VK_LBUTTON))
            clearmouseclick(WM_LBUTTONDOWN);
        while(mousex() > XE / 2 + 133 && mousex() < XE / 2 + 158 && mousey() > YE - 150 && mousey() < YE - 100){
            if(GetAsyncKeyState(VK_LBUTTON)){
                fnc = pag35();
                if(fnc == 1){
                        fnc = 0;
                        delay(300);
                        h = YE / 3 - 150;
                        clearmouseclick(WM_LBUTTONDOWN);
                        delay(200);
                        setbkcolor(RGB(196,192,251));
                        cleardevice();
                        setcolor(RGB(65,0,36));
    settextstyle(6, 0, 17);
    outtextxy(XE / 2 - 240, 50, "Tipul inregistrare");

    text("da", "In acest mod s-a declarat un tip de date cu numele NUME_STRUCTURA si eventual niste ", h);
    text("nu", "variabile de acest tip. In continuare NUME_STRUCTURA poate fi folosit ca un tip de date oarecare,", h);
    text("nu", "de exemplu pentru a declara variabile sau in lista parametrilor formali ai unei functii.", h);
    text("da", "Pentru exemplul dat mai sus, declararea va fi:", h);
    text("da", "struct Persoana{", h);
    text("da", "    char nume[21], prenume[21], sex;", h);
    text("da", "    int varsta;", h);
    text("da", "    double salariu;};", h);
    text("da", "S-a declarat o structura cu numele Persoana, dar nu s-a declarat nicio variabila de acest ", h);
    text("da", "tip. Pentru a declara variabile de tip Persoana putem sa le adaugam la declararea structurii:", h);
    text("da", "struct Persoana{", h);
    text("da", "    char nume[21], prenume[21], sex;", h);
    text("da", "    char nume[21], prenume[21], sex;", h);
    text("da", "    double salariu;} A, B;", h);
    text("da", "(am declarat odata cu tipul de date Persoana si doua variable A si B de acest tip), sau", h);
    text("nu", "putem sa le declaram ulterior declararii tipului de date, astfel:", h);
    text("da", "Aceasta declarare este corecta in C++, dar nu este corecta in C:", h);
    text("da", "Persoana A, B;", h);
    text("da", "sau", h);
    text("da", "Aceasta declarare este corecta atat in C++ cat si in C:", h);
    text("da", "struct Persoana A, B;", h);

                        setcolor(WHITE);
                        rectangle(XE / 2 - 105, YE - 150, XE / 2 + 113, YE - 100);
                        settextstyle(6, 0 , 3);
                        outtextxy(XE / 2 - 100, YE - 135, "Pagina 2 din 5");
                        setcolor(WHITE);
                        break;
                    }
                else if(fnc == 2){
                       return 2;
                }
                clearmouseclick(WM_LBUTTONDOWN);
            }
            setcolor(RGB(118,47,5));
            line(XE / 2 + 158, YE - 125, XE / 2 + 133, YE - 100);
            line(XE / 2 + 158, YE - 125, XE / 2 + 133, YE - 150);
        }
        setcolor(WHITE);
        clearmouseclick(WM_LBUTTONDOWN);

    }
}
int pag15(){
    int h = YE / 3 - 150;
    cleardevice();
    clearmouseclick(WM_LBUTTONDOWN);
    setbkcolor(RGB(196,192,251));
    cleardevice();
setcolor(RGB(65,0,36));
    settextstyle(6, 0, 17);
    outtextxy(XE / 2 - 240, 50, "Tipul inregistrare");

    text("da", "De multe ori datele folosite intr-un program caracterizeaza obiecte/fenomene din realizate,iar", h);
    text("nu", "acestea au mai multe caracteristici decat un simplu numar sau un sir de caractere.", h);
    text("nu", "De exemplu, o persoana poate fi caracterizata prin cateva informatii:", h);
    text("nu", "•	nume – sir de caractere", h);
    text("nu", "•	prenume – sir de caractere", h);
    text("nu", "•	sex – (M/F) probabil caracter", h);
    text("nu", "•	varsta – numar natural", h);
    text("nu", "•	salariu – numar real", h);
    text("da", "Pentru a gestiona informatiile despre o persoana avem nevoie de (cel putin) 5 variabile, cate", h);
    text("nu", "una pentru fiecare informatie caracteristica a persoanelor: nume, prenume, etc., iar daca am", h);
    text("nu", "prelucra informatii despre n persoane am avea nevoie de 5 vectori cu n elemente,corespunzatoare", h);
    text("nu", "acelor persoane. Elementele vectorilor trebuie sincronizate, ceea ce devine foarte complicat si", h);
    text("nu", "obositor. Ar fi mult mai simplu daca am putea grupa toate acesteinformatii specifice unei", h);
    text("nu", "persoane intr-o singura variabila.", h);
    text("da", "Acest lucru este posibil in C/C++, folosind tipul de date struct, prin care vom defini o", h);
    text("nu", "structura. O data de tip structura inglobeaza mai multe date componente, numite campuri", h);
    text("nu", "sau membri sau date membre, fiecare de un anumit tip precizat la definitia tipului structura", h);
    text("nu", "corespunzator. Fiecare camp memoreaza o anumita valoare, care poate fi tratata ca ", h);
    text("nu", "o variabila oarecare de tipul corespunzator (i se pot aplica citiri, afisari,atribuiri,etc.).", h);
    text("da", "Sintaxa generala a declararii unui tip de date struct este urmatoarea:", h);
    text("da", "struct [NUME_STRUCTURA]", h);
    text("da", "{[TIP1 NUME_CAMP[, NUME_CAMP[, ...]];]", h);
    text("da", "[TIP2 NUME_CAMP[, NUME_CAMP[, ...]];]", h);
    text("da", "    ...} [LISTA DE VARIABILE];", h);


    while(true){
            setcolor(WHITE);
                    settextstyle(6, 0 , 3);
                    outtextxy(XE / 2 - 100, YE - 135, "Pagina 1 din 5");
                    rectangle(XE / 2 - 105, YE - 150, XE / 2 + 113, YE - 100);
        if(pga == 0)
            pga = intoarcere();
        else
            return 1;
        //sageata dreapta
        setcolor(WHITE);
        line(XE / 2 + 158, YE - 125, XE / 2 + 133, YE - 100);
        line(XE / 2 + 158, YE - 125, XE / 2 + 133, YE - 150);
        if(!(mousex() > XE / 2 + 133 && mousex() < XE / 2 + 158 && mousey() > YE - 150 && mousey() < YE - 100) && GetAsyncKeyState(VK_LBUTTON))
            clearmouseclick(WM_LBUTTONDOWN);
        while(mousex() > XE / 2 + 133 && mousex() < XE / 2 + 158 && mousey() > YE - 150 && mousey() < YE - 100){
            if(GetAsyncKeyState(VK_LBUTTON)){
                clearmouseclick(WM_LBUTTONDOWN);
                fnc = pag25();
                if(fnc == 1){
                    fnc = 0;
                    h = YE / 3 - 150;
                    clearmouseclick(WM_LBUTTONDOWN);
                    setbkcolor(RGB(196,192,251));
                    cleardevice();
                    setcolor(RGB(65,0,36));
    settextstyle(6, 0, 17);
    outtextxy(XE / 2 - 240, 50, "Tipul inregistrare");
    text("da", "De multe ori datele folosite intr-un program caracterizeaza obiecte/fenomene din realizate,iar", h);
    text("nu", "acestea au mai multe caracteristici decat un simplu numar sau un sir de caractere.", h);
    text("nu", "De exemplu, o persoana poate fi caracterizata prin cateva informatii:", h);
    text("nu", "•	nume – sir de caractere", h);
    text("nu", "•	prenume – sir de caractere", h);
    text("nu", "•	sex – (M/F) probabil caracter", h);
    text("nu", "•	varsta – numar natural", h);
    text("nu", "•	salariu – numar real", h);
    text("da", "Pentru a gestiona informatiile despre o persoana avem nevoie de (cel putin) 5 variabile, cate", h);
    text("nu", "una pentru fiecare informatie caracteristica a persoanelor: nume, prenume, etc., iar daca am", h);
    text("nu", "prelucra informatii despre n persoane am avea nevoie de 5 vectori cu n elemente,corespunzatoare", h);
    text("nu", "acelor persoane. Elementele vectorilor trebuie sincronizate, ceea ce devine foarte complicat si", h);
    text("nu", "obositor. Ar fi mult mai simplu daca am putea grupa toate acesteinformatii specifice unei", h);
    text("nu", "persoane intr-o singura variabila.", h);
    text("da", "Acest lucru este posibil in C/C++, folosind tipul de date struct, prin care vom defini o", h);
    text("nu", "structura. O data de tip structura inglobeaza mai multe date componente, numite campuri", h);
    text("nu", "sau membri sau date membre, fiecare de un anumit tip precizat la definitia tipului structura", h);
    text("nu", "corespunzator. Fiecare camp memoreaza o anumita valoare, care poate fi tratata ca ", h);
    text("nu", "o variabila oarecare de tipul corespunzator (i se pot aplica citiri, afisari,atribuiri,etc.).", h);
    text("da", "Sintaxa generala a declararii unui tip de date struct este urmatoarea:", h);
    text("da", "struct [NUME_STRUCTURA]", h);
    text("da", "{[TIP1 NUME_CAMP[, NUME_CAMP[, ...]];]", h);
    text("da", "[TIP2 NUME_CAMP[, NUME_CAMP[, ...]];]", h);
    text("da", "    ...} [LISTA DE VARIABILE];", h);

                    setcolor(WHITE);
                    rectangle(XE / 2 - 105, YE - 150, XE / 2 + 113, YE - 100);
                    settextstyle(6, 0 , 3);
                    outtextxy(XE / 2 - 95, YE - 135, "Pagina 1 din 5");
                    break;
                }
                if(fnc == 2){
                    return 0;
                }
            }
            setcolor(RGB(118,47,5));
            line(XE / 2 + 158, YE - 125, XE / 2 + 133, YE - 100);
            line(XE / 2 + 158, YE - 125, XE / 2 + 133, YE - 150);
        }
        setcolor(WHITE);
    }
}

int pag76(){
    int h7 = YE / 3 - 200;
    clearmouseclick(WM_LBUTTONDOWN);
    delay(200);
    setbkcolor(RGB(196,192,251));
    cleardevice();
    setcolor(RGB(65,0,36));
    settextstyle(6, 0, 17);
    outtextxy(XE / 2 - 240, 50, "Subprograme");
    setcolor(WHITE);
    rectangle(XE / 2 - 105, YE - 150, XE / 2 + 113, YE - 100);
    settextstyle(6, 0 , 3);
    outtextxy(XE / 2 - 95, YE - 135, "Pagina 7 din 7");
    text("nu", "In programul de mai sus variabilele x si y sunt globale. Variabila x poate fi utilizata atat in functia main() cat si in F(), iar variabila ", h7);
    text("nu", "y numai in main().", h7);
    h7 += 25;
    text("nu", "Variabilele globale respecta urmatoarele reguli:", h7);
    text("da", "•	li se aloca memorie in zona de date", h7);
    text("da", "•	sunt vizibile in toate functiile care urmeaza in codul sursa declararii lor", h7);
    text("da", "•	durata de viata a lotr este executia intregului program", h7);
    text("da", "•	sunt initializate cu valoarea 0.", h7);
    text("nu", "#include <iostream>", h7);
    text("nu", "using namespace std;", h7);
    text("nu", "int x;", h7);
    text("nu", "void F(){", h7);
    text("nu", "    cout << x << endl; //5, variabila globala", h7);
    text("nu", "    int x = 10;", h7);
    text("nu", "    cout << x << endl; //10, variabila locala in F()", h7);
    text("nu", "    {", h7);
    text("nu", "        int x = 20;", h7);
    text("nu", "        cout << x << endl; //20, variabila locala in F(), blocul interior", h7);
    text("nu", "    }", h7);
    text("nu", "    cout << x << endl; //10, variabila locala in F()", h7);
    text("nu", "}", h7);
    text("nu", "int y;", h7);
    text("nu", "int main(){", h7);
    text("nu", "    cout << x << endl; //0, variabila globala", h7);
    text("nu", "    x = 5;", h7);
    text("nu", "    cout << x << endl; //5, variabila globala", h7);
    text("nu", "    F();", h7);
    text("nu", "    cout << x << endl; //5, variabila globala", h7);
    text("nu", "    int x = 100;", h7);
    text("nu", " cout << x << endl; //100, variabila locala in main()", h7);
    text("nu", "    return 0;", h7);
    text("nu", "}", h7);
    while(true){
        if(pga == 0)
           pga = intoarcere();
        if(pga == 1){
             pga = 0;
            return 2;
        }
        clearmouseclick(WM_LBUTTONDOWN);
        //sageata stanga
        line(XE / 2 - 150, YE - 125, XE / 2 - 125, YE - 100);
        line(XE / 2 - 150, YE - 125, XE / 2 - 125, YE - 150);
        if(!(mousex() > XE / 2 - 150 && mousex() < XE / 2 - 125 && mousey() > YE - 150 && mousey() < YE - 100) && GetAsyncKeyState(VK_LBUTTON))
            clearmouseclick(WM_LBUTTONDOWN);
        while(mousex() > XE / 2 - 150 && mousex() < XE / 2 - 125 && mousey() > YE - 150 && mousey() < YE - 100){
            setcolor(RGB(118,47,5));
            line(XE / 2 - 150, YE - 125, XE / 2 - 125, YE - 100);
            line(XE / 2 - 150, YE - 125, XE / 2 - 125, YE - 150);
            if(GetAsyncKeyState(VK_LBUTTON)){
                clearmouseclick(WM_LBUTTONDOWN);
                return 1;
            }
        }
    }
}

int pag94(){// pag72() adica pag 7 lectia 2, schimbati voi in functie de unde sunteti
    int h = YE / 3 - 200;
    clearmouseclick(WM_LBUTTONDOWN);
    delay(200);
    setbkcolor(RGB(196,192,251));
    cleardevice();
    setcolor(RGB(65,0,36));
    settextstyle(6, 0, 17);
    outtextxy(XE / 2 - 400, 50, "Tablouri bidimensionale");
    outtextxy( 50, h, "Diagonala secundara");

    setcolor(RGB(60,56,153));
    settextstyle(10, 0 , 5);
    readimagefile("poza 6.jpg", 150, h + 150, 550, h + 400);
    h+=410;
    text("da", "i + j = n - 1",h);
    text("da", "Parcurgerea elementelor de pe diagonala secundara:",h);
    text("da", "for(int i = 0 ; i < n ; i ++)",h);
    text("da", "{",h);
    text("da", "    // A[i][n - 1 - i]",h);
    text("da", "}",h);
    text("da", "//indexare de la 1",h);
    text("da", "for(int i = 1 ; i <= n ; i ++)",h);
    text("da", "{",h);
    text("da", "    // A[i][n + 1 - i]",h);
    text("da", "}",h);

    while(true){
	setcolor(WHITE);
		rectangle(XE / 2 - 105, YE - 150, XE / 2 + 113, YE - 100);
		settextstyle(6, 0 , 3);
		outtextxy(XE / 2 - 100, YE - 135, "Pagina 9	din 9");
        if(pga == 0)
           pga = intoarcere();
        if(pga == 1){
            return 2;
        }
        clearmouseclick(WM_LBUTTONDOWN);
        //sageata stanga
        line(XE / 2 - 150, YE - 125, XE / 2 - 125, YE - 100);
        line(XE / 2 - 150, YE - 125, XE / 2 - 125, YE - 150);
        if(!(mousex() > XE / 2 - 150 && mousex() < XE / 2 - 125 && mousey() > YE - 150 && mousey() < YE - 100) && GetAsyncKeyState(VK_LBUTTON))
            clearmouseclick(WM_LBUTTONDOWN);
        while(mousex() > XE / 2 - 150 && mousex() < XE / 2 - 125 && mousey() > YE - 150 && mousey() < YE - 100){
            setcolor(RGB(118,47,5));
            line(XE / 2 - 150, YE - 125, XE / 2 - 125, YE - 100);
            line(XE / 2 - 150, YE - 125, XE / 2 - 125, YE - 150);
            if(GetAsyncKeyState(VK_LBUTTON)){
                clearmouseclick(WM_LBUTTONDOWN);
                return 1;
            }
        }
    }
}

int pag84(){// pag72() adica pag 7 lectia 2, schimbati voi in functie de unde sunteti
    int h = YE / 3 - 200;
    clearmouseclick(WM_LBUTTONDOWN);
    delay(200);
    setbkcolor(RGB(196,192,251));
    cleardevice();
    setcolor(RGB(65,0,36));
    settextstyle(6, 0, 17);
    outtextxy(XE / 2 - 400, 50, "Tablouri bidimensionale");
    outtextxy( 50, h, "Diagonala principala");
    h+=60;
    setcolor(RGB(60,56,153));
    settextstyle(10, 0 , 5);
    text("da", "Indexare de la 0",h);
    readimagefile("poza 54.jpg", 150, h , 550, h + 250);
    readimagefile("poza 44.jpg", 850, h, 1350, h + 250);
    setcolor(RGB(60,56,153));
    settextstyle(10, 0 , 5);
    h+=270;
    text("da", "i=j",h);
    text("da", "Parcurgerea elementelor de pe diagonala principala:",h);
    text("da", "for(int i = 0 ; i < n ; i ++)",h);
    text("da", "{",h);
    text("da", "// A[i][i]",h);
    text("da", "}",h);



    while(true){
		setcolor(WHITE);
		rectangle(XE / 2 - 105, YE - 150, XE / 2 + 113, YE - 100);
		settextstyle(6, 0 , 3);
		outtextxy(XE / 2 - 100, YE - 135, "Pagina 8	din 9");
        if(pga == 0)
           pga = intoarcere();
        if(pga == 1){
            return 2;
        }
        clearmouseclick(WM_LBUTTONDOWN);
        //sageata stanga
        line(XE / 2 - 150, YE - 125, XE / 2 - 125, YE - 100);
        line(XE / 2 - 150, YE - 125, XE / 2 - 125, YE - 150);
        if(!(mousex() > XE / 2 - 150 && mousex() < XE / 2 - 125 && mousey() > YE - 150 && mousey() < YE - 100) && GetAsyncKeyState(VK_LBUTTON))
            clearmouseclick(WM_LBUTTONDOWN);
        while(mousex() > XE / 2 - 150 && mousex() < XE / 2 - 125 && mousey() > YE - 150 && mousey() < YE - 100){
            setcolor(RGB(118,47,5));
            line(XE / 2 - 150, YE - 125, XE / 2 - 125, YE - 100);
            line(XE / 2 - 150, YE - 125, XE / 2 - 125, YE - 150);
            if(GetAsyncKeyState(VK_LBUTTON)){
                clearmouseclick(WM_LBUTTONDOWN);
                return 1;
            }
        }
        setcolor(WHITE);
        line(XE / 2 + 158, YE - 125, XE / 2 + 133, YE - 100);
        line(XE / 2 + 158, YE - 125, XE / 2 + 133, YE - 150);
        if(!(mousex() > XE / 2 + 133 && mousex() < XE / 2 + 158 && mousey() > YE - 150 && mousey() < YE - 100) && GetAsyncKeyState(VK_LBUTTON))
            clearmouseclick(WM_LBUTTONDOWN);
        while(mousex() > XE / 2 + 133 && mousex() < XE / 2 + 158 && mousey() > YE - 150 && mousey() < YE - 100){
            if(GetAsyncKeyState(VK_LBUTTON)){
                fnc = pag94();
                if(fnc == 1){
                    delay(200);
                    h = YE / 3 - 200;
                    setbkcolor(RGB(196,192,251));
                    cleardevice();
                    setcolor(WHITE);
                    line(XE / 2 + 158, YE - 125, XE / 2 + 133, YE - 100);
                    line(XE / 2 + 158, YE - 125, XE / 2 + 133, YE - 150);
					 setbkcolor(RGB(196,192,251));
                    cleardevice();
                    setcolor(RGB(65,0,36));
                    settextstyle(6, 0, 17);
                    outtextxy(XE / 2 - 400, 50, "Tablouri bidimensionale");
                    outtextxy( 50, h, "Diagonala principala");
                    h+=60;
                    setcolor(WHITE);
                    rectangle(XE / 2 - 105, YE - 150, XE / 2 + 113, YE - 100);
                    settextstyle(6, 0 , 3);
                    outtextxy(XE / 2 - 100, YE - 135, "Pagina 8 din 9");
                    setcolor(RGB(60,56,153));
                    settextstyle(10, 0 , 5);
                    text("da", "Indexare de la 0",h);
                    readimagefile("poza 54.jpg", 150, h , 550, h + 250);
                    readimagefile("poza 44.jpg", 850, h, 1350, h + 250);
                    setcolor(RGB(60,56,153));
                    settextstyle(10, 0 , 5);
                    h+=270;
                    text("da", "i=j",h);
                    text("da", "Parcurgerea elementelor de pe diagonala principala:",h);
                    text("da", "for(int i = 0 ; i < n ; i ++)",h);
                    text("da", "{",h);
                    text("da", "// A[i][i]",h);
                    text("da", "}",h);

					break;
                }
                else if(fnc == 2){
                    return 2;
                }
            }
        }
    }
}

int pag74(){// pag72() adica pag 7 lectia 2, schimbati voi in functie de unde sunteti
    int h = YE / 3 - 200;
    clearmouseclick(WM_LBUTTONDOWN);
    delay(200);
    setbkcolor(RGB(196,192,251));
    cleardevice();
    setcolor(RGB(65,0,36));
    settextstyle(6, 0, 17);
    outtextxy(XE / 2 - 400, 50, "Tablouri bidimensionale");
    outtextxy( 30, h, "Tablouri patratice");

    h+=50;
    text("da", "Un tablou bidimensional este tablou patratic sau matrice patratica daca numarul de linii este egal",h);
    text("nu", "cu numarul de coloane.",h);
    text("da", "In aceasta situatie folosim pentru ambele dimensiuni o singura variabila, de regula n:",h);
    text("da", "int n, A[100][100];",h);
    text("da", "Exemplu:",h);
    text("da", "Matrice patratica indexata de la 0",h);
    readimagefile("poza 44.jpg", 850, h + 130, 1350, h + 480);
    h+=270;
    setcolor(RGB(60,56,153));
    settextstyle(10, 0 , 5);
    text("da", "Intr-o matrice patratica se disting o categorie speciala",h);
    text("nu", "de elemente, diagonalele. Un element al matricei apartine",h);
    text("nu", "sau nu diagonalelor sau zonelor delimitate de acestea daca",h);
    text("nu", "respecta anumite reguli, in care intervin indicii",h);
    text("nu", "elementului, nu valoarea elementului. In cele ce urmeaza,",h);
    text("nu", "pentru un element oarecare al matricei vom nota cu i",h);
    text("nu", "indicele de linie si cu j indicele de coloana.",h);
    while(true){
		setcolor(WHITE);
		rectangle(XE / 2 - 105, YE - 150, XE / 2 + 113, YE - 100);
		settextstyle(6, 0 , 3);
		outtextxy(XE / 2 - 100, YE - 135, "Pagina 7	din 9");
        if(pga == 0)
           pga = intoarcere();
        if(pga == 1){
            return 2;
        }
        clearmouseclick(WM_LBUTTONDOWN);
        //sageata stanga
        line(XE / 2 - 150, YE - 125, XE / 2 - 125, YE - 100);
        line(XE / 2 - 150, YE - 125, XE / 2 - 125, YE - 150);
        if(!(mousex() > XE / 2 - 150 && mousex() < XE / 2 - 125 && mousey() > YE - 150 && mousey() < YE - 100) && GetAsyncKeyState(VK_LBUTTON))
            clearmouseclick(WM_LBUTTONDOWN);
        while(mousex() > XE / 2 - 150 && mousex() < XE / 2 - 125 && mousey() > YE - 150 && mousey() < YE - 100){
            setcolor(RGB(118,47,5));
            line(XE / 2 - 150, YE - 125, XE / 2 - 125, YE - 100);
            line(XE / 2 - 150, YE - 125, XE / 2 - 125, YE - 150);
            if(GetAsyncKeyState(VK_LBUTTON)){
                clearmouseclick(WM_LBUTTONDOWN);
                return 1;
            }
        }
        setcolor(WHITE);
        line(XE / 2 + 158, YE - 125, XE / 2 + 133, YE - 100);
        line(XE / 2 + 158, YE - 125, XE / 2 + 133, YE - 150);
        if(!(mousex() > XE / 2 + 133 && mousex() < XE / 2 + 158 && mousey() > YE - 150 && mousey() < YE - 100) && GetAsyncKeyState(VK_LBUTTON))
            clearmouseclick(WM_LBUTTONDOWN);
        while(mousex() > XE / 2 + 133 && mousex() < XE / 2 + 158 && mousey() > YE - 150 && mousey() < YE - 100){
            if(GetAsyncKeyState(VK_LBUTTON)){
                fnc = pag84();
                if(fnc == 1){
                    delay(200);
                    setbkcolor(RGB(196,192,251));
                    cleardevice();
                    setcolor(WHITE);
                    h = YE / 3 - 200;
                    line(XE / 2 + 158, YE - 125, XE / 2 + 133, YE - 100);
                    line(XE / 2 + 158, YE - 125, XE / 2 + 133, YE - 150);
					setbkcolor(RGB(196,192,251));
    cleardevice();
    setcolor(RGB(65,0,36));
    settextstyle(6, 0, 17);
    outtextxy(XE / 2 - 400, 50, "Tablouri bidimensionale");
    outtextxy( 30, h, "Tablouri patratice");

    h+=50;
    text("da", "Un tablou bidimensional este tablou patratic sau matrice patratica daca numarul de linii este egal",h);
    text("nu", "cu numarul de coloane.",h);
    text("da", "In aceasta situatie folosim pentru ambele dimensiuni o singura variabila, de regula n:",h);
    text("da", "int n, A[100][100];",h);
    text("da", "Exemplu:",h);
    text("da", "Matrice patratica indexata de la 0",h);
    readimagefile("poza 44.jpg", 850, h + 130, 1350, h + 480);
    h+=270;
    setcolor(RGB(60,56,153));
    settextstyle(10, 0 , 5);
    text("da", "Intr-o matrice patratica se disting o categorie speciala",h);
    text("nu", "de elemente, diagonalele. Un element al matricei apartine",h);
    text("nu", "sau nu diagonalelor sau zonelor delimitate de acestea daca",h);
    text("nu", "respecta anumite reguli, in care intervin indicii",h);
    text("nu", "elementului, nu valoarea elementului. In cele ce urmeaza,",h);
    text("nu", "pentru un element oarecare al matricei vom nota cu i",h);
    text("nu", "indicele de linie si cu j indicele de coloana.",h);
					break;
                }
                else if(fnc == 2){
                    return 2;
                }
            }
        }
    }
}


int pag64(){// pag72() adica pag 7 lectia 2, schimbati voi in functie de unde sunteti
    int h = YE / 3 - 200;
    clearmouseclick(WM_LBUTTONDOWN);
    delay(200);
    setbkcolor(RGB(196,192,251));
    cleardevice();
    setcolor(RGB(65,0,36));
    settextstyle(6, 0, 17);
    outtextxy(XE / 2 - 400, 50, "Tablouri bidimensionale");
    outtextxy( 30, h, "Afisarea unei matrice");
    setcolor(WHITE);
    rectangle(XE / 2 - 105, YE - 150, XE / 2 + 113, YE - 100);
    settextstyle(6, 0 , 3);
    h+=50;
    text("da", "Pentru a obtine aspectul specific tabloului bidimensional, dupa afisarea elementelor de fiecare linie",h);
    text("nu", "vom trece la linia urmatoare a ecranului. Elementele fiecarei linii sunt de regula separate printr-un",h);
    text("nu", "spatiu:",h);
    text("da", "for(int i = 0 ; i < n ; i ++)",h);
    text("da", "{",h);
    text("da", "    for(int j = 0 ; j < m ; j ++)",h);
    text("da", "        cout << A[i][j] << " ";",h);
    text("da", "    cout << endl;",h);
    readimagefile("poza 24.jpg", 40, h - 30, 500, h + 280);
    while(true){
	setcolor(WHITE);
		rectangle(XE / 2 - 105, YE - 150, XE / 2 + 113, YE - 100);
		settextstyle(6, 0 , 3);
		outtextxy(XE / 2 - 100, YE - 135, "Pagina 6	din 9");
        if(pga == 0)
           pga = intoarcere();
        if(pga == 1){
            return 2;
        }
        clearmouseclick(WM_LBUTTONDOWN);
        //sageata stanga
        line(XE / 2 - 150, YE - 125, XE / 2 - 125, YE - 100);
        line(XE / 2 - 150, YE - 125, XE / 2 - 125, YE - 150);
        if(!(mousex() > XE / 2 - 150 && mousex() < XE / 2 - 125 && mousey() > YE - 150 && mousey() < YE - 100) && GetAsyncKeyState(VK_LBUTTON))
            clearmouseclick(WM_LBUTTONDOWN);
        while(mousex() > XE / 2 - 150 && mousex() < XE / 2 - 125 && mousey() > YE - 150 && mousey() < YE - 100){
            setcolor(RGB(118,47,5));
            line(XE / 2 - 150, YE - 125, XE / 2 - 125, YE - 100);
            line(XE / 2 - 150, YE - 125, XE / 2 - 125, YE - 150);
            if(GetAsyncKeyState(VK_LBUTTON)){
                clearmouseclick(WM_LBUTTONDOWN);
                return 1;
            }
        }
        setcolor(WHITE);
        line(XE / 2 + 158, YE - 125, XE / 2 + 133, YE - 100);
        line(XE / 2 + 158, YE - 125, XE / 2 + 133, YE - 150);
        if(!(mousex() > XE / 2 + 133 && mousex() < XE / 2 + 158 && mousey() > YE - 150 && mousey() < YE - 100) && GetAsyncKeyState(VK_LBUTTON))
            clearmouseclick(WM_LBUTTONDOWN);
        while(mousex() > XE / 2 + 133 && mousex() < XE / 2 + 158 && mousey() > YE - 150 && mousey() < YE - 100){
            if(GetAsyncKeyState(VK_LBUTTON)){
                fnc = pag74();
                if(fnc == 1){
                    delay(200);
                    setbkcolor(RGB(196,192,251));
                    cleardevice();
                    h = YE / 3 - 200;
                    setcolor(WHITE);
                    line(XE / 2 + 158, YE - 125, XE / 2 + 133, YE - 100);
                    line(XE / 2 + 158, YE - 125, XE / 2 + 133, YE - 150);
					setbkcolor(RGB(196,192,251));
    cleardevice();
    setcolor(RGB(65,0,36));
    settextstyle(6, 0, 17);
    outtextxy(XE / 2 - 400, 50, "Tablouri bidimensionale");
    outtextxy( 30, h, "Afisarea unei matrice");
    setcolor(WHITE);
    rectangle(XE / 2 - 105, YE - 150, XE / 2 + 113, YE - 100);
    settextstyle(6, 0 , 3);
    h+=50;
    text("da", "Pentru a obtine aspectul specific tabloului bidimensional, dupa afisarea elementelor de fiecare linie",h);
    text("nu", "vom trece la linia urmatoare a ecranului. Elementele fiecarei linii sunt de regula separate printr-un",h);
    text("nu", "spatiu:",h);
    text("da", "for(int i = 0 ; i < n ; i ++)",h);
    text("da", "{",h);
    text("da", "    for(int j = 0 ; j < m ; j ++)",h);
    text("da", "        cout << A[i][j] << " ";",h);
    text("da", "    cout << endl;",h);
    readimagefile("poza 24.jpg", 40, h - 30, 500, h + 280);
	break;
                }
                else if(fnc == 2){
                    return 2;
                }
            }
        }
    }
}

int pag73(){// pag72() adica pag 7 lectia 2, schimbati voi in functie de unde sunteti
    int h = YE / 3 - 200;
    clearmouseclick(WM_LBUTTONDOWN);
    delay(200);
    setbkcolor(RGB(196,192,251));
    cleardevice();
        setcolor(RGB(65,0,36));
    settextstyle(6, 0, 17);
    outtextxy(XE / 2 - 400, 50, "Tablouri unidimensionale");
    ///setcolor(RGB(60,56,153));
    ///settextstyle(10, 0 , 5);
    ///outtextxy( 50, YE / 3 - 180, "");
    ///h+=20;
    text("da", "Daca tabloul este indexat de la 1 la n, apelul va fi:", h);
    text("da", "sort(A + 1, A + n + 1);",h);
    text("da", "Apelurile de mai sus sorteaza crescator elementele secventei/tabloului.", h);
    setcolor(RGB(60,56,153));
    settextstyle(10, 0 , 5);
    outtextxy( 50, h, "Ordonarea descrescatoare");
    h+=40;
    text("da", "Pentru a sorta descrescator elementele secventei delimitate de indicii s si d in tabloul A", h);
    text("nu", "cu elemente de tip int, se transmite functiei sort un parametru suplimentar, astfel:",h);
    text("da", "sort(A + s, A + d + 1, greater<int>());", h);
    text("da", "Daca elementele tabloului A sunt de tip double, apelul va fi:", h);
    text("da", "sort(A + s, A + d + 1, greater<double>());",h);



    while(true){
        setcolor(WHITE);
        rectangle(XE / 2 - 105, YE - 150, XE / 2 + 113, YE - 100);
        settextstyle(6, 0 , 3);
        outtextxy(XE / 2 - 100, YE - 135, "Pagina 7 din 7");
        if(pga == 0)
           pga = intoarcere();
        if(pga == 1){
            return 2;
        }
        clearmouseclick(WM_LBUTTONDOWN);
        //sageata stanga
        line(XE / 2 - 150, YE - 125, XE / 2 - 125, YE - 100);
        line(XE / 2 - 150, YE - 125, XE / 2 - 125, YE - 150);
        if(!(mousex() > XE / 2 - 150 && mousex() < XE / 2 - 125 && mousey() > YE - 150 && mousey() < YE - 100) && GetAsyncKeyState(VK_LBUTTON))
            clearmouseclick(WM_LBUTTONDOWN);
        while(mousex() > XE / 2 - 150 && mousex() < XE / 2 - 125 && mousey() > YE - 150 && mousey() < YE - 100){
            setcolor(RGB(118,47,5));
            line(XE / 2 - 150, YE - 125, XE / 2 - 125, YE - 100);
            line(XE / 2 - 150, YE - 125, XE / 2 - 125, YE - 150);
            if(GetAsyncKeyState(VK_LBUTTON)){
                clearmouseclick(WM_LBUTTONDOWN);
                return 1;
            }
        }
    }
}
int pag63(){
    int h = YE / 3 - 150;
    clearmouseclick(WM_LBUTTONDOWN);
    delay(200);
    setbkcolor(RGB(196,192,251));
    cleardevice();

    setcolor(RGB(65,0,36));
    settextstyle(6, 0, 17);
    outtextxy(XE / 2 - 400, 50, "Tablouri unidimensionale");
    ///setcolor(RGB(60,56,153));
    ///settextstyle(10, 0 , 5);
    ///outtextxy( 50, YE / 3 - 180, "");
    ///h+=20;
    text("da", "int n, X[100];", h);
    text("da", "//citire X[] cu n elemente", h);
    text("da", "for(int i = 0 ; i < n - 1 ; i ++)", h);
    text("da", "    for(int j = i + 1 ; j < n ; j ++)", h);
    text("da", "        if(X[i] > X[j])", h);
    text("da", "            {int aux = X[i];", h);
    text("da", "            X[i] = X[j];", h);
    text("da", "            X[j] = aux;}", h);
    text("da", "Algoritmul descris mai sus se mai numeste sortare prin selectie generala, sau implicita.", h);
    text("da", "Standard Template Library-STL contine o functie ce realizeaza sortarea eficienta a unui tablou,sort.", h);
    text("nu", "Ea poate fi folosita atat pentru sortarea unui vector STL, cat si pentru sortarea unui tablou standard C.", h);
    text("nu", "Elementele tabloului pot avea orice tip pe care este definita operatia <.", h);
    text("da", "Functia sort este declarata in header-ul algorithm, care trebuie inclus in programul sursa:", h);
    text("nu", "#include <algorithm>", h);
    setcolor(RGB(60,56,153));
    settextstyle(10, 0 , 5);
    outtextxy( 50, h, "Ordonarea crescatoare");
    h+=40;
    text("da", "Functia sort permite sortarea unei secvente a tabloului. Pentru a sorta in tabloul A secventa", h);
    text("nu", "delimitata de indicii s si d (inclusiv acestia), se face apelul:", h);
    text("da", "sort(A + s, A + d + 1);", h);
    text("da", "Daca se doreste sortarea unui tablou A cu n elemente, indexate de la 0 la n-1, apelul va fi:", h);
    text("da", "sort(A, A + n);", h);



    while(true){
         setcolor(WHITE);
        rectangle(XE / 2 - 105, YE - 150, XE / 2 + 113, YE - 100);
        settextstyle(6, 0 , 3);
        outtextxy(XE / 2 - 100, YE - 135, "Pagina 6 din 7");
        if(pga == 0)
           pga = intoarcere();
        if(pga == 1){
            return 2;
        }
        clearmouseclick(WM_LBUTTONDOWN);
        //sageata stanga
        line(XE / 2 - 150, YE - 125, XE / 2 - 125, YE - 100);
        line(XE / 2 - 150, YE - 125, XE / 2 - 125, YE - 150);
        if(!(mousex() > XE / 2 - 150 && mousex() < XE / 2 - 125 && mousey() > YE - 150 && mousey() < YE - 100) && GetAsyncKeyState(VK_LBUTTON))
            clearmouseclick(WM_LBUTTONDOWN);
        while(mousex() > XE / 2 - 150 && mousex() < XE / 2 - 125 && mousey() > YE - 150 && mousey() < YE - 100){
            setcolor(RGB(118,47,5));
            line(XE / 2 - 150, YE - 125, XE / 2 - 125, YE - 100);
            line(XE / 2 - 150, YE - 125, XE / 2 - 125, YE - 150);
            if(GetAsyncKeyState(VK_LBUTTON)){
                clearmouseclick(WM_LBUTTONDOWN);
                return 1;
            }
        }
        //sageata dreapta
        setcolor(WHITE);
        line(XE / 2 + 158, YE - 125, XE / 2 + 133, YE - 100);
        line(XE / 2 + 158, YE - 125, XE / 2 + 133, YE - 150);
        if(!(mousex() > XE / 2 + 133 && mousex() < XE / 2 + 158 && mousey() > YE - 150 && mousey() < YE - 100) && GetAsyncKeyState(VK_LBUTTON))
            clearmouseclick(WM_LBUTTONDOWN);
        while(mousex() > XE / 2 + 133 && mousex() < XE / 2 + 158 && mousey() > YE - 150 && mousey() < YE - 100){
            if(GetAsyncKeyState(VK_LBUTTON)){
                fnc = pag73();
                if(fnc == 1){
                    h = YE / 3 - 150;
                    clearmouseclick(WM_LBUTTONDOWN);
                    delay(200);
                    setbkcolor(RGB(196,192,251));
                    cleardevice();
                    setcolor(WHITE);
                    line(XE / 2 + 158, YE - 125, XE / 2 + 133, YE - 100);
                    line(XE / 2 + 158, YE - 125, XE / 2 + 133, YE - 150);
                       setcolor(RGB(65,0,36));
    settextstyle(6, 0, 17);
    outtextxy(XE / 2 - 400, 50, "Tablouri unidimensionale");
    ///setcolor(RGB(60,56,153));
    ///settextstyle(10, 0 , 5);
    ///outtextxy( 50, YE / 3 - 180, "");
    ///h+=20;
    text("da", "int n, X[100];", h);
    text("da", "//citire X[] cu n elemente", h);
    text("da", "for(int i = 0 ; i < n - 1 ; i ++)", h);
    text("da", "    for(int j = i + 1 ; j < n ; j ++)", h);
    text("da", "        if(X[i] > X[j])", h);
    text("da", "            {int aux = X[i];", h);
    text("da", "            X[i] = X[j];", h);
    text("da", "            X[j] = aux;}", h);
    text("da", "Algoritmul descris mai sus se mai numeste sortare prin selectie generala, sau implicita.", h);
    text("da", "Standard Template Library-STL contine o functie ce realizeaza sortarea eficienta a unui tablou,sort.", h);
    text("nu", "Ea poate fi folosita atat pentru sortarea unui vector STL, cat si pentru sortarea unui tablou standard C.", h);
    text("nu", "Elementele tabloului pot avea orice tip pe care este definita operatia <.", h);
    text("da", "Functia sort este declarata in header-ul algorithm, care trebuie inclus in programul sursa:", h);
    text("nu", "#include <algorithm>", h);
    setcolor(RGB(60,56,153));
    settextstyle(10, 0 , 5);
    outtextxy( 50, h, "Ordonarea crescatoare");
    h+=40;
    text("da", "Functia sort permite sortarea unei secvente a tabloului. Pentru a sorta in tabloul A secventa", h);
    text("nu", "delimitata de indicii s si d (inclusiv acestia), se face apelul:", h);
    text("da", "sort(A + s, A + d + 1);", h);
    text("da", "Daca se doreste sortarea unui tablou A cu n elemente, indexate de la 0 la n-1, apelul va fi:", h);
    text("da", "sort(A, A + n);", h);

                    break;
                }
                if(fnc == 2){
                    clearmouseclick(WM_LBUTTONDOWN);
                    return 2;
                }
            }
            setcolor(RGB(118,47,5));
            line(XE / 2 + 158, YE - 125, XE / 2 + 133, YE - 100);
            line(XE / 2 + 158, YE - 125, XE / 2 + 133, YE - 150);
        }
        setcolor(WHITE);
    }
}

int pag53(){
    int h = YE / 3 - 210;
    clearmouseclick(WM_LBUTTONDOWN);
    delay(200);
    setbkcolor(RGB(196,192,251));
    cleardevice();
    setcolor(RGB(65,0,36));
    settextstyle(6, 0, 17);
    outtextxy(XE / 2 - 400, 50, "Tablouri unidimensionale");
    setcolor(RGB(60,56,153));
    settextstyle(10, 0 , 5);
    outtextxy( 50, h, "Sortarea prin selectie");
    h+=20;
    text("da", "(Selection Sort) se bazeaza pe urmatoarea idee:", h);
    text("nu", "•	fie un vector X[] cu n elemente;", h);
    text("nu", "•	plasam in X[0] cea mai mica valoare din vector;", h);
    text("nu", "•	plasam in X[1] cea mai mica valoare ramasa;", h);
    text("da", "O descriere a algoritmului este:", h);
    text("nu", "•	parcurgem vectorul cu indicele i", h);
    text("nu", "  o	  parcurgem cu indicele j elementele din dreapta lui X[i]", h);
    text("nu", "       daca elementele X[i] si X[j] nu sunt in ordinea dorita, le interschimbam", h);
    text("da", "Exemplu", h);
    text("da", "Sa ordonam urmatorul vector, in care n=5:", h);
    readimagefile("poza  13 .jpg", 40, h + 140, 300, h + 300);
    readimagefile("poza  23.jpg", 500, h + 140, 1200, h + 400);
    setcolor(RGB(60,56,153));
    settextstyle(10, 0 , 5);
    outtextxy( 50, YE / 2 + 20, "");
    h+=40;

    while(true){
        setcolor(WHITE);
        rectangle(XE / 2 - 105, YE - 150, XE / 2 + 113, YE - 100);
        settextstyle(6, 0 , 3);
        outtextxy(XE / 2 - 100, YE - 135, "Pagina 5 din 7");
        if(pga == 0)
           pga = intoarcere();
        if(pga == 1){
            return 2;
        }
        clearmouseclick(WM_LBUTTONDOWN);
        //sageata stanga
        line(XE / 2 - 150, YE - 125, XE / 2 - 125, YE - 100);
        line(XE / 2 - 150, YE - 125, XE / 2 - 125, YE - 150);
        if(!(mousex() > XE / 2 - 150 && mousex() < XE / 2 - 125 && mousey() > YE - 150 && mousey() < YE - 100) && GetAsyncKeyState(VK_LBUTTON))
            clearmouseclick(WM_LBUTTONDOWN);
        while(mousex() > XE / 2 - 150 && mousex() < XE / 2 - 125 && mousey() > YE - 150 && mousey() < YE - 100){
            setcolor(RGB(118,47,5));
            line(XE / 2 - 150, YE - 125, XE / 2 - 125, YE - 100);
            line(XE / 2 - 150, YE - 125, XE / 2 - 125, YE - 150);
            if(GetAsyncKeyState(VK_LBUTTON)){
                clearmouseclick(WM_LBUTTONDOWN);
                return 1;
            }
        }
        //sageata dreapta
        setcolor(WHITE);
        line(XE / 2 + 158, YE - 125, XE / 2 + 133, YE - 100);
        line(XE / 2 + 158, YE - 125, XE / 2 + 133, YE - 150);
        if(!(mousex() > XE / 2 + 133 && mousex() < XE / 2 + 158 && mousey() > YE - 150 && mousey() < YE - 100) && GetAsyncKeyState(VK_LBUTTON))
            clearmouseclick(WM_LBUTTONDOWN);
        while(mousex() > XE / 2 + 133 && mousex() < XE / 2 + 158 && mousey() > YE - 150 && mousey() < YE - 100){
            if(GetAsyncKeyState(VK_LBUTTON)){
                fnc = pag63();
                if(fnc == 1){
                    h = YE / 3 - 210;
                    clearmouseclick(WM_LBUTTONDOWN);
                    delay(200);
                    setbkcolor(RGB(196,192,251));
                    cleardevice();
                  setcolor(RGB(65,0,36));
     setcolor(RGB(65,0,36));
    settextstyle(6, 0, 17);
    outtextxy(XE / 2 - 400, 50, "Tablouri unidimensionale");
    setcolor(RGB(60,56,153));
    settextstyle(10, 0 , 5);
    outtextxy( 50, h, "Sortarea prin selectie");
    h+=20;
    text("da", "(Selection Sort) se bazeaza pe urmatoarea idee:", h);
    text("nu", "•	fie un vector X[] cu n elemente;", h);
    text("nu", "•	plasam in X[0] cea mai mica valoare din vector;", h);
    text("nu", "•	plasam in X[1] cea mai mica valoare ramasa;", h);
    text("da", "O descriere a algoritmului este:", h);
    text("nu", "•	parcurgem vectorul cu indicele i", h);
    text("nu", "  o	  parcurgem cu indicele j elementele din dreapta lui X[i]", h);
    text("nu", "       daca elementele X[i] si X[j] nu sunt in ordinea dorita, le interschimbam", h);
    text("da", "Exemplu", h);
    text("da", "Sa ordonam urmatorul vector, in care n=5:", h);
    readimagefile("poza  13 .jpg", 40, h + 140, 300, h + 300);
    readimagefile("poza  23.jpg", 500, h + 140, 1200, h + 400);
    setcolor(RGB(60,56,153));
    settextstyle(10, 0 , 5);
    outtextxy( 50, YE / 2 + 20, "");
    h+=40;

                    break;
                }
                if(fnc == 2){
                    return 2;
                }
            }
            setcolor(RGB(118,47,5));
            line(XE / 2 + 158, YE - 125, XE / 2 + 133, YE - 100);
            line(XE / 2 + 158, YE - 125, XE / 2 + 133, YE - 150);
        }
        setcolor(WHITE);
    }
}

int pag43(){
    int h = YE / 3 - 150;
    clearmouseclick(WM_LBUTTONDOWN);
    delay(200);
    setbkcolor(RGB(196,192,251));
    cleardevice();
   setcolor(RGB(65,0,36));
    settextstyle(6, 0, 17);
    outtextxy(XE / 2 - 400, 50, "Tablouri unidimensionale");
    setcolor(RGB(60,56,153));
    settextstyle(10, 0 , 5);
    outtextxy( 50, h, "Indexare de la 0 si indexare de la 1");
    h+=20;
    text("da", "Orice tablou C++ are fizic elementele indexate de la 0 la Dimensiune-1. De exemplu, daca", h);
    text("nu", "avem nevoie de un tablou cu n<100 elemente intregi, il vom declara:", h);
    text("da", "int V[100];", h);
    text("da", "iar elementele vor avea indici intre 0 si 99. Astfel, primul element al tabloului este V[0],", h);
    text("nu", "al doilea este V[1], …, ultimul este V[n-1].", h);
    text("da", "Daca dorim, putem ignora elementul V[0] (pur si simplu nu il folosim, el exista insa in continuare),", h);
    text("nu", "si atunci toate operatiile (citire, afisare, parcurgere) vor utiliza elementele V[1] (primul element),", h);
    text("nu", "V[1] (al doilea element), …, V[n] (ultimul element).", h);
    text("da", "Trebuie de asemenea sa tratam cu atentie declararea tabloului, dimensiunea fizica trebuind sa fie", h);
    text("nu", "mai mare cu 1 decat valoarea precizata in problema. Daca de exemplu, n<100, declararea va fi:", h);
    text("da", "int V[101];", h);
    text("da", "Acest lucru este necesar pentru a exista elementul V[100].", h);
    setcolor(RGB(60,56,153));
    settextstyle(10, 0 , 5);
    outtextxy( 50, h, "Indexare de la 0 si indexare de la 1");
    h+=40;
    text("da", "La declararea tabloului este posibil sa initializam elementele sale:", h);
    text("nu", "int A[] = {10 , 20 , 30 , 40};", h);
    text("nu", "int B[10] = {10 , 20 , 30 , 40};", h);
    text("da", "int C[10] = {0};", h);
    text("da", "A va avea patru elemente, cu valorile A[0] = 10, A[1] = 20, A[2] = 30, A[3] = 40.B va avea zece", h);
    text("nu", "elemente;primele patru vor avea valorile B[0] = 10, B[1] = 20, B[2] = 30 ,  B[3] = 40,celelalte vor", h);
    text("nu", "avea valoarea 0!!! C va avea zece elemente. Toate vor avea valoarea 0!!!", h);


    while(true){
        setcolor(WHITE);
        rectangle(XE / 2 - 105, YE - 150, XE / 2 + 113, YE - 100);
        settextstyle(6, 0 , 3);
        outtextxy(XE / 2 - 100, YE - 135, "Pagina 4 din 7");

        if(pga == 0)
           pga = intoarcere();
        if(pga == 1){
            return 2;
        }
        clearmouseclick(WM_LBUTTONDOWN);
        //sageata stanga
        line(XE / 2 - 150, YE - 125, XE / 2 - 125, YE - 100);
        line(XE / 2 - 150, YE - 125, XE / 2 - 125, YE - 150);
        if(!(mousex() > XE / 2 - 150 && mousex() < XE / 2 - 125 && mousey() > YE - 150 && mousey() < YE - 100) && GetAsyncKeyState(VK_LBUTTON))
            clearmouseclick(WM_LBUTTONDOWN);
        while(mousex() > XE / 2 - 150 && mousex() < XE / 2 - 125 && mousey() > YE - 150 && mousey() < YE - 100){
            setcolor(RGB(118,47,5));
            line(XE / 2 - 150, YE - 125, XE / 2 - 125, YE - 100);
            line(XE / 2 - 150, YE - 125, XE / 2 - 125, YE - 150);
            if(GetAsyncKeyState(VK_LBUTTON)){
                clearmouseclick(WM_LBUTTONDOWN);
                return 1;
            }
        }
        //sageata dreapta
        setcolor(WHITE);
        line(XE / 2 + 158, YE - 125, XE / 2 + 133, YE - 100);
        line(XE / 2 + 158, YE - 125, XE / 2 + 133, YE - 150);
        if(!(mousex() > XE / 2 + 133 && mousex() < XE / 2 + 158 && mousey() > YE - 150 && mousey() < YE - 100) && GetAsyncKeyState(VK_LBUTTON))
            clearmouseclick(WM_LBUTTONDOWN);
        while(mousex() > XE / 2 + 133 && mousex() < XE / 2 + 158 && mousey() > YE - 150 && mousey() < YE - 100){
            if(GetAsyncKeyState(VK_LBUTTON)){
                fnc = pag53();
                if(fnc == 1){
                    fnc = 0;
                    h = YE / 3 - 150;
                    clearmouseclick(WM_LBUTTONDOWN);
                    delay(200);
                    setcolor(RGB(65,0,36));
    setcolor(RGB(65,0,36));
    settextstyle(6, 0, 17);
    outtextxy(XE / 2 - 400, 50, "Tablouri unidimensionale");
    setcolor(RGB(60,56,153));
    settextstyle(10, 0 , 5);
    outtextxy( 50, h, "Indexare de la 0 si indexare de la 1");
    h+=20;
    text("da", "Orice tablou C++ are fizic elementele indexate de la 0 la Dimensiune-1. De exemplu, daca", h);
    text("nu", "avem nevoie de un tablou cu n<100 elemente intregi, il vom declara:", h);
    text("da", "int V[100];", h);
    text("da", "iar elementele vor avea indici intre 0 si 99. Astfel, primul element al tabloului este V[0],", h);
    text("nu", "al doilea este V[1], …, ultimul este V[n-1].", h);
    text("da", "Daca dorim, putem ignora elementul V[0] (pur si simplu nu il folosim, el exista insa in continuare),", h);
    text("nu", "si atunci toate operatiile (citire, afisare, parcurgere) vor utiliza elementele V[1] (primul element),", h);
    text("nu", "V[1] (al doilea element), …, V[n] (ultimul element).", h);
    text("da", "Trebuie de asemenea sa tratam cu atentie declararea tabloului, dimensiunea fizica trebuind sa fie", h);
    text("nu", "mai mare cu 1 decat valoarea precizata in problema. Daca de exemplu, n<100, declararea va fi:", h);
    text("da", "int V[101];", h);
    text("da", "Acest lucru este necesar pentru a exista elementul V[100].", h);
    setcolor(RGB(60,56,153));
    settextstyle(10, 0 , 5);
    outtextxy( 50, h, "Indexare de la 0 si indexare de la 1");
    h+=40;
    text("da", "La declararea tabloului este posibil sa initializam elementele sale:", h);
    text("nu", "int A[] = {10 , 20 , 30 , 40};", h);
    text("nu", "int B[10] = {10 , 20 , 30 , 40};", h);
    text("da", "int C[10] = {0};", h);
    text("da", "A va avea patru elemente, cu valorile A[0] = 10, A[1] = 20, A[2] = 30, A[3] = 40.B va avea zece", h);
    text("nu", "elemente;primele patru vor avea valorile B[0] = 10, B[1] = 20, B[2] = 30 ,  B[3] = 40,celelalte vor", h);
    text("nu", "avea valoarea 0!!! C va avea zece elemente. Toate vor avea valoarea 0!!!", h);

                    break;
                }
                else if(fnc == 2){
                    return 2;
                }
            }
            setcolor(RGB(118,47,5));
            line(XE / 2 + 158, YE - 125, XE / 2 + 133, YE - 100);
            line(XE / 2 + 158, YE - 125, XE / 2 + 133, YE - 150);
        }
        setcolor(WHITE);
    }
}

int pag33(){
    int h = YE / 3 - 150;
    clearmouseclick(WM_LBUTTONDOWN);
    delay(200);
    setbkcolor(RGB(196,192,251));
    cleardevice();
    setcolor(RGB(65,0,36));
    settextstyle(6, 0, 17);
    outtextxy(XE / 2 - 400, 50, "Tablouri unidimensionale");
    setcolor(RGB(60,56,153));
    settextstyle(10, 0 , 5);
    outtextxy( 50, YE / 3 - 180, "Citirea unui vector");
    h+=20;
    text("da", "int X[100], n;", h);
    text("da", "De fapt,in cele mai multe cazuri nu se poate face citirea unui tablou unidimensional (vector),adica", h);
    text("da", "cin >> X;", h);
    text("da", "Instructiunea de mai sus duce de regula la eroare de sintaxa. In schimb, se pot citi elementele", h);
    text("nu", "tabloului, in ordine, cu ajutorul parcurgerii:", h);
    text("da", "cin >> n;", h);
    text("da", "for(int i = 0 ; i < n ; i ++)", h);
    text("da", "    cin >> X[i];", h);
    setcolor(RGB(60,56,153));
    settextstyle(10, 0 , 5);
    outtextxy( 50, h, "Afisarea unui vector");
    h+=40;
    text("da", "int X[100], n;", h);
    text("da", "La fel ca in cazul citirii, in cele mai multe cazuri nu se poate face nici afisarea unui vector, adica", h);
    text("da", "cout <<  X;", h);
    text("da", "Spre deosebire de citire, afisarea unui tablou cu ajutorul operatorului de insertie << nu duce la", h);
    text("nu", "eroare de sintaxa,,insa nu se vor afisa elementele tabloului, ci o adresa (de exemplu 0x7ffc9711bcd0),", h);
    text("nu", "reprezentand adresa primului element al tabloului. Elementele tabloului se pot afisa prin parcurgere,", h);
    text("nu", "in ordinea dorita:", h);
    text("da", "for(int i = 0 ; i < n ; i ++)", h);
    text("da", "    cout << X[i] << ' ';", h);
    text("da", "sau", h);
    text("da", "for(int i = n - 1 ; i >= 0 ; i --)", h);
    text("da", "    cout << X[i] << ' ';",h);


    while(true){
        setcolor(WHITE);
        rectangle(XE / 2 - 105, YE - 150, XE / 2 + 113, YE - 100);
        settextstyle(6, 0 , 3);
        outtextxy(XE / 2 - 100, YE - 135, "Pagina 3 din 7");
        if(pga == 0)
           pga = intoarcere();
        if(pga == 1){
            return 2;
        }
        clearmouseclick(WM_LBUTTONDOWN);
        //sageata stanga
        line(XE / 2 - 150, YE - 125, XE / 2 - 125, YE - 100);
        line(XE / 2 - 150, YE - 125, XE / 2 - 125, YE - 150);
        if(!(mousex() > XE / 2 - 150 && mousex() < XE / 2 - 125 && mousey() > YE - 150 && mousey() < YE - 100) && GetAsyncKeyState(VK_LBUTTON))
            clearmouseclick(WM_LBUTTONDOWN);
        while(mousex() > XE / 2 - 150 && mousex() < XE / 2 - 125 && mousey() > YE - 150 && mousey() < YE - 100){
            setcolor(RGB(118,47,5));
            line(XE / 2 - 150, YE - 125, XE / 2 - 125, YE - 100);
            line(XE / 2 - 150, YE - 125, XE / 2 - 125, YE - 150);
            if(GetAsyncKeyState(VK_LBUTTON)){
                clearmouseclick(WM_LBUTTONDOWN);
                return 1;
            }
        }
        //sageata dreapta
        setcolor(WHITE);
        line(XE / 2 + 158, YE - 125, XE / 2 + 133, YE - 100);
        line(XE / 2 + 158, YE - 125, XE / 2 + 133, YE - 150);
        if(!(mousex() > XE / 2 + 133 && mousex() < XE / 2 + 158 && mousey() > YE - 150 && mousey() < YE - 100) && GetAsyncKeyState(VK_LBUTTON))
            clearmouseclick(WM_LBUTTONDOWN);
        while(mousex() > XE / 2 + 133 && mousex() < XE / 2 + 158 && mousey() > YE - 150 && mousey() < YE - 100){
            if(GetAsyncKeyState(VK_LBUTTON)){
                fnc = pag43();
                if(fnc == 1){
                    h = YE / 3 - 150;
                    clearmouseclick(WM_LBUTTONDOWN);
                    delay(200);
                    setbkcolor(RGB(196,192,251));
                    cleardevice();
                    setcolor(RGB(65,0,36));
    setcolor(RGB(65,0,36));
    settextstyle(6, 0, 17);
    outtextxy(XE / 2 - 400, 50, "Tablouri unidimensionale");
    setcolor(RGB(60,56,153));
    settextstyle(10, 0 , 5);
    outtextxy( 50, h, "Citirea unui vector");
    h+=20;
    text("da", "int X[100], n;", h);
    text("da", "De fapt,in cele mai multe cazuri nu se poate face citirea unui tablou unidimensional (vector),adica", h);
    text("da", "cin >> X;", h);
    text("da", "Instructiunea de mai sus duce de regula la eroare de sintaxa. In schimb, se pot citi elementele", h);
    text("nu", "tabloului, in ordine, cu ajutorul parcurgerii:", h);
    text("da", "cin >> n;", h);
    text("da", "for(int i = 0 ; i < n ; i ++)", h);
    text("da", "    cin >> X[i];", h);
    setcolor(RGB(60,56,153));
    settextstyle(10, 0 , 5);
    outtextxy( 50, YE / 2 - 80, "Afisarea unui vector");
    h+=40;
    text("da", "int X[100], n;", h);
    text("da", "La fel ca in cazul citirii, in cele mai multe cazuri nu se poate face nici afisarea unui vector, adica", h);
    text("da", "cout <<  X;", h);
    text("da", "Spre deosebire de citire, afisarea unui tablou cu ajutorul operatorului de insertie << nu duce la", h);
    text("nu", "eroare de sintaxa,,insa nu se vor afisa elementele tabloului, ci o adresa (de exemplu 0x7ffc9711bcd0),", h);
    text("nu", "reprezentand adresa primului element al tabloului. Elementele tabloului se pot afisa prin parcurgere,", h);
    text("nu", "in ordinea dorita:", h);
    text("da", "for(int i = 0 ; i < n ; i ++)", h);
    text("da", "    cout << X[i] << ' ';", h);
    text("da", "sau", h);
    text("da", "for(int i = n - 1 ; i >= 0 ; i --)", h);
    text("da", "    cout << X[i] << ' ';",h);

                    break;
                }
                else if(fnc == 2){
                    return 2;
                }
            }
            setcolor(RGB(118,47,5));
            line(XE / 2 + 158, YE - 125, XE / 2 + 133, YE - 100);
            line(XE / 2 + 158, YE - 125, XE / 2 + 133, YE - 150);
        }
        setcolor(WHITE);
    }
}

int pag23(){
    int h = YE / 3 - 150;
    clearmouseclick(WM_LBUTTONDOWN);
    delay(200);
    setbkcolor(RGB(196,192,251));
    cleardevice();
       setcolor(RGB(65,0,36));
    settextstyle(6, 0, 17);
    outtextxy(XE / 2 - 400, 50, "Tablouri unidimensionale");
    setcolor(RGB(60,56,153));
    settextstyle(10, 0 , 5);
    outtextxy( 50, h, "Parcurgerea unui tablou unidimensional");
    h+=20;
    text("da", "Parcurgerea unui tablou reprezinta referirea fiecarui element al tabloului intr-o anumita ordine.",h);
    text("nu", "Referirea elementului se face prin intermediul indicelui, cu ajutorul operatorului de indexare.",h);
    text("da", "Urmatorul exemplu declara un tablou cu 100 de elemente si memoreaza in primele n elemente ale",h);
    text("nu", "tabloului valoarea 1.Dupa cum stim deja,n trebuie sa respecte relatia n<=100. In caz contrar,",h);
    text("nu", "comportamentul programului devine impredictibil – foarte probabil executia sa va fi oprita de.",h);
    text("nu", "sistemul de operare.",h);
    text("da", "int X[100], n;",h);
    text("da", "//n = .... ;",h);
    text("da", "for(int i = 0 ; i < n ; i ++)",h);
    text("da", "X[i] = 1;",h);
    text("da", "De regula, parcurgerea tabloului se face in ordinea crescatoare a indicelor, de la 0 la n-1.",h);
    text("nu", "Facand o analogie cu axa numerelor, putem spune ca parcurgerea se face de la stanga spre",h);
    text("nu", "dreapta. Tabloul poate fi parcurs si de la dreapta la stanga, adica in ordinea descrescatoare",h);
    text("nu", "a indicilor, de la n-1 la 0:",h);
    text("da", "for(int i = n - 1 ; i >= 0 ; i --)",h);
    text("da", "    X[i] = 1;",h);



    while(true){
             setcolor(WHITE);
    rectangle(XE / 2 - 105, YE - 150, XE / 2 + 113, YE - 100);
    settextstyle(6, 0 , 3);
    outtextxy(XE / 2 - 100, YE - 135, "Pagina 2 din 7");
    setcolor(WHITE);
        if(pga == 0)
           pga = intoarcere();
        if(pga == 1){
            return 2;
        }
        //sageata stanga
        line(XE / 2 - 150, YE - 125, XE / 2 - 125, YE - 100);
        line(XE / 2 - 150, YE - 125, XE / 2 - 125, YE - 150);
        if(!(mousex() > XE / 2 - 150 && mousex() < XE / 2 - 125 && mousey() > YE - 150 && mousey() < YE - 100) && GetAsyncKeyState(VK_LBUTTON))
            clearmouseclick(WM_LBUTTONDOWN);
        while(mousex() > XE / 2 - 150 && mousex() < XE / 2 - 125 && mousey() > YE - 150 && mousey() < YE - 100){
            setcolor(RGB(118,47,5));
            line(XE / 2 - 150, YE - 125, XE / 2 - 125, YE - 100);
            line(XE / 2 - 150, YE - 125, XE / 2 - 125, YE - 150);
            if(GetAsyncKeyState(VK_LBUTTON)){
                clearmouseclick(WM_LBUTTONDOWN);
                return 1;
            }
        }
        //sageata dreapta
        setcolor(WHITE);
        line(XE / 2 + 158, YE - 125, XE / 2 + 133, YE - 100);
        line(XE / 2 + 158, YE - 125, XE / 2 + 133, YE - 150);
        if(!(mousex() > XE / 2 + 133 && mousex() < XE / 2 + 158 && mousey() > YE - 150 && mousey() < YE - 100) && GetAsyncKeyState(VK_LBUTTON))
            clearmouseclick(WM_LBUTTONDOWN);
        while(mousex() > XE / 2 + 133 && mousex() < XE / 2 + 158 && mousey() > YE - 150 && mousey() < YE - 100){
            if(GetAsyncKeyState(VK_LBUTTON)){
                fnc = pag33();
                if(fnc == 1){
                        fnc = 0;
                        delay(300);
                        h = YE / 3 - 150;
                        clearmouseclick(WM_LBUTTONDOWN);
                        delay(200);
                        setbkcolor(RGB(196,192,251));
                        cleardevice();
                            setcolor(RGB(65,0,36));
    settextstyle(6, 0, 17);
    outtextxy(XE / 2 - 400, 50, "Tablouri unidimensionale");
    setcolor(RGB(60,56,153));
    settextstyle(10, 0 , 5);
    outtextxy( 50, h, "Parcurgerea unui tablou unidimensional");
    h+=20;
    text("da", "Parcurgerea unui tablou reprezinta referirea fiecarui element al tabloului intr-o anumita ordine.",h);
    text("nu", "Referirea elementului se face prin intermediul indicelui, cu ajutorul operatorului de indexare.",h);
    text("da", "Urmatorul exemplu declara un tablou cu 100 de elemente si memoreaza in primele n elemente ale",h);
    text("nu", "tabloului valoarea 1.Dupa cum stim deja,n trebuie sa respecte relatia n<=100. In caz contrar,",h);
    text("nu", "comportamentul programului devine impredictibil – foarte probabil executia sa va fi oprita de.",h);
    text("nu", "sistemul de operare.",h);
    text("da", "int X[100], n;",h);
    text("da", "//n = .... ;",h);
    text("da", "for(int i = 0 ; i < n ; i ++)",h);
    text("da", "X[i] = 1;",h);
    text("da", "De regula, parcurgerea tabloului se face in ordinea crescatoare a indicelor, de la 0 la n-1.",h);
    text("nu", "Facand o analogie cu axa numerelor, putem spune ca parcurgerea se face de la stanga spre",h);
    text("nu", "dreapta. Tabloul poate fi parcurs si de la dreapta la stanga, adica in ordinea descrescatoare",h);
    text("nu", "a indicilor, de la n-1 la 0:",h);
    text("da", "for(int i = n - 1 ; i >= 0 ; i --)",h);
    text("da", "    X[i] = 1;",h);

                        setcolor(WHITE);
                        rectangle(XE / 2 - 105, YE - 150, XE / 2 + 113, YE - 100);
                        settextstyle(6, 0 , 3);
                        outtextxy(XE / 2 - 100, YE - 135, "Pagina 2 din 7");
                        setcolor(WHITE);
                        break;
                    }
                else if(fnc == 2){
                       return 2;
                }
                clearmouseclick(WM_LBUTTONDOWN);
            }
            setcolor(RGB(118,47,5));
            line(XE / 2 + 158, YE - 125, XE / 2 + 133, YE - 100);
            line(XE / 2 + 158, YE - 125, XE / 2 + 133, YE - 150);
        }
        setcolor(WHITE);
        clearmouseclick(WM_LBUTTONDOWN);

    }
}
int pag13(){
    int h = YE / 3 - 150;
    cleardevice();
    clearmouseclick(WM_LBUTTONDOWN);
    setbkcolor(RGB(196,192,251));
    cleardevice();
    setcolor(RGB(65,0,36));
    settextstyle(6, 0, 17);
    outtextxy(XE / 2 - 340, 50, "Tablouri unidimensionale");
    text("da", "Un tablou unidimensional se declara în C++ astfel:", h);
    text("da", "tipDeBaza denumire[Dimensiune];", h);
    text("da", "de exemplu:", h);
    text("da", "int X[10];", h);
    setcolor(RGB(60,56,153));
    settextstyle(10, 0 , 5);
    outtextxy( 50, YE / 3 - 50, "Referirea unui element");
    h+=40;
    text("da", "Referirea unui element se face prin operatorul de indexare, [] ,care are prioritate maxima.", h);
    text("nu", "De exemplu:", h);
    text("da", "X[0], X[5], X[i]", h);
    setcolor(RGB(60,56,153));
    settextstyle(10, 0 , 5);
    outtextxy( 50, YE / 3 + 70, "Dimensiunea unui tablou unidimensional");
     h+=40;
    text("da", "La declararea unui tablou unidimensional se precizeaza o dimensiune pentru acesta.Aceasta", h);
    text("nu", "reprezinta o dimensiune fizica a tabloului – numarul maxim de elemente pe care le-ar putea avea", h);
    text("nu", "acesta,conform restrictiilor problemei.De cele mai multe ori,in program nu se folosesc", h);
    text("nu", "toate elementele tabloului. De regula, enuntul unei probleme cu tablouri este:", h);
    text("da", "“Se citeste un vector cu n elemente, numere …. Sa se …..”", h);
    text("da", "Este deci necesar ca in program sa avem o variabila – de regula se noteaza n, care sa reprezinte", h);
    text("nu", "dimensiunea logica a tabloului numarul de elemente ale tabloului care la un moment dat sunt", h);
    text("nu", "utilizate in program.", h);


    while(true){
            setcolor(WHITE);
                    settextstyle(6, 0 , 3);
                    outtextxy(XE / 2 - 100, YE - 135, "Pagina 1 din 7");
                    rectangle(XE / 2 - 105, YE - 150, XE / 2 + 113, YE - 100);
        if(pga == 0)
            pga = intoarcere();
        else
            return 1;
        //sageata dreapta
        setcolor(WHITE);
        line(XE / 2 + 158, YE - 125, XE / 2 + 133, YE - 100);
        line(XE / 2 + 158, YE - 125, XE / 2 + 133, YE - 150);
        if(!(mousex() > XE / 2 + 133 && mousex() < XE / 2 + 158 && mousey() > YE - 150 && mousey() < YE - 100) && GetAsyncKeyState(VK_LBUTTON))
            clearmouseclick(WM_LBUTTONDOWN);
        while(mousex() > XE / 2 + 133 && mousex() < XE / 2 + 158 && mousey() > YE - 150 && mousey() < YE - 100){
            if(GetAsyncKeyState(VK_LBUTTON)){
                clearmouseclick(WM_LBUTTONDOWN);
                fnc = pag23();
                if(fnc == 1){
                    fnc = 0;
                    h = YE / 3 - 150;
                    clearmouseclick(WM_LBUTTONDOWN);
                    setbkcolor(RGB(196,192,251));
                    cleardevice();
                     setcolor(RGB(65,0,36));
    settextstyle(6, 0, 17);
    outtextxy(XE / 2 - 340, 50, "Tablouri unidimensionale");
    text("da", "Un tablou unidimensional se declara în C++ astfel:", h);
    text("da", "tipDeBaza denumire[Dimensiune];", h);
    text("da", "de exemplu:", h);
    text("da", "int X[10];", h);
    setcolor(RGB(60,56,153));
    settextstyle(10, 0 , 5);
    outtextxy( 50, YE / 3 - 50, "Referirea unui element");
    h+=40;
    text("da", "Referirea unui element se face prin operatorul de indexare, [] ,care are prioritate maxima.", h);
    text("nu", "De exemplu:", h);
    text("da", "X[0], X[5], X[i]", h);
    setcolor(RGB(60,56,153));
    settextstyle(10, 0 , 5);
    outtextxy( 50, YE / 3 + 70, "Dimensiunea unui tablou unidimensional");
     h+=40;
    text("da", "La declararea unui tablou unidimensional se precizeaza o dimensiune pentru acesta.Aceasta", h);
    text("nu", "reprezinta o dimensiune fizica a tabloului – numarul maxim de elemente pe care le-ar putea avea", h);
    text("nu", "acesta,conform restrictiilor problemei.De cele mai multe ori,in program nu se folosesc", h);
    text("nu", "toate elementele tabloului. De regula, enuntul unei probleme cu tablouri este:", h);
    text("da", "“Se citeste un vector cu n elemente, numere …. Sa se …..”", h);
    text("da", "Este deci necesar ca in program sa avem o variabila – de regula se noteaza n, care sa reprezinte", h);
    text("nu", "dimensiunea logica a tabloului numarul de elemente ale tabloului care la un moment dat sunt", h);
    text("nu", "utilizate in program.", h);

                    setcolor(WHITE);
                    rectangle(XE / 2 - 105, YE - 150, XE / 2 + 113, YE - 100);
                    settextstyle(6, 0 , 3);
                    outtextxy(XE / 2 - 95, YE - 135, "Pagina 1 din 7");
                    break;
                }
                if(fnc == 2){
                    return 0;
                }
            }
            setcolor(RGB(118,47,5));
            line(XE / 2 + 158, YE - 125, XE / 2 + 133, YE - 100);
            line(XE / 2 + 158, YE - 125, XE / 2 + 133, YE - 150);
        }
        setcolor(WHITE);
    }
}

int pag54(){// pag72() adica pag 7 lectia 2, schimbati voi in functie de unde sunteti
    int h = YE / 3 - 200;
    clearmouseclick(WM_LBUTTONDOWN);
    delay(200);
    setbkcolor(RGB(196,192,251));
    cleardevice();
    setcolor(RGB(65,0,36));
    settextstyle(6, 0, 17);
    outtextxy(XE / 2 - 400, 50, "Tablouri bidimensionale");
    outtextxy( 30, h, "Parcurgerea unei linii");
    h+=50;
    text("da", "Toate elementele de pe o anumita linie au acelasi indice de linie si difera prin indicele de coloana.",h);
    text("nu", "Pentru a parcurge o anumita linie k, vom parcurge indici de coloana:",h);
    text("da", "for(int j = 0 ; j < m ; j ++)",h);
    text("da", "{",h);
    text("da", "// A[k][j]",h);
    text("da", "}",h);
    h+=60;
    setcolor(RGB(65,0,36));
    settextstyle(6, 0, 17);
    outtextxy( 30, YE / 2 - 100, "Parcurgerea unei coloane");
    h+=70;
    text("da", "Toate elementele de pe o anumita coloana au acelasi indice de coloana si difera prin indicele de linie.",h);
    text("nu", "Pentru a parcurge o anumita coloana k, vom parcurge indici de linie:",h);
    text("da", "for(int i = 0 ; i < n ; i ++)",h);
    text("da", "{",h);
    text("da", "    // A[i][k]",h);
    text("da", "}",h);
    readimagefile("poza 24.jpg", 40, h - 30, 500, h + 280);
    while(true){
		setcolor(WHITE);
		rectangle(XE / 2 - 105, YE - 150, XE / 2 + 113, YE - 100);
		settextstyle(6, 0 , 3);
		outtextxy(XE / 2 - 100, YE - 135, "Pagina 5	din 9");
        if(pga == 0)
           pga = intoarcere();
        if(pga == 1){
            return 2;
        }
        clearmouseclick(WM_LBUTTONDOWN);
        //sageata stanga
        line(XE / 2 - 150, YE - 125, XE / 2 - 125, YE - 100);
        line(XE / 2 - 150, YE - 125, XE / 2 - 125, YE - 150);
        if(!(mousex() > XE / 2 - 150 && mousex() < XE / 2 - 125 && mousey() > YE - 150 && mousey() < YE - 100) && GetAsyncKeyState(VK_LBUTTON))
            clearmouseclick(WM_LBUTTONDOWN);
        while(mousex() > XE / 2 - 150 && mousex() < XE / 2 - 125 && mousey() > YE - 150 && mousey() < YE - 100){
            setcolor(RGB(118,47,5));
            line(XE / 2 - 150, YE - 125, XE / 2 - 125, YE - 100);
            line(XE / 2 - 150, YE - 125, XE / 2 - 125, YE - 150);
            if(GetAsyncKeyState(VK_LBUTTON)){
                clearmouseclick(WM_LBUTTONDOWN);
                return 1;
            }
        }
        setcolor(WHITE);
        line(XE / 2 + 158, YE - 125, XE / 2 + 133, YE - 100);
        line(XE / 2 + 158, YE - 125, XE / 2 + 133, YE - 150);
        if(!(mousex() > XE / 2 + 133 && mousex() < XE / 2 + 158 && mousey() > YE - 150 && mousey() < YE - 100) && GetAsyncKeyState(VK_LBUTTON))
            clearmouseclick(WM_LBUTTONDOWN);
        while(mousex() > XE / 2 + 133 && mousex() < XE / 2 + 158 && mousey() > YE - 150 && mousey() < YE - 100){
            if(GetAsyncKeyState(VK_LBUTTON)){
                fnc = pag64();
                if(fnc == 1){
                    h = YE / 3 - 200;
                    delay(200);
                    setbkcolor(RGB(196,192,251));
                    cleardevice();
                    setcolor(WHITE);
                    line(XE / 2 + 158, YE - 125, XE / 2 + 133, YE - 100);
                    line(XE / 2 + 158, YE - 125, XE / 2 + 133, YE - 150);
					setbkcolor(RGB(196,192,251));
					cleardevice();
					setcolor(RGB(65,0,36));
					settextstyle(6, 0, 17);
					outtextxy(XE / 2 - 400, 50, "Tablouri bidimensionale");
					outtextxy( 30, h, "Parcurgerea unei linii");
					setcolor(WHITE);
					rectangle(XE / 2 - 105, YE - 150, XE / 2 + 113, YE - 100);
					settextstyle(6, 0 , 3);
					outtextxy(XE / 2 - 100, YE - 135, "Pagina 5 din 9");
					h+=50;
					text("da", "Toate elementele de pe o anumita linie au acelasi indice de linie si difera prin indicele de coloana.",h);
					text("nu", "Pentru a parcurge o anumita linie k, vom parcurge indici de coloana:",h);
					text("da", "for(int j = 0 ; j < m ; j ++)",h);
					text("da", "{",h);
					text("da", "// A[k][j]",h);
					text("da", "}",h);
					h+=60;
					setcolor(RGB(65,0,36));
					settextstyle(6, 0, 17);
					outtextxy( 30, YE / 2 - 100, "Parcurgerea unei coloane");
					h+=70;
					text("da", "Toate elementele de pe o anumita coloana au acelasi indice de coloana si difera prin indicele de linie.",h);
					text("nu", "Pentru a parcurge o anumita coloana k, vom parcurge indici de linie:",h);
					text("da", "for(int i = 0 ; i < n ; i ++)",h);
					text("da", "{",h);
					text("da", "    // A[i][k]",h);
					text("da", "}",h);
					readimagefile("poza 24.jpg", 40, h - 30, 500, h + 280);
					break;
                }
                else if(fnc == 2){
                    return 2;
                }
            }
        }
    }
}

int pag44(){// pag72() adica pag 7 lectia 2, schimbati voi in functie de unde sunteti
    int h = YE / 3 - 200;
    clearmouseclick(WM_LBUTTONDOWN);
    delay(200);
    setbkcolor(RGB(196,192,251));
    cleardevice();
    setcolor(RGB(65,0,36));
    settextstyle(6, 0, 17);
    outtextxy(XE / 2 - 400, 50, "Tablouri bidimensionale");
    outtextxy( 30, h , "Parcurgerea matricei");
    setcolor(WHITE);
    rectangle(XE / 2 - 105, YE - 150, XE / 2 + 113, YE - 100);
    settextstyle(6, 0 , 3);

    h+=50;
    text("da", "Parcurgerea presupune accesarea elementelor curente ale matricei, intr-o anumita ordine – de",h);
    text("nu", "regula aceasta se face pe linii, de sus in jos si de la stanga la dreapta:",h);
    text("da", "int n, m, A[100][100];",h);
    text("da", "...",h);
    text("da", "for(int i = 0 ; i < n ; i ++)",h);
    text("da", "{ // linia i",h);
    text("da", "for(int j = 0 ; j < m ; j ++)",h);
    text("da", "// A[i][j]",h);
    text("da", "// .....}",h);
    text("da", "Urmatoarea secventa realizeaza parcurgerea pe coloane:",h);
    text("da", "int n, m, A[100][100];",h);
    text("da", "...",h);
    text("da", "for(int j = 0 ; j < m ; j ++)",h);
    text("da", "{// linia i",h);
    text("da", "    for(int i = 0 ; i < n ; i ++)",h);
    text("nu", "         // A[i][j]",h);
    text("da", "    // .....}",h);
    while(true){
	setcolor(WHITE);
		rectangle(XE / 2 - 105, YE - 150, XE / 2 + 113, YE - 100);
		settextstyle(6, 0 , 3);
		outtextxy(XE / 2 - 100, YE - 135, "Pagina 4	din 9");
        if(pga == 0)
           pga = intoarcere();
        if(pga == 1){
            return 2;
        }
        clearmouseclick(WM_LBUTTONDOWN);
        //sageata stanga
        line(XE / 2 - 150, YE - 125, XE / 2 - 125, YE - 100);
        line(XE / 2 - 150, YE - 125, XE / 2 - 125, YE - 150);
        if(!(mousex() > XE / 2 - 150 && mousex() < XE / 2 - 125 && mousey() > YE - 150 && mousey() < YE - 100) && GetAsyncKeyState(VK_LBUTTON))
            clearmouseclick(WM_LBUTTONDOWN);
        while(mousex() > XE / 2 - 150 && mousex() < XE / 2 - 125 && mousey() > YE - 150 && mousey() < YE - 100){
            setcolor(RGB(118,47,5));
            line(XE / 2 - 150, YE - 125, XE / 2 - 125, YE - 100);
            line(XE / 2 - 150, YE - 125, XE / 2 - 125, YE - 150);
            if(GetAsyncKeyState(VK_LBUTTON)){
                clearmouseclick(WM_LBUTTONDOWN);
                return 1;
            }
        }
        setcolor(WHITE);
        line(XE / 2 + 158, YE - 125, XE / 2 + 133, YE - 100);
        line(XE / 2 + 158, YE - 125, XE / 2 + 133, YE - 150);
        if(!(mousex() > XE / 2 + 133 && mousex() < XE / 2 + 158 && mousey() > YE - 150 && mousey() < YE - 100) && GetAsyncKeyState(VK_LBUTTON))
            clearmouseclick(WM_LBUTTONDOWN);
        while(mousex() > XE / 2 + 133 && mousex() < XE / 2 + 158 && mousey() > YE - 150 && mousey() < YE - 100){
            if(GetAsyncKeyState(VK_LBUTTON)){
                fnc = pag54();
                if(fnc == 1){
                    delay(200);
                    setbkcolor(RGB(196,192,251));
                    cleardevice();
                    setcolor(WHITE);
                    line(XE / 2 + 158, YE - 125, XE / 2 + 133, YE - 100);
                    line(XE / 2 + 158, YE - 125, XE / 2 + 133, YE - 150);
					setbkcolor(RGB(196,192,251));
					cleardevice();
					setcolor(RGB(65,0,36));
					settextstyle(6, 0, 17);
					outtextxy(XE / 2 - 400, 50, "Tablouri bidimensionale");
					outtextxy( 30, h , "Parcurgerea matricei");
					setcolor(WHITE);
					rectangle(XE / 2 - 105, YE - 150, XE / 2 + 113, YE - 100);
					settextstyle(6, 0 , 3);

					h+=50;
					text("da", "Parcurgerea presupune accesarea elementelor curente ale matricei, intr-o anumita ordine – de",h);
					text("nu", "regula aceasta se face pe linii, de sus in jos si de la stanga la dreapta:",h);
					text("da", "int n, m, A[100][100];",h);
					text("da", "...",h);
					text("da", "for(int i = 0 ; i < n ; i ++)",h);
					text("da", "{ // linia i",h);
					text("da", "for(int j = 0 ; j < m ; j ++)",h);
					text("da", "// A[i][j]",h);
					text("da", "// .....}",h);
					text("da", "Urmatoarea secventa realizeaza parcurgerea pe coloane:",h);
					text("da", "int n, m, A[100][100];",h);
					text("da", "...",h);
					text("da", "for(int j = 0 ; j < m ; j ++)",h);
					text("da", "{// linia i",h);
					text("da", "    for(int i = 0 ; i < n ; i ++)",h);
					text("nu", "         // A[i][j]",h);
					text("da", "    // .....}",h);
					break;
                }
                else if(fnc == 2){
                    return 2;
                }
            }
        }
    }
}

int pag34(){// pag72() adica pag 7 lectia 2, schimbati voi in functie de unde sunteti
    int h = YE / 3 - 200;
    clearmouseclick(WM_LBUTTONDOWN);
    delay(200);
    setbkcolor(RGB(196,192,251));
    cleardevice();
    setcolor(RGB(65,0,36));
    settextstyle(6, 0, 17);
    outtextxy(XE / 2 - 400, 50, "Tablouri bidimensionale");
    outtextxy( 30, h, "Legatura dintre matrice si tablourile");
    outtextxy( 30, h, "unidimensionale in C/C++");
    setcolor(WHITE);
    rectangle(XE / 2 - 105, YE - 150, XE / 2 + 113, YE - 100);
    settextstyle(6, 0 , 3);
    h+=80;
    text("da", "Ne putem gandi la un tablou bidimensional in doua moduri:",h);
    text("nu", "•	A este o matrice;",h);
    text("nu", "•	A are linii si coloane. A[1][9] este elementul aflat pe linia 1 si coloana 9;",h);
    text("da", "sau:",h);
    text("nu", "•	A este o un vector; elementele lui A sunt vectori;",h);
    text("nu", "•	A[1] este un vector – reprezinta o linie din matricea A;",h);
    text("nu", "•	A[1][9] este un element al vectorului A[1], de tip int",h);
    text("da", "Cata memorie ocupa un tablou bidimensional?",h);
    text("da", "Dupa cum ati observat deja, toate problemele precizeaza o serie de restrictii, printre care limita",h);
    text("nu", "maxima de memorie care poate fi folosita.Apare firesc intrebarea: cat de mare poate fi o matrice",h);
    text("nu", "sau, mai degraba, cata memorie ocupa o matrice?",h);
    text("da", "Raspunsul difera in functie de doi factori:",h);
    text("nu", "•	tipul elementelor matricei;",h);
    text("nu", "•	dimensiunile precizate la declarare;",h);
    text("nu", "De exemplu, pentru urmatoarea declarare:",h);
    text("nu", "int A[1000][1000];",h);
    text("da", "matricea A are 1000 * 1000 = 1000000 de elemente de tip int. O data de tip int se reprezinta pe",h);
    text("nu", "(ocupa) 4B, deci matricea A va ocupa 4 * 1000 * 1000 B = 4.000.000B, adica ceva mai putin de 4MB.",h);


    while(true){
	setcolor(WHITE);
		rectangle(XE / 2 - 105, YE - 150, XE / 2 + 113, YE - 100);
		settextstyle(6, 0 , 3);
		outtextxy(XE / 2 - 100, YE - 135, "Pagina 3	din 9");
        if(pga == 0)
           pga = intoarcere();
        if(pga == 1){
            return 2;
        }
        clearmouseclick(WM_LBUTTONDOWN);
        //sageata stanga
        line(XE / 2 - 150, YE - 125, XE / 2 - 125, YE - 100);
        line(XE / 2 - 150, YE - 125, XE / 2 - 125, YE - 150);
        if(!(mousex() > XE / 2 - 150 && mousex() < XE / 2 - 125 && mousey() > YE - 150 && mousey() < YE - 100) && GetAsyncKeyState(VK_LBUTTON))
            clearmouseclick(WM_LBUTTONDOWN);
        while(mousex() > XE / 2 - 150 && mousex() < XE / 2 - 125 && mousey() > YE - 150 && mousey() < YE - 100){
            setcolor(RGB(118,47,5));
            line(XE / 2 - 150, YE - 125, XE / 2 - 125, YE - 100);
            line(XE / 2 - 150, YE - 125, XE / 2 - 125, YE - 150);
            if(GetAsyncKeyState(VK_LBUTTON)){
                clearmouseclick(WM_LBUTTONDOWN);
                return 1;
            }
        }
        setcolor(WHITE);
        line(XE / 2 + 158, YE - 125, XE / 2 + 133, YE - 100);
        line(XE / 2 + 158, YE - 125, XE / 2 + 133, YE - 150);
        if(!(mousex() > XE / 2 + 133 && mousex() < XE / 2 + 158 && mousey() > YE - 150 && mousey() < YE - 100) && GetAsyncKeyState(VK_LBUTTON))
            clearmouseclick(WM_LBUTTONDOWN);
        while(mousex() > XE / 2 + 133 && mousex() < XE / 2 + 158 && mousey() > YE - 150 && mousey() < YE - 100){
            if(GetAsyncKeyState(VK_LBUTTON)){
                fnc = pag44();
                if(fnc == 1){
                    delay(200);
                    setbkcolor(RGB(196,192,251));
                    cleardevice();
                    setcolor(WHITE);
                    line(XE / 2 + 158, YE - 125, XE / 2 + 133, YE - 100);
                    line(XE / 2 + 158, YE - 125, XE / 2 + 133, YE - 150);
					 setbkcolor(RGB(196,192,251));
					cleardevice();
					setcolor(RGB(65,0,36));
					settextstyle(6, 0, 17);
					outtextxy(XE / 2 - 400, 50, "Tablouri bidimensionale");
					outtextxy( 30, h, "Legatura dintre matrice si tablourile");
					outtextxy( 30, h, "unidimensionale in C/C++");
					setcolor(WHITE);
					rectangle(XE / 2 - 105, YE - 150, XE / 2 + 113, YE - 100);
					settextstyle(6, 0 , 3);
					h+=80;
					text("da", "Ne putem gandi la un tablou bidimensional in doua moduri:",h);
					text("nu", "•	A este o matrice;",h);
					text("nu", "•	A are linii si coloane. A[1][9] este elementul aflat pe linia 1 si coloana 9;",h);
					text("da", "sau:",h);
					text("nu", "•	A este o un vector; elementele lui A sunt vectori;",h);
					text("nu", "•	A[1] este un vector – reprezinta o linie din matricea A;",h);
					text("nu", "•	A[1][9] este un element al vectorului A[1], de tip int",h);
					text("da", "Cata memorie ocupa un tablou bidimensional?",h);
					text("da", "Dupa cum ati observat deja, toate problemele precizeaza o serie de restrictii, printre care limita",h);
					text("nu", "maxima de memorie care poate fi folosita.Apare firesc intrebarea: cat de mare poate fi o matrice",h);
					text("nu", "sau, mai degraba, cata memorie ocupa o matrice?",h);
					text("da", "Raspunsul difera in functie de doi factori:",h);
					text("nu", "•	tipul elementelor matricei;",h);
					text("nu", "•	dimensiunile precizate la declarare;",h);
					text("nu", "De exemplu, pentru urmatoarea declarare:",h);
					text("nu", "int A[1000][1000];",h);
					text("da", "matricea A are 1000 * 1000 = 1000000 de elemente de tip int. O data de tip int se reprezinta pe",h);
					text("nu", "(ocupa) 4B, deci matricea A va ocupa 4 * 1000 * 1000 B = 4.000.000B, adica ceva mai putin de 4MB.",h);

					break;
                }
                else if(fnc == 2){
                    return 2;
                }
            }
        }
    }
}

int pag24(){// pag72() adica pag 7 lectia 2, schimbati voi in functie de unde sunteti
    int h = YE / 3 - 200;
    clearmouseclick(WM_LBUTTONDOWN);
    delay(200);
    setbkcolor(RGB(196,192,251));
    cleardevice();
    setcolor(RGB(65,0,36));
    settextstyle(6, 0, 17);
    outtextxy(XE / 2 - 240, 50, "Tablouri bidimensionale");

    text("nu", "•	5 • 10 = 50 de elemente;",h);
    text("nu", "•	5 linii, indexate (numerotate) de la 0 la 4 – mai jos sunt evidentiate liniile cu indici 1 si 3;",h);
    text("nu", "•	10 coloane, indexate de la 0 la 9 – mai jos sunt evidentiate coloanele cu indici 0, 4 si 9;",h);
    text("da", "                                                      Referirea elementelor se face prin intermediul operatorului C++ de",h);
    text("da", "                                                      indexare [] la fel ca in cazul vectorilor, dar trebuie precizati",h);
    text("da", "                                                      doi indici cel de linie si cel de coloana. Astfel, A[2][4] reprezinta",h);
    text("da", "                                                      elementul matricei aflat pe linia 2 si pe coloana 4 – la intersectia",h);
    text("da", "                                                      dintre linia 2 si coloana 4. Astfel primul indice al unui element ",h);
    text("da", "                                                      este cel de linie, iar al doilea indice este cel de coloana.",h);
    text("da", "                                                      Exemple:",h);


    while(true){
		 setcolor(WHITE);
		rectangle(XE / 2 - 105, YE - 150, XE / 2 + 113, YE - 100);
		settextstyle(6, 0 , 3);
		outtextxy(XE / 2 - 100, YE - 135, "Pagina 2 din 9");
        if(pga == 0)
           pga = intoarcere();
        if(pga == 1){
            return 2;
        }
        clearmouseclick(WM_LBUTTONDOWN);
        //sageata stanga
        line(XE / 2 - 150, YE - 125, XE / 2 - 125, YE - 100);
        line(XE / 2 - 150, YE - 125, XE / 2 - 125, YE - 150);
        if(!(mousex() > XE / 2 - 150 && mousex() < XE / 2 - 125 && mousey() > YE - 150 && mousey() < YE - 100) && GetAsyncKeyState(VK_LBUTTON))
            clearmouseclick(WM_LBUTTONDOWN);
        while(mousex() > XE / 2 - 150 && mousex() < XE / 2 - 125 && mousey() > YE - 150 && mousey() < YE - 100){
            setcolor(RGB(118,47,5));
            line(XE / 2 - 150, YE - 125, XE / 2 - 125, YE - 100);
            line(XE / 2 - 150, YE - 125, XE / 2 - 125, YE - 150);
            if(GetAsyncKeyState(VK_LBUTTON)){
                clearmouseclick(WM_LBUTTONDOWN);
                return 1;
            }
        }
        setcolor(WHITE);
        line(XE / 2 + 158, YE - 125, XE / 2 + 133, YE - 100);
        line(XE / 2 + 158, YE - 125, XE / 2 + 133, YE - 150);
        if(!(mousex() > XE / 2 + 133 && mousex() < XE / 2 + 158 && mousey() > YE - 150 && mousey() < YE - 100) && GetAsyncKeyState(VK_LBUTTON))
            clearmouseclick(WM_LBUTTONDOWN);
        while(mousex() > XE / 2 + 133 && mousex() < XE / 2 + 158 && mousey() > YE - 150 && mousey() < YE - 100){
            if(GetAsyncKeyState(VK_LBUTTON)){
                fnc = pag34();
                if(fnc == 1){
                    delay(200);
                    setbkcolor(RGB(196,192,251));
                    cleardevice();
                    setcolor(WHITE);
                    line(XE / 2 + 158, YE - 125, XE / 2 + 133, YE - 100);
                    line(XE / 2 + 158, YE - 125, XE / 2 + 133, YE - 150);
					 setbkcolor(RGB(196,192,251));
					cleardevice();
					setcolor(RGB(65,0,36));
					settextstyle(6, 0, 17);
					outtextxy(XE / 2 - 240, 50, "Tablouri bidimensionale");

					text("nu", "•	5 • 10 = 50 de elemente;",h);
					text("nu", "•	5 linii, indexate (numerotate) de la 0 la 4 – mai jos sunt evidentiate liniile cu indici 1 si 3;",h);
					text("nu", "•	10 coloane, indexate de la 0 la 9 – mai jos sunt evidentiate coloanele cu indici 0, 4 si 9;",h);
					text("da", "                                                      Referirea elementelor se face prin intermediul operatorului C++ de",h);
					text("da", "                                                      indexare [] la fel ca in cazul vectorilor, dar trebuie precizati",h);
					text("da", "                                                      doi indici cel de linie si cel de coloana. Astfel, A[2][4] reprezinta",h);
					text("da", "                                                      elementul matricei aflat pe linia 2 si pe coloana 4 – la intersectia",h);
					text("da", "                                                      dintre linia 2 si coloana 4. Astfel primul indice al unui element ",h);
					text("da", "                                                      este cel de linie, iar al doilea indice este cel de coloana.",h);
					text("da", "                                                      Exemple:",h);
					break;
                }
                else if(fnc == 2){
                    return 2;
                }
            }
        }
    }
}

int pag14(){
    int h = YE / 3 - 200;
    clearmouseclick(WM_LBUTTONDOWN);
    delay(200);
    setbkcolor(RGB(196,192,251));
    cleardevice();
    setcolor(RGB(65,0,36));
    settextstyle(6, 0, 17);
    outtextxy(XE / 2 - 240, 50, "Tablouri bidimensionale");

    text("da", "Tablourile unidimensionale C/C++ au elemente de acelasi tip. Astfel, tipul elementelor poate fi ", h);
    text("nu", "chiar tablou (unidimensional) elementele tabloului sunt la randul lor tablouri unidimensionale, care",h);
    text("nu", "au elemente de un anumit tip. Aceste tablouri se numesc bidimensionale sau matrice.",h);
    text("da", "Dintr-o perspectiva usor diferita, tablourile unidimensionale sunt structuri de date alcatuite",h);
    text("nu", "din elemente de acelasi tip, organizate pe linii si pe coloane.Astfel, fiecare element are doi indici:",h);
    text("nu", "un indice de linie si un indice de coloana.",h);
    text("da", "Declararea tablourilor bidimensionale (matrice) face in C/C++ similar cu a tablourilor",h);
    text("nu", "unidimensionale, dar trebuie precizate doua dimensiuni fizice, maximale: numarul maxim de linii si",h);
    text("nu", "numarul maxim de coloane ale matricei:",h);
    text("da", "tipDeBaza denumire[NumarLinii][NumarColoane];",h);
    text("da", "de exemplu:",h);
    text("da", "int A[5][10];",h);
    text("da", "Mai sus s-a declarat un tablou bidimensional (o matrice) cu 5 linii si 10 coloane. Ni-l putem",h);
    text("nu", "imagina astfel (valorile sunt aleatorii):",h);
    readimagefile("poza 14.jpg", 440, h + 140, 800, h + 350);

    while(true){
        setcolor(WHITE);
        rectangle(XE / 2 - 105, YE - 150, XE / 2 + 113, YE - 100);
        settextstyle(6, 0 , 3);
        outtextxy(XE / 2 - 100, YE - 135, "Pagina 1 din 9");
        if(pga == 0)
           pga = intoarcere();
        if(pga == 1){
            return 2;
        }
        clearmouseclick(WM_LBUTTONDOWN);
        setcolor(WHITE);
        line(XE / 2 + 158, YE - 125, XE / 2 + 133, YE - 100);
        line(XE / 2 + 158, YE - 125, XE / 2 + 133, YE - 150);
        if(!(mousex() > XE / 2 + 133 && mousex() < XE / 2 + 158 && mousey() > YE - 150 && mousey() < YE - 100) && GetAsyncKeyState(VK_LBUTTON))
            clearmouseclick(WM_LBUTTONDOWN);
        while(mousex() > XE / 2 + 133 && mousex() < XE / 2 + 158 && mousey() > YE - 150 && mousey() < YE - 100){
            if(GetAsyncKeyState(VK_LBUTTON)){
                fnc = pag24();
                if(fnc == 1){
                    delay(200);
                    setbkcolor(RGB(196,192,251));
                    cleardevice();
                    setcolor(WHITE);
                    line(XE / 2 + 158, YE - 125, XE / 2 + 133, YE - 100);
                    line(XE / 2 + 158, YE - 125, XE / 2 + 133, YE - 150);
					 setcolor(RGB(65,0,36));
					settextstyle(6, 0, 17);
					outtextxy(XE / 2 - 240, 50, "Tablouri bidimensionale");
					setcolor(WHITE);
					rectangle(XE / 2 - 105, YE - 150, XE / 2 + 113, YE - 100);
					settextstyle(6, 0 , 3);
					outtextxy(XE / 2 - 100, YE - 135, "Pagina 1 din 9");
					text("da", "Tablourile unidimensionale C/C++ au elemente de acelasi tip. Astfel, tipul elementelor poate fi ", h);
					text("nu", "chiar tablou (unidimensional) elementele tabloului sunt la randul lor tablouri unidimensionale, care",h);
					text("nu", "au elemente de un anumit tip. Aceste tablouri se numesc bidimensionale sau matrice.",h);
					text("da", "Dintr-o perspectiva usor diferita, tablourile unidimensionale sunt structuri de date alcatuite",h);
					text("nu", "din elemente de acelasi tip, organizate pe linii si pe coloane.Astfel, fiecare element are doi indici:",h);
					text("nu", "un indice de linie si un indice de coloana.",h);
					text("da", "Declararea tablourilor bidimensionale (matrice) face in C/C++ similar cu a tablourilor",h);
					text("nu", "unidimensionale, dar trebuie precizate doua dimensiuni fizice, maximale: numarul maxim de linii si",h);
					text("nu", "numarul maxim de coloane ale matricei:",h);
					text("da", "tipDeBaza denumire[NumarLinii][NumarColoane];",h);
					text("da", "de exemplu:",h);
					text("da", "int A[5][10];",h);
					text("da", "Mai sus s-a declarat un tablou bidimensional (o matrice) cu 5 linii si 10 coloane. Ni-l putem",h);
					text("nu", "imagina astfel (valorile sunt aleatorii):",h);
					readimagefile("poza 14.jpg", 440, h + 140, 800, h + 350);
					break;
                }
                else if(fnc == 2){
                    return 2;
                }
            }
        }
    }
}

int pag102(){
    int h = YE / 3 - 200;
    clearmouseclick(WM_LBUTTONDOWN);
    delay(200);
    setbkcolor(RGB(196,192,251));
    cleardevice();
    setcolor(RGB(65,0,36));
    settextstyle(6, 0, 17);
    outtextxy(XE / 2 - 240, 50, "Structuri Elementare");
    text("da", "Mod de executie", h);
    text("da", "Efectul instructiunii continue este ignorarea instructiunilor care ii urmeaza in corpul ciclului si", h);
    text("nu", "revenirea la evaluarea Expresiei, in cazul lui while, do ... while, respectiv la", h);
    text("nu", "Expresiei_de_Continuare, in cazul lui for.", h);
    text("da", "Exemplu:", h);
    text("da", "#include <iostream>", h);
    text("da", "using namespace std;", h);
    text("da", "int main ()", h);
    text("da", "{", h);
    text("da", "    int n;", h);
    text("da", "    cin >> n;", h);
    text("da", "    int S = 0;", h);
    text("da", "    for(int i = 1; i <= n ; i ++)", h);
    text("da", "    {if(i % 2 == 0)", h);
    text("da", "            continue;", h);
    text("da", "        S += i; }", h);
    text("da", "    cout << S << endl;", h);
    text("da", "    return 0;", h);
    text("da", "}", h);


    while(true){
        setcolor(WHITE);
        rectangle(XE / 2 - 110, YE - 150, XE / 2 + 125, YE - 100);
        settextstyle(6, 0 , 3);
        outtextxy(XE / 2 - 107, YE - 135, "Pagina 10 din 10");
        if(pga == 0)
           pga = intoarcere();
        if(pga == 1){
            return 2;
        }
        clearmouseclick(WM_LBUTTONDOWN);
        //sageata stanga
        line(XE / 2 - 150, YE - 125, XE / 2 - 125, YE - 100);
        line(XE / 2 - 150, YE - 125, XE / 2 - 125, YE - 150);
        if(!(mousex() > XE / 2 - 150 && mousex() < XE / 2 - 125 && mousey() > YE - 150 && mousey() < YE - 100) && GetAsyncKeyState(VK_LBUTTON))
            clearmouseclick(WM_LBUTTONDOWN);
        while(mousex() > XE / 2 - 150 && mousex() < XE / 2 - 125 && mousey() > YE - 150 && mousey() < YE - 100){
            setcolor(RGB(118,47,5));
            line(XE / 2 - 150, YE - 125, XE / 2 - 125, YE - 100);
            line(XE / 2 - 150, YE - 125, XE / 2 - 125, YE - 150);
            if(GetAsyncKeyState(VK_LBUTTON)){
                clearmouseclick(WM_LBUTTONDOWN);
                return 1;
            }
        }
        setcolor(WHITE);
    }
}

int pag92(){
    int h = YE / 3 - 200;
    clearmouseclick(WM_LBUTTONDOWN);
    delay(200);
    setbkcolor(RGB(196,192,251));
    cleardevice();
    setcolor(RGB(65,0,36));
    settextstyle(6, 0, 17);
    outtextxy(XE / 2 - 240, 50, "Structuri Elementare");
    text("da", "Mod de executie", h);
    text("da", "Am vazut semnificatia instructiunii break atunci cand apare in instructiunea switch", h);
    text("da", "Efectul instructiunii break cand apare intr-o instructiune repetitiva este intreruperea executiei", h);
    text("da", "acesteia si trecerea la instructiunea care urmeaza celei repetitive.", h);
    text("da", "Exemplu:", h);
    text("da", "#include <iostream>", h);
    text("da", "using namespace std;", h);
    text("da", "int main ()", h);
    text("da", "{   int n;", h);
    text("da", "    cin >> n;", h);
    text("da", "    int S = 0;", h);
    text("da", "    for(int i = 1; i <= n ; i ++)", h);
    text("da", "    { S += i;", h);
    text("da", "        if(i == 5)", h);
    text("da", "            break;}", h);
    text("da", "    cout << S << endl;", h);
    text("da", "    return 0;}", h);
    text("da", "•	Daca valoarea lui n este cel mult 5, se va afisa suma numerelor de la 1 la n.", h);
    text("da", "•	Daca n >= 5 se va afisa intotdeauna 15, deoarece executia lui for se intrerupe", h);
    text("da", "    datorita lui break, cand i este 5.", h);
    setcolor(RGB(60,56,153));
    settextstyle(10, 0 , 5);
    h += 20;
    outtextxy( 50, h, "Instructiunea continue");
    h+= 50;
    text("da", "Instructiunea continue are sens si poate fi folosita numai in instructiunile while, do ... while", h);
    text("nu", "si for.", h);
    text("da", "continue;", h);




    while(true){
        setcolor(WHITE);
        rectangle(XE / 2 - 105, YE - 150, XE / 2 + 113, YE - 100);
        settextstyle(6, 0 , 3);
        outtextxy(XE / 2 - 100, YE - 135, "Pagina 9 din 10");
        if(pga == 0)
           pga = intoarcere();
        if(pga == 1){
            return 2;
        }
        clearmouseclick(WM_LBUTTONDOWN);
        //sageata stanga
        line(XE / 2 - 150, YE - 125, XE / 2 - 125, YE - 100);
        line(XE / 2 - 150, YE - 125, XE / 2 - 125, YE - 150);
        if(!(mousex() > XE / 2 - 150 && mousex() < XE / 2 - 125 && mousey() > YE - 150 && mousey() < YE - 100) && GetAsyncKeyState(VK_LBUTTON))
            clearmouseclick(WM_LBUTTONDOWN);
        while(mousex() > XE / 2 - 150 && mousex() < XE / 2 - 125 && mousey() > YE - 150 && mousey() < YE - 100){
            setcolor(RGB(118,47,5));
            line(XE / 2 - 150, YE - 125, XE / 2 - 125, YE - 100);
            line(XE / 2 - 150, YE - 125, XE / 2 - 125, YE - 150);
            if(GetAsyncKeyState(VK_LBUTTON)){
                clearmouseclick(WM_LBUTTONDOWN);
                return 1;
            }
        }
        setcolor(WHITE);
        line(XE / 2 + 158, YE - 125, XE / 2 + 133, YE - 100);
        line(XE / 2 + 158, YE - 125, XE / 2 + 133, YE - 150);
        if(!(mousex() > XE / 2 + 133 && mousex() < XE / 2 + 158 && mousey() > YE - 150 && mousey() < YE - 100) && GetAsyncKeyState(VK_LBUTTON))
            clearmouseclick(WM_LBUTTONDOWN);
        while(mousex() > XE / 2 + 133 && mousex() < XE / 2 + 158 && mousey() > YE - 150 && mousey() < YE - 100){
            if(GetAsyncKeyState(VK_LBUTTON)){
                fnc = pag102();
                if(fnc == 1){
                    delay(200);
                    setbkcolor(RGB(196,192,251));
                    cleardevice();
                    setcolor(WHITE);
                    line(XE / 2 + 158, YE - 125, XE / 2 + 133, YE - 100);
                    line(XE / 2 + 158, YE - 125, XE / 2 + 133, YE - 150);
                    setcolor(RGB(65,0,36));
                    settextstyle(6, 0, 17);
                    outtextxy(XE / 2 - 240, 50, "Structuri Elementare");
                    text("da", "Mod de executie", h);
                    text("da", "Am vazut semnificatia instructiunii break atunci cand apare in instructiunea switch", h);
                    text("da", "Efectul instructiunii break cand apare intr-o instructiune repetitiva este intreruperea executiei", h);
                    text("da", "acesteia si trecerea la instructiunea care urmeaza celei repetitive.", h);
                    text("da", "Exemplu:", h);
                    text("da", "#include <iostream>", h);
                    text("da", "using namespace std;", h);
                    text("da", "int main ()", h);
                    text("da", "{   int n;", h);
                    text("da", "    cin >> n;", h);
                    text("da", "    int S = 0;", h);
                    text("da", "    for(int i = 1; i <= n ; i ++)", h);
                    text("da", "    { S += i;", h);
                    text("da", "        if(i == 5)", h);
                    text("da", "            break;}", h);
                    text("da", "    cout << S << endl;", h);
                    text("da", "    return 0;}", h);
                    text("da", "•	Daca valoarea lui n este cel mult 5, se va afisa suma numerelor de la 1 la n.", h);
                    text("da", "•	Daca n >= 5 se va afisa intotdeauna 15, deoarece executia lui for se intrerupe", h);
                    text("da", "    datorita lui break, cand i este 5.", h);
                    setcolor(RGB(60,56,153));
                    settextstyle(10, 0 , 5);
                    h += 20;
                    outtextxy( 50, h, "Instructiunea continue");
                    h+= 50;
                    text("da", "Instructiunea continue are sens si poate fi folosita numai in instructiunile while, do ... while", h);
                    text("nu", "si for.", h);
                    text("da", "continue;", h);
                    break;
                }
                else if(fnc == 2){
                    return 2;
                }

    }
}
    }
}
int pag82(){
    int h = YE / 3 - 200;
    clearmouseclick(WM_LBUTTONDOWN);
    delay(200);
    setbkcolor(RGB(196,192,251));
    cleardevice();
    setcolor(RGB(65,0,36));
    settextstyle(6, 0, 17);
    outtextxy(XE / 2 - 240, 50, "Structuri Elementare");
    text("da", "Mod de executie", h);
    text("da", "1.	Se evalueaza Expresie_de_Initializare", h);
    text("da", "2.	Se evalueaza Expresie_de_Testare", h);
    text("da", "3.	Daca Expresie_de_Testare este nenula:", h);
    text("da", "  o	  Se executa Instructiune.", h);
    text("da", "  o	  Se evalueaza Expresie_de_Continuare.", h);
    text("da", "  o	  Se revine la pasul 2.", h);
    text("da", "4.	Daca Expresie_de_Testare este nula, se trece la instructiunea de dupa for.", h);
    text("da", "Exemplu",h);
    text("da", "#include <iostream>", h);
    text("da", "using namespace std;                         Urmatorul program citeste valoarea variabilei n", h);
    text("da", "int main ()                                           si calculeaza suma primelor n numere naturale.", h);
    text("da", "{int n;                                      Rulati-l analizand rezultatul pentru diverse valori ale lui n, inclusiv 0.", h);
    text("da", "cin >> n;", h);
    text("da", "int S = 0;",h);
    text("da", "for(int i = 1; i <= n ; i ++)", h);
    text("da", "S += i;", h);
    text("da", "cout << S << endl;", h);
    text("da", "return 0;}", h);
    setcolor(RGB(60,56,153));
    settextstyle(10, 0 , 5);
    outtextxy( 50, h, "Instructiunea break");
    h += 50;
    text("da", "Instructiunea break aresens si poate fi folosita numai in instructiunile switch, while, do ... while", h);
    text("nu", "si for.", h);
    text("da", "break;", h);


    while(true){
        setcolor(WHITE);
        rectangle(XE / 2 - 105, YE - 150, XE / 2 + 113, YE - 100);
        settextstyle(6, 0 , 3);
        outtextxy(XE / 2 - 100, YE - 135, "Pagina 8 din 10");
        if(pga == 0)
           pga = intoarcere();
        if(pga == 1){
            return 2;
        }
        clearmouseclick(WM_LBUTTONDOWN);
        //sageata stanga
        line(XE / 2 - 150, YE - 125, XE / 2 - 125, YE - 100);
        line(XE / 2 - 150, YE - 125, XE / 2 - 125, YE - 150);
        if(!(mousex() > XE / 2 - 150 && mousex() < XE / 2 - 125 && mousey() > YE - 150 && mousey() < YE - 100) && GetAsyncKeyState(VK_LBUTTON))
            clearmouseclick(WM_LBUTTONDOWN);
        while(mousex() > XE / 2 - 150 && mousex() < XE / 2 - 125 && mousey() > YE - 150 && mousey() < YE - 100){
            setcolor(RGB(118,47,5));
            line(XE / 2 - 150, YE - 125, XE / 2 - 125, YE - 100);
            line(XE / 2 - 150, YE - 125, XE / 2 - 125, YE - 150);
            if(GetAsyncKeyState(VK_LBUTTON)){
                clearmouseclick(WM_LBUTTONDOWN);
                return 1;
            }
        }
        setcolor(WHITE);
        line(XE / 2 + 158, YE - 125, XE / 2 + 133, YE - 100);
        line(XE / 2 + 158, YE - 125, XE / 2 + 133, YE - 150);
        if(!(mousex() > XE / 2 + 133 && mousex() < XE / 2 + 158 && mousey() > YE - 150 && mousey() < YE - 100) && GetAsyncKeyState(VK_LBUTTON))
            clearmouseclick(WM_LBUTTONDOWN);
        while(mousex() > XE / 2 + 133 && mousex() < XE / 2 + 158 && mousey() > YE - 150 && mousey() < YE - 100){
            setcolor(RGB(118,47,5));
            line(XE / 2 + 158, YE - 125, XE / 2 + 133, YE - 100);
            line(XE / 2 + 158, YE - 125, XE / 2 + 133, YE - 150);
            if(GetAsyncKeyState(VK_LBUTTON)){
                fnc = pag92();
                if(fnc == 1){
                    delay(200);
                    setbkcolor(RGB(196,192,251));
                    cleardevice();
                    setcolor(WHITE);
                    line(XE / 2 + 158, YE - 125, XE / 2 + 133, YE - 100);
                    line(XE / 2 + 158, YE - 125, XE / 2 + 133, YE - 150);
                    setcolor(RGB(65,0,36));
                    settextstyle(6, 0, 17);
                    outtextxy(XE / 2 - 240, 50, "Structuri Elementare");
                    text("da", "Mod de executie", h);
                    text("da", "1.	Se evalueaza Expresie_de_Initializare", h);
                    text("da", "2.	Se evalueaza Expresie_de_Testare", h);
                    text("da", "3.	Daca Expresie_de_Testare este nenula:", h);
                    text("da", "  o	  Se executa Instructiune.", h);
                    text("da", "  o	  Se evalueaza Expresie_de_Continuare.", h);
                    text("da", "  o	  Se revine la pasul 2.", h);
                    text("da", "4.	Daca Expresie_de_Testare este nula, se trece la instructiunea de dupa for.", h);
                    text("da", "Exemplu",h);
                    text("da", "#include <iostream>", h);
                    text("da", "using namespace std;                         Urmatorul program citeste valoarea variabilei n", h);
                    text("da", "int main ()                                           si calculeaza suma primelor n numere naturale.", h);
                    text("da", "{int n;                                      Rulati-l analizand rezultatul pentru diverse valori ale lui n, inclusiv 0.", h);
                    text("da", "cin >> n;", h);
                    text("da", "int S = 0;",h);
                    text("da", "for(int i = 1; i <= n ; i ++)", h);
                    text("da", "S += i;", h);
                    text("da", "cout << S << endl;", h);
                    text("da", "return 0;}", h);
                    setcolor(RGB(60,56,153));
                    settextstyle(10, 0 , 5);
                    outtextxy( 50, h, "Instructiunea break");
                    h += 50;
                    text("da", "Instructiunea break aresens si poate fi folosita numai in instructiunile switch, while, do ... while", h);
                    text("nu", "si for.", h);
                    text("da", "break;", h);
                    break;
                }
                else if(fnc == 2){
                    return 2;
                }
        }
    }
    }
}
int pag72(){// pag72() adica pag 7 lectia 2, schimbati voi in functie de unde sunteti
    int h = YE / 3 - 200;
    clearmouseclick(WM_LBUTTONDOWN);
    delay(200);
    setbkcolor(RGB(196,192,251));
    cleardevice();
    setcolor(RGB(65,0,36));
    settextstyle(6, 0, 17);
    outtextxy(XE / 2 - 240, 50, "Structuri Elementare");
    text("nu", "Mod de executie", h);//primu argument e aliniat(da sau nu), al doilea e randul si al 3lea il lasati asa
    text("da", "1.	Se executa Instructiune", h);
    text("da", "2.	Se evalueaza Expresie", h);
    text("da", "3.	Daca Expresie este nenula, se reia pasul 1.", h);
    text("da", "4.	Daca Expresie este nula, se trece la instructiunea de dupa do ... while.", h);
    text("da", "#include <iostream>                          Exemplu",h);
    text("da", "using namespace std;                         Programul din stanga citeste valoarea variabilei n si calculeaza", h);
    text("da", "int main ()                                           suma primelor n numere naturale", h);
    text("da", "{int n;                                                  Rulati-l numere naturale. Rulati-l analizand rezultatul pentru",h);
    text("da", "cin >> n;                                             diverse valori ale lui n, inclusiv 0.", h);
    text("da", "int S = 0;", h);
    text("da", "int i = 1;", h);
    text("da", "do", h);
    text("da", "{S += i;", h);
    text("da", "i ++;}", h);
    text("da", "while(i <= n);", h);
    text("da", "cout << S << endl;", h);
    text("da", "return 0;}", h);
    settextstyle(10, 0 , 5);
    setcolor(RGB(60,56,153));
    outtextxy( 50, h, "Instructiunea for");
    h += 50;
    text("da", "Instructiunea for este o structura repetitiva cu numar necunoscut de pasi si test initial", h);
    text("nu", "echivalenta cu while.", h);
    text("da", "for( Expresie_de_Initializare ; Expresie_de_Testare ; Expresie_de_Continuare ) Instructiune", h);


    while(true){
        setcolor(WHITE);
        rectangle(XE / 2 - 105, YE - 150, XE / 2 + 113, YE - 100);
        settextstyle(6, 0 , 3);
        outtextxy(XE / 2 - 100, YE - 135, "Pagina 7 din 10");
        if(pga == 0)
           pga = intoarcere();
        if(pga == 1){
            return 2;
        }
        clearmouseclick(WM_LBUTTONDOWN);
        //sageata stanga
        line(XE / 2 - 150, YE - 125, XE / 2 - 125, YE - 100);
        line(XE / 2 - 150, YE - 125, XE / 2 - 125, YE - 150);
        if(!(mousex() > XE / 2 - 150 && mousex() < XE / 2 - 125 && mousey() > YE - 150 && mousey() < YE - 100) && GetAsyncKeyState(VK_LBUTTON))
            clearmouseclick(WM_LBUTTONDOWN);
        while(mousex() > XE / 2 - 150 && mousex() < XE / 2 - 125 && mousey() > YE - 150 && mousey() < YE - 100){
            setcolor(RGB(118,47,5));
            line(XE / 2 - 150, YE - 125, XE / 2 - 125, YE - 100);
            line(XE / 2 - 150, YE - 125, XE / 2 - 125, YE - 150);
            if(GetAsyncKeyState(VK_LBUTTON)){
                clearmouseclick(WM_LBUTTONDOWN);
                return 1;
            }
        }
        setcolor(WHITE);
        line(XE / 2 + 158, YE - 125, XE / 2 + 133, YE - 100);
        line(XE / 2 + 158, YE - 125, XE / 2 + 133, YE - 150);
        if(!(mousex() > XE / 2 + 133 && mousex() < XE / 2 + 158 && mousey() > YE - 150 && mousey() < YE - 100) && GetAsyncKeyState(VK_LBUTTON))
            clearmouseclick(WM_LBUTTONDOWN);
        while(mousex() > XE / 2 + 133 && mousex() < XE / 2 + 158 && mousey() > YE - 150 && mousey() < YE - 100){
            setcolor(RGB(118,47,5));
            line(XE / 2 + 158, YE - 125, XE / 2 + 133, YE - 100);
            line(XE / 2 + 158, YE - 125, XE / 2 + 133, YE - 150);
            if(GetAsyncKeyState(VK_LBUTTON)){
                fnc = pag82();
                if(fnc == 1){
                    h = YE/ 3 - 200;
                    delay(200);
                    setbkcolor(RGB(196,192,251));
                    cleardevice();
                    setcolor(WHITE);
                    line(XE / 2 + 158, YE - 125, XE / 2 + 133, YE - 100);
                    line(XE / 2 + 158, YE - 125, XE / 2 + 133, YE - 150);
                    setcolor(RGB(65,0,36));
                    settextstyle(6, 0, 17);
                    outtextxy(XE / 2 - 240, 50, "Structuri Elementare");
                    text("nu", "Mod de executie", h);//primu argument e aliniat(da sau nu), al doilea e randul si al 3lea il lasati asa
                    text("da", "1.	Se executa Instructiune", h);
                    text("da", "2.	Se evalueaza Expresie", h);
                    text("da", "3.	Daca Expresie este nenula, se reia pasul 1.", h);
                    text("da", "4.	Daca Expresie este nula, se trece la instructiunea de dupa do ... while.", h);
                    text("da", "#include <iostream>                          Exemplu",h);
                    text("da", "using namespace std;                         Programul din stanga citeste valoarea variabilei n si calculeaza", h);
                    text("da", "int main ()                                           suma primelor n numere naturale", h);
                    text("da", "{int n;                                                  Rulati-l numere naturale. Rulati-l analizand rezultatul pentru",h);
                    text("da", "cin >> n;                                             diverse valori ale lui n, inclusiv 0.", h);
                    text("da", "int S = 0;", h);
                    text("da", "int i = 1;", h);
                    text("da", "do", h);
                    text("da", "{S += i;", h);
                    text("da", "i ++;}", h);
                    text("da", "while(i <= n);", h);
                    text("da", "cout << S << endl;", h);
                    text("da", "return 0;}", h);
                    settextstyle(10, 0 , 5);
                    outtextxy( 50, YE / 3 - 190, "Instructiunea for");
                    h += 50;
                    text("da", "Instructiunea for este o structura repetitiva cu numar necunoscut de pasi si test initial", h);
                    text("nu", "echivalenta cu while.", h);
                    text("da", "for( Expresie_de_Initializare ; Expresie_de_Testare ; Expresie_de_Continuare ) Instructiune", h);
                    break;
                }
                else if(fnc == 2){
                    return 2;
                }
            }
        }
    }
}
int pag62(){
    int h6 = YE / 3 - 150;
    clearmouseclick(WM_LBUTTONDOWN);
    delay(200);
    setbkcolor(RGB(196,192,251));
    cleardevice();
    setcolor(RGB(65,0,36));
    settextstyle(6, 0, 17);
    outtextxy(XE / 2 - 240, 50, "Structuri Elementare");

    setcolor(RGB(60,56,153));
    settextstyle(10, 0 , 5);
    outtextxy( 50, h6, "Instructiunea while");
    h6+=40;
    text("da", "Instructiunea while este o structura repetitiva cu numar necunoscut de pasi si test initial.", h6);
    text("da", "while (Expresie) Instructiune", h6);
    text("da", "Mod de executie", h6);
    text("da", "1.	Se evalueaza Expresie", h6);
    text("da", "2.	Daca Expresie este nenula", h6);
    text("da", " o	 Se executa Instructiune", h6);
    text("da", " o	 Se reia pasul 1.", h6);
    text("da", "3.	Daca Expresie este nula, se trece la instructiunea de dupa while.", h6);
    text("da", "Exemplu", h6);
    text("da", "#include <iostream>                       Programul din stanga citeste valoarea variabilei n", h6);
    text("da", "using namespace std;                      si calculeaza suma primelor n numere naturale.", h6);
    text("da", "int main ()                                        Rulati-l analizand rezultatul pentru diverse", h6);
    text("da", "{int n;                                               valori ale lui n, inclusiv 0.", h6);
    text("da", "cin >> n;", h6);
    text("da", "int S = 0;", h6);
    text("da", "int i = 1;", h6);
    text("da", "while(i <= n)", h6);
    text("da", "{S += i;", h6);
    text("da", "i++;}", h6);
    text("da", "cout << S << endl;", h6);
    text("da", "return 0;}", h6);
    setcolor(RGB(60,56,153));
    settextstyle(10, 0 , 5);
    outtextxy( 50, h6, "Instructiunea do ... while");
    h6 += 50;
    text("da", "Instructiunea do ... while este o structura repetitiva cu numar necunoscut de pasi si test final.", h6);
    text("da", "DoInstructiune", h6);
    text("da", "while ( Expresie );", h6);



    while(true){
         setcolor(WHITE);
        rectangle(XE / 2 - 105, YE - 150, XE / 2 + 113, YE - 100);
        settextstyle(6, 0 , 3);
        outtextxy(XE / 2 - 100, YE - 135, "Pagina 6 din 10");
        if(pga == 0)
           pga = intoarcere();
        if(pga == 1){
            return 2;
        }
        clearmouseclick(WM_LBUTTONDOWN);
        //sageata stanga
        line(XE / 2 - 150, YE - 125, XE / 2 - 125, YE - 100);
        line(XE / 2 - 150, YE - 125, XE / 2 - 125, YE - 150);
        if(!(mousex() > XE / 2 - 150 && mousex() < XE / 2 - 125 && mousey() > YE - 150 && mousey() < YE - 100) && GetAsyncKeyState(VK_LBUTTON))
            clearmouseclick(WM_LBUTTONDOWN);
        while(mousex() > XE / 2 - 150 && mousex() < XE / 2 - 125 && mousey() > YE - 150 && mousey() < YE - 100){
            setcolor(RGB(118,47,5));
            line(XE / 2 - 150, YE - 125, XE / 2 - 125, YE - 100);
            line(XE / 2 - 150, YE - 125, XE / 2 - 125, YE - 150);
            if(GetAsyncKeyState(VK_LBUTTON)){
                clearmouseclick(WM_LBUTTONDOWN);
                return 1;
            }
        }
        //sageata dreapta
        setcolor(WHITE);
        line(XE / 2 + 158, YE - 125, XE / 2 + 133, YE - 100);
        line(XE / 2 + 158, YE - 125, XE / 2 + 133, YE - 150);
        if(!(mousex() > XE / 2 + 133 && mousex() < XE / 2 + 158 && mousey() > YE - 150 && mousey() < YE - 100) && GetAsyncKeyState(VK_LBUTTON))
            clearmouseclick(WM_LBUTTONDOWN);
        while(mousex() > XE / 2 + 133 && mousex() < XE / 2 + 158 && mousey() > YE - 150 && mousey() < YE - 100){
            if(GetAsyncKeyState(VK_LBUTTON)){
                fnc = pag72();
                if(fnc == 1){
                    h6 = YE / 3 - 150;
                    clearmouseclick(WM_LBUTTONDOWN);
                    delay(200);
                    setbkcolor(RGB(196,192,251));
                    cleardevice();
                    setcolor(WHITE);
                    line(XE / 2 + 158, YE - 125, XE / 2 + 133, YE - 100);
                    line(XE / 2 + 158, YE - 125, XE / 2 + 133, YE - 150);
                    setcolor(RGB(65,0,36));
                    settextstyle(6, 0, 17);
                    outtextxy(XE / 2 - 240, 50, "Structuri Elementare");
                    setcolor(RGB(60,56,153));
                    settextstyle(10, 0 , 5);
                    outtextxy( 50, h6, "Instructiunea while");
                    h6+=40;
                    text("da", "Instructiunea while este o structura repetitiva cu numar necunoscut de pasi si test initial.", h6);
                    text("da", "while (Expresie) Instructiune", h6);
                    text("da", "Mod de executie", h6);
                    text("da", "1.	Se evalueaza Expresie", h6);
                    text("da", "2.	Daca Expresie este nenula", h6);
                    text("da", " o	 Se executa Instructiune", h6);
                    text("da", " o	 Se reia pasul 1.", h6);
                    text("da", "3.	Daca Expresie este nula, se trece la instructiunea de dupa while.", h6);
                    text("da", "Exemplu", h6);
                    text("da", "#include <iostream>                       Programul din stanga citeste valoarea variabilei n", h6);
                    text("da", "using namespace std;                      si calculeaza suma primelor n numere naturale.", h6);
                    text("da", "int main ()                                        Rulati-l analizand rezultatul pentru diverse", h6);
                    text("da", "{int n;                                               valori ale lui n, inclusiv 0.", h6);
                    text("da", "cin >> n;", h6);
                    text("da", "int S = 0;", h6);
                    text("da", "int i = 1;", h6);
                    text("da", "while(i <= n)", h6);
                    text("da", "{S += i;", h6);
                    text("da", "i++;}", h6);
                    text("da", "cout << S << endl;", h6);
                    text("da", "return 0;}", h6);
                    setcolor(RGB(60,56,153));
                    settextstyle(10, 0 , 5);
                    outtextxy( 50, h6, "Instructiunea do ... while");
                    h6 += 50;
                    text("da", "Instructiunea do ... while este o structura repetitiva cu numar necunoscut de pasi si test final.", h6);
                    text("da", "DoInstructiune", h6);
                    text("da", "while ( Expresie );", h6);
                    break;
                }
                if(fnc == 2){
                    clearmouseclick(WM_LBUTTONDOWN);
                    return 2;
                }
            }
            setcolor(RGB(118,47,5));
            line(XE / 2 + 158, YE - 125, XE / 2 + 133, YE - 100);
            line(XE / 2 + 158, YE - 125, XE / 2 + 133, YE - 150);
        }
        setcolor(WHITE);
    }
}

int pag52(){
    int h5 = YE / 3 - 210;
    clearmouseclick(WM_LBUTTONDOWN);
    delay(200);
    setbkcolor(RGB(196,192,251));
    cleardevice();
    setcolor(RGB(65,0,36));
    settextstyle(6, 0, 17);
    outtextxy(XE / 2 - 240, 50, "Structuri Elementare");
    setcolor(RGB(60,56,153));
    settextstyle(10, 0 , 5);
    outtextxy( 50, h5, "Instructiunea switch");
    h5+=40;
    text("da", "Instructiunea switch permite executarea unor instructiuni,in functie de egalitatea unei expresii", h5);
    text("nu", "anumite valori numerice constante:", h5);
    text("da", "Mod de executie", h5);
    text("da", "•	se evalueaza Expresie", h5);
    text("da", "•	daca valoarea expresiei este egala cu una dintre valorile constante din clauzele case, se executa", h5);
    text("da", " instructiunile din grupul de instructiuni corespunzator,apoi se trece la instructiunea de dupa switch", h5);
    text("da", "•	daca valoarea expresiei nu este egala cu niciuna dintre valorile constante din clauzele case", h5);
    text("da", " se verifica existenta clausei default;", h5);
    text("da", "  o	 daca exista clauza default, se executa instructiunile din grupul de instructiuni corespunzator", h5);
    text("da", "   clauzei default, apoi se trece la instructiunea de dupa switch", h5);
    text("da", "  o	 daca nu exista clauza default, se trece la instructiunea de dupa switch", h5);
    text("da", "3. Exemple", h5);
    text("nu", "In exemplul de mai jos se afiseaza (aproximativ) numele zilei din saptamana in functie de numarul ei.", h5);
    text("da", "#include <iostream>", h5);
    text("da", "using namespace std;", h5);
    text("da", "int main(){int zi;", h5);
    text("da", "cin >> zi;", h5);
    text("da", "switch(zi)", h5);
    text("da", "{case 1:", h5);
    text("da", "cout << Luni\n; break;", h5);
    text("da", "case 2:", h5);
    text("da", "cout << Marti\n; break;", h5);
    text("da", "case 3:", h5);
    text("da", "cout << Miercuri\n; break;", h5);
    text("da", "case 4:", h5);
    text("da", "cout << Joi\n; break;",h5);
    text("da", "case 5:", h5);
    text("da", "cout << Vineri\n; break;", h5);
    text("da", "case 6:", h5);
    text("da", "cout << WEEKEND!!!\n; break;", h5);
    text("da", "default:", h5);
    text("da", "cout << Numarul zilei este incorect\n; break;}", h5);
    text("da", "return 0;}", h5);

    while(true){
        setcolor(WHITE);
        rectangle(XE / 2 - 105, YE - 150, XE / 2 + 113, YE - 100);
        settextstyle(6, 0 , 3);
        outtextxy(XE / 2 - 100, YE - 135, "Pagina 5 din 10");
        if(pga == 0)
           pga = intoarcere();
        if(pga == 1){
            return 2;
        }
        clearmouseclick(WM_LBUTTONDOWN);
        //sageata stanga
        line(XE / 2 - 150, YE - 125, XE / 2 - 125, YE - 100);
        line(XE / 2 - 150, YE - 125, XE / 2 - 125, YE - 150);
        if(!(mousex() > XE / 2 - 150 && mousex() < XE / 2 - 125 && mousey() > YE - 150 && mousey() < YE - 100) && GetAsyncKeyState(VK_LBUTTON))
            clearmouseclick(WM_LBUTTONDOWN);
        while(mousex() > XE / 2 - 150 && mousex() < XE / 2 - 125 && mousey() > YE - 150 && mousey() < YE - 100){
            setcolor(RGB(118,47,5));
            line(XE / 2 - 150, YE - 125, XE / 2 - 125, YE - 100);
            line(XE / 2 - 150, YE - 125, XE / 2 - 125, YE - 150);
            if(GetAsyncKeyState(VK_LBUTTON)){
                clearmouseclick(WM_LBUTTONDOWN);
                return 1;
            }
        }
        //sageata dreapta
        setcolor(WHITE);
        line(XE / 2 + 158, YE - 125, XE / 2 + 133, YE - 100);
        line(XE / 2 + 158, YE - 125, XE / 2 + 133, YE - 150);
        if(!(mousex() > XE / 2 + 133 && mousex() < XE / 2 + 158 && mousey() > YE - 150 && mousey() < YE - 100) && GetAsyncKeyState(VK_LBUTTON))
            clearmouseclick(WM_LBUTTONDOWN);
        while(mousex() > XE / 2 + 133 && mousex() < XE / 2 + 158 && mousey() > YE - 150 && mousey() < YE - 100){
            if(GetAsyncKeyState(VK_LBUTTON)){
                fnc = pag62();
                if(fnc == 1){
                    h5 = YE / 3 - 210;
                    clearmouseclick(WM_LBUTTONDOWN);
                    delay(200);
                    setbkcolor(RGB(196,192,251));
                    cleardevice();
                    line(XE / 2 + 158, YE - 125, XE / 2 + 133, YE - 100);
                    line(XE / 2 + 158, YE - 125, XE / 2 + 133, YE - 150);
                    setcolor(RGB(65,0,36));
                    settextstyle(6, 0, 17);
                    outtextxy(XE / 2 - 240, 50, "Structuri Elementare");
                    setcolor(RGB(60,56,153));
                    settextstyle(10, 0 , 5);
                    outtextxy( 50, h5, "Instructiunea switch");
                    h5+=40;
                    text("da", "Instructiunea switch permite executarea unor instructiuni,in functie de egalitatea unei expresii", h5);
                    text("nu", "anumite valori numerice constante:", h5);
                    text("da", "Mod de executie", h5);
                    text("da", "•	se evalueaza Expresie", h5);
                    text("da", "•	daca valoarea expresiei este egala cu una dintre valorile constante din clauzele case, se executa", h5);
                    text("da", " instructiunile din grupul de instructiuni corespunzator,apoi se trece la instructiunea de dupa switch", h5);
                    text("da", "•	daca valoarea expresiei nu este egala cu niciuna dintre valorile constante din clauzele case", h5);
                    text("da", " se verifica existenta clausei default;", h5);
                    text("da", "  o	 daca exista clauza default, se executa instructiunile din grupul de instructiuni corespunzator", h5);
                    text("da", "   clauzei default, apoi se trece la instructiunea de dupa switch", h5);
                    text("da", "  o	 daca nu exista clauza default, se trece la instructiunea de dupa switch", h5);
                    text("da", "3. Exemple", h5);
                    text("nu", "In exemplul de mai jos se afiseaza (aproximativ) numele zilei din saptamana in functie de numarul ei.", h5);
                    text("da", "#include <iostream>", h5);
                    text("da", "using namespace std;", h5);
                    text("da", "int main(){int zi;", h5);
                    text("da", "cin >> zi;", h5);
                    text("da", "switch(zi)", h5);
                    text("da", "{case 1:", h5);
                    text("da", "cout << Luni\n; break;", h5);
                    text("da", "case 2:", h5);
                    text("da", "cout << Marti\n; break;", h5);
                    text("da", "case 3:", h5);
                    text("da", "cout << Miercuri\n; break;", h5);
                    text("da", "case 4:", h5);
                    text("da", "cout << Joi\n; break;",h5);
                    text("da", "case 5:", h5);
                    text("da", "cout << Vineri\n; break;", h5);
                    text("da", "case 6:", h5);
                    text("da", "cout << WEEKEND!!!\n; break;", h5);
                    text("da", "default:", h5);
                    text("da", "cout << Numarul zilei este incorect\n; break;}", h5);
                    text("da", "return 0;}", h5);
                    break;
                }
                if(fnc == 2){
                    return 2;
                }
            }
            setcolor(RGB(118,47,5));
            line(XE / 2 + 158, YE - 125, XE / 2 + 133, YE - 100);
            line(XE / 2 + 158, YE - 125, XE / 2 + 133, YE - 150);
        }
        setcolor(WHITE);
    }
}

int pag42(){
    int h4 = YE / 3 - 150;
    clearmouseclick(WM_LBUTTONDOWN);
    delay(200);
    setbkcolor(RGB(196,192,251));
    cleardevice();
    setcolor(RGB(65,0,36));
    settextstyle(6, 0, 17);
    outtextxy(XE / 2 - 240, 50, "Structuri Elementare");
    text("da", "Exemple", h4);
    text("nu", "Urmatoarea secventa decide daca un numar intreg citi este par sau nu:", h4);
    text("da", "int x;", h4);
    text("da", "cin >> x;", h4);
    text("da", "if(x % 2 == 0)", h4);
    text("da", "  cout << x << este par;", h4);
    text("da", "else", h4);
    text("da", "  cout << x <<  este impar;", h4);
    h4+=10;
    text("da", "Urmatoarea secventa testeaza egalitatea cu 0 a unei expresii in forma scurta, fara a folosi operatorii", h4);
    text("nu", " de egalitate:", h4);
    text("da", "if( n )", h4);
    text("da", "  cout << n << nenul;", h4);
    text("da", "else", h4);
    text("da", "  cout << x << este impar;", h4);
    text("da", "Urmatoarea secventa testeaza egalitatea cu 0 a unei expresii in forma scurta,fara a folosi operatorii", h4);
    text("nu", "de egalitate:", h4);
    h4+=10;
    text("da", "if(n)", h4);
    text("da", "   cout << n << nenul;", h4);
    text("da", "else", h4);
    text("da", "   cout << n << este nul;", h4);

    while(true){
        setcolor(WHITE);
        rectangle(XE / 2 - 105, YE - 150, XE / 2 + 113, YE - 100);
        settextstyle(6, 0 , 3);
        outtextxy(XE / 2 - 100, YE - 135, "Pagina 4 din 10");

        if(pga == 0)
           pga = intoarcere();
        if(pga == 1){
            return 2;
        }
        clearmouseclick(WM_LBUTTONDOWN);
        //sageata stanga
        line(XE / 2 - 150, YE - 125, XE / 2 - 125, YE - 100);
        line(XE / 2 - 150, YE - 125, XE / 2 - 125, YE - 150);
        if(!(mousex() > XE / 2 - 150 && mousex() < XE / 2 - 125 && mousey() > YE - 150 && mousey() < YE - 100) && GetAsyncKeyState(VK_LBUTTON))
            clearmouseclick(WM_LBUTTONDOWN);
        while(mousex() > XE / 2 - 150 && mousex() < XE / 2 - 125 && mousey() > YE - 150 && mousey() < YE - 100){
            setcolor(RGB(118,47,5));
            line(XE / 2 - 150, YE - 125, XE / 2 - 125, YE - 100);
            line(XE / 2 - 150, YE - 125, XE / 2 - 125, YE - 150);
            if(GetAsyncKeyState(VK_LBUTTON)){
                clearmouseclick(WM_LBUTTONDOWN);
                return 1;
            }
        }
        //sageata dreapta
        setcolor(WHITE);
        line(XE / 2 + 158, YE - 125, XE / 2 + 133, YE - 100);
        line(XE / 2 + 158, YE - 125, XE / 2 + 133, YE - 150);
        if(!(mousex() > XE / 2 + 133 && mousex() < XE / 2 + 158 && mousey() > YE - 150 && mousey() < YE - 100) && GetAsyncKeyState(VK_LBUTTON))
            clearmouseclick(WM_LBUTTONDOWN);
        while(mousex() > XE / 2 + 133 && mousex() < XE / 2 + 158 && mousey() > YE - 150 && mousey() < YE - 100){
            if(GetAsyncKeyState(VK_LBUTTON)){
                fnc = pag52();
                if(fnc == 1){
                    fnc = 0;
                    h4 = YE / 3 - 150;
                    clearmouseclick(WM_LBUTTONDOWN);
                    delay(200);
                    text("da", "Exemple", h4);
                    text("nu", "Urmatoarea secventa decide daca un numar intreg citi este par sau nu:", h4);
                    text("da", "int x;", h4);
                    text("da", "cin >> x;", h4);
                    text("da", "if(x % 2 == 0)", h4);
                    text("da", "  cout << x << este par;", h4);
                    text("da", "else", h4);
                    text("da", "  cout << x <<  este impar;", h4);
                    h4+=10;
                    text("da", "Urmatoarea secventa testeaza egalitatea cu 0 a unei expresii in forma scurta, fara a folosi operatorii", h4);
                    text("nu", " de egalitate:", h4);
                    text("da", "if( n )", h4);
                    text("da", "  cout << n << nenul;", h4);
                    text("da", "else", h4);
                    text("da", "  cout << x << este impar;", h4);
                    text("da", "Urmatoarea secventa testeaza egalitatea cu 0 a unei expresii in forma scurta,fara a folosi operatorii", h4);
                    text("nu", "de egalitate:", h4);
                    h4+=10;
                    text("da", "if(n)", h4);
                    text("da", "   cout << n << nenul;", h4);
                    text("da", "else", h4);
                    text("da", "   cout << n << este nul;", h4);
                    break;
                }
                else if(fnc == 2){
                    return 2;
                }
            }
            setcolor(RGB(118,47,5));
            line(XE / 2 + 158, YE - 125, XE / 2 + 133, YE - 100);
            line(XE / 2 + 158, YE - 125, XE / 2 + 133, YE - 150);
        }
        setcolor(WHITE);
    }
}

int pag32(){
    int h3 = YE / 3 - 150;
    clearmouseclick(WM_LBUTTONDOWN);
    delay(200);
    setbkcolor(RGB(196,192,251));
    cleardevice();
    setcolor(RGB(65,0,36));
    settextstyle(6, 0, 17);
    outtextxy(XE / 2 - 240, 50, "Structuri Elementare");
    setcolor(RGB(60,56,153));
    settextstyle(10, 0 , 5);
    outtextxy( 50, h3, "Structuri alternative");
    h3+=50;
    text("da", "In anumite situatii,este necesara executarea unor instructiuni in cadrul unui program numai in ", h3);
    text("nu", "anumite conditii. Numite si structuri de decizie, structurile alternative permit rezolvarea unor asemenea", h3);
    text("nu", "situatii.", h3);
    h3 += 25;
    setcolor(RGB(60,56,153));
    settextstyle(10, 0 , 5);
    outtextxy( 40, h3, "Instructiunea if");
    h3+=50;
    text("da", "Instructiunea if este cea mai utilizata structura alternativa.Instructiunea if are doua forme:", h3);
    text("da", "Varianta 1", h3);
    text("nu", "if(Expresie)Instructiune1", h3);
    text("nu", "else Instructiune2", h3);
    text("da", "Varianta 2", h3);
    text("nu", "if ( Expresie ) Instructiune1", h3);
    text("da", "Mod de executie", h3);
    text("nu", "•	se evalueaza Expresia", h3);
    text("nu", "•	daca valoarea ei este nenula", h3);
    text("da", "o	se executa Instructiune1", h3);
    text("da", "o	se continua cu instructiunea care urmeaza dupa if", h3);
    text("nu", "•	daca valoare expresiei este nula", h3);
    text("da", "o	 daca exista clauza else", h3);
    text("da", "    se executa Instructiune 2", h3);
    text("da", "    se continua cu instructiunea care urmeaza dupa if", h3);
    text("da", "o	 daca nu exista clauza else, se continua cu instructiunea care urmeaza dupa if", h3);



    while(true){
        setcolor(WHITE);
        rectangle(XE / 2 - 105, YE - 150, XE / 2 + 113, YE - 100);
        settextstyle(6, 0 , 3);
        outtextxy(XE / 2 - 100, YE - 135, "Pagina 3 din 10");
        if(pga == 0)
           pga = intoarcere();
        if(pga == 1){
            return 2;
        }
        clearmouseclick(WM_LBUTTONDOWN);
        //sageata stanga
        line(XE / 2 - 150, YE - 125, XE / 2 - 125, YE - 100);
        line(XE / 2 - 150, YE - 125, XE / 2 - 125, YE - 150);
        if(!(mousex() > XE / 2 - 150 && mousex() < XE / 2 - 125 && mousey() > YE - 150 && mousey() < YE - 100) && GetAsyncKeyState(VK_LBUTTON))
            clearmouseclick(WM_LBUTTONDOWN);
        while(mousex() > XE / 2 - 150 && mousex() < XE / 2 - 125 && mousey() > YE - 150 && mousey() < YE - 100){
            setcolor(RGB(118,47,5));
            line(XE / 2 - 150, YE - 125, XE / 2 - 125, YE - 100);
            line(XE / 2 - 150, YE - 125, XE / 2 - 125, YE - 150);
            if(GetAsyncKeyState(VK_LBUTTON)){
                clearmouseclick(WM_LBUTTONDOWN);
                return 1;
            }
        }
        //sageata dreapta
        setcolor(WHITE);
        line(XE / 2 + 158, YE - 125, XE / 2 + 133, YE - 100);
        line(XE / 2 + 158, YE - 125, XE / 2 + 133, YE - 150);
        if(!(mousex() > XE / 2 + 133 && mousex() < XE / 2 + 158 && mousey() > YE - 150 && mousey() < YE - 100) && GetAsyncKeyState(VK_LBUTTON))
            clearmouseclick(WM_LBUTTONDOWN);
        while(mousex() > XE / 2 + 133 && mousex() < XE / 2 + 158 && mousey() > YE - 150 && mousey() < YE - 100){
            if(GetAsyncKeyState(VK_LBUTTON)){
                fnc = pag42();
                if(fnc == 1){
                    h3 = YE / 3 - 150;
                    clearmouseclick(WM_LBUTTONDOWN);
                    delay(200);
                    setbkcolor(RGB(196,192,251));
                    cleardevice();
                    setcolor(RGB(65,0,36));
                    settextstyle(6, 0, 17);
                    outtextxy(XE / 2 - 240, 50, "Structuri Elementare");
                    setcolor(RGB(60,56,153));
                    settextstyle(10, 0 , 5);
                    outtextxy( 50, h3, "Structuri alternative");
                    h3+=50;
                    text("da", "In anumite situatii,este necesara executarea unor instructiuni in cadrul unui program numai in ", h3);
                    text("nu", "anumite conditii. Numite si structuri de decizie, structurile alternative permit rezolvarea unor asemenea", h3);
                    text("nu", "situatii.", h3);
                    h3 += 25;
                    setcolor(RGB(60,56,153));
                    settextstyle(10, 0 , 5);
                    outtextxy( 40, h3, "Instructiunea if");
                    h3+=50;
                    text("da", "Instructiunea if este cea mai utilizata structura alternativa.Instructiunea if are doua forme:", h3);
                    text("da", "Varianta 1", h3);
                    text("nu", "if(Expresie)Instructiune1", h3);
                    text("nu", "else Instructiune2", h3);
                    text("da", "Varianta 2", h3);
                    text("nu", "if ( Expresie ) Instructiune1", h3);
                    text("da", "Mod de executie", h3);
                    text("nu", "•	se evalueaza Expresia", h3);
                    text("nu", "•	daca valoarea ei este nenula", h3);
                    text("da", "o	se executa Instructiune1", h3);
                    text("da", "o	se continua cu instructiunea care urmeaza dupa if", h3);
                    text("nu", "•	daca valoare expresiei este nula", h3);
                    text("da", "o	 daca exista clauza else", h3);
                    text("da", "    se executa Instructiune 2", h3);
                    text("da", "    se continua cu instructiunea care urmeaza dupa if", h3);
                    text("da", "o	 daca nu exista clauza else, se continua cu instructiunea care urmeaza dupa if", h3);


                    break;
                }
                else if(fnc == 2){
                    return 2;
                }
            }
            setcolor(RGB(118,47,5));
            line(XE / 2 + 158, YE - 125, XE / 2 + 133, YE - 100);
            line(XE / 2 + 158, YE - 125, XE / 2 + 133, YE - 150);
        }
        setcolor(WHITE);
    }
}

int pag22(){
    int h2 = YE / 3 - 150;
    clearmouseclick(WM_LBUTTONDOWN);
    delay(200);
    setbkcolor(RGB(196,192,251));
    cleardevice();
    setcolor(RGB(65,0,36));
    settextstyle(6, 0, 17);
    outtextxy(XE / 2 - 240, 50, "Structuri elementare");//Titlu lectiei
    text("da", "Exemple:", h2);
    text("da", "#include <iostream>", h2);
    text("da", "using namespace std;", h2);
    text("da", "int main(){", h2);
    text("da", "int x = 5;", h2);
    text("nu", "{", h2);
    text("da", "int x = 7;", h2);
    text("da", "cout << x << endl; // se va afisa 7}", h2);
    text("da", "cout << x << endl; // se va afisa 5", h2);
    text("da", "return 0;", h2);
    text("nu", "}", h2);
    setcolor(RGB(60,56,153));
    settextstyle(10, 0 , 5);
    outtextxy( 50, h2, "Instructiunea return");
    h2+=40;
    text("da", "O instructiune return permite iesirea dintr-o functie si transmiterea controlului apelantului functiei.", h2);
    text("nu", "O functie poate returna valori apelantului sau, prin intermediul unei instructiuni return.", h2);
    text("da", "Sintaxa:",h2);
    text("da", "return;", h2);
    text("da", "In primul caz valoarea returnata nu este definita. In al doilea caz valoarea expresiei este returnata", h2);
    text("nu", "apelantului functiei.", h2);
    setcolor(RGB(60,56,153));
    settextstyle(10, 0 , 5);
    outtextxy( 50, h2, "Instructiunea vida");
    h2+= 50;
    text("da", "In anumite situatii, sintaxa limbajului C++ cere prezenta unei instructiuni intr-un anumit punct", h2);
    text("nu", "al programului, dar logica acestuia nu cere acest lucru. Aici intervine instructiunea vida, cu urmatoarea", h2);
    text("nu", "sintaxa: ;", h2);
    text("da", "La intalnirea instructiunii vide nu se va executa nicio actiune.", h2);

    setcolor(WHITE);
    rectangle(XE / 2 - 105, YE - 150, XE / 2 + 113, YE - 100);
    settextstyle(6, 0 , 3);
    outtextxy(XE / 2 - 100, YE - 135, "Pagina 2 din 10");
    setcolor(WHITE);
    while(true){
        if(pga == 0)
           pga = intoarcere();
        if(pga == 1){
            return 2;
        }
        //sageata stanga
        line(XE / 2 - 150, YE - 125, XE / 2 - 125, YE - 100);
        line(XE / 2 - 150, YE - 125, XE / 2 - 125, YE - 150);
        if(!(mousex() > XE / 2 - 150 && mousex() < XE / 2 - 125 && mousey() > YE - 150 && mousey() < YE - 100) && GetAsyncKeyState(VK_LBUTTON))
            clearmouseclick(WM_LBUTTONDOWN);
        while(mousex() > XE / 2 - 150 && mousex() < XE / 2 - 125 && mousey() > YE - 150 && mousey() < YE - 100){
            setcolor(RGB(118,47,5));
            line(XE / 2 - 150, YE - 125, XE / 2 - 125, YE - 100);
            line(XE / 2 - 150, YE - 125, XE / 2 - 125, YE - 150);
            if(GetAsyncKeyState(VK_LBUTTON)){
                clearmouseclick(WM_LBUTTONDOWN);
                return 1;
            }
        }
        //sageata dreapta
        setcolor(WHITE);
        line(XE / 2 + 158, YE - 125, XE / 2 + 133, YE - 100);
        line(XE / 2 + 158, YE - 125, XE / 2 + 133, YE - 150);
        if(!(mousex() > XE / 2 + 133 && mousex() < XE / 2 + 158 && mousey() > YE - 150 && mousey() < YE - 100) && GetAsyncKeyState(VK_LBUTTON))
            clearmouseclick(WM_LBUTTONDOWN);
        while(mousex() > XE / 2 + 133 && mousex() < XE / 2 + 158 && mousey() > YE - 150 && mousey() < YE - 100){
            if(GetAsyncKeyState(VK_LBUTTON)){
                fnc = pag32();
                if(fnc == 1){
                        fnc = 0;
                        delay(300);
                        h2 = YE / 3 - 150;
                        clearmouseclick(WM_LBUTTONDOWN);
                        delay(200);
                        setbkcolor(RGB(196,192,251));
                        cleardevice();
                        setcolor(RGB(65,0,36));
                        settextstyle(6, 0, 17);
                        outtextxy(XE / 2 - 240, 50, "Structuri elementare");//Titlu lectiei
                        text("da", "Exemple:", h2);
                        text("da", "#include <iostream>", h2);
                        text("da", "using namespace std;", h2);
                        text("da", "int main(){", h2);
                        text("da", "int x = 5;", h2);
                        text("nu", "{", h2);
                        text("da", "int x = 7;", h2);
                        text("da", "cout << x << endl; // se va afisa 7}", h2);
                        text("da", "cout << x << endl; // se va afisa 5", h2);
                        text("da", "return 0;", h2);
                        text("nu", "}", h2);
                        setcolor(RGB(60,56,153));
                        settextstyle(10, 0 , 5);
                        outtextxy( 50, h2, "Instructiunea return");
                        h2+=40;
                        text("da", "O instructiune return permite iesirea dintr-o functie si transmiterea controlului apelantului functiei.", h2);
                        text("nu", "O functie poate returna valori apelantului sau, prin intermediul unei instructiuni return.", h2);
                        text("da", "Sintaxa:",h2);
                        text("da", "return;", h2);
                        text("da", "In primul caz valoarea returnata nu este definita. In al doilea caz valoarea expresiei este returnata", h2);
                        text("nu", "apelantului functiei.", h2);
                        setcolor(RGB(60,56,153));
                        settextstyle(10, 0 , 5);
                        outtextxy( 50, h2, "Instructiunea vida");
                        h2+= 50;
                        text("da", "In anumite situatii, sintaxa limbajului C++ cere prezenta unei instructiuni intr-un anumit punct", h2);
                        text("nu", "al programului, dar logica acestuia nu cere acest lucru. Aici intervine instructiunea vida, cu urmatoarea", h2);
                        text("nu", "sintaxa: ;", h2);
                        text("da", "La intalnirea instructiunii vide nu se va executa nicio actiune.", h2);
                        setcolor(WHITE);
                        rectangle(XE / 2 - 105, YE - 150, XE / 2 + 113, YE - 100);
                        settextstyle(6, 0 , 3);
                        outtextxy(XE / 2 - 100, YE - 135, "Pagina 2 din 11");
                        setcolor(WHITE);
                        break;
                    }
                else if(fnc == 2){
                       return 2;
                }
                clearmouseclick(WM_LBUTTONDOWN);
            }
            setcolor(RGB(118,47,5));
            line(XE / 2 + 158, YE - 125, XE / 2 + 133, YE - 100);
            line(XE / 2 + 158, YE - 125, XE / 2 + 133, YE - 150);
        }
        setcolor(WHITE);
        clearmouseclick(WM_LBUTTONDOWN);

    }
}
int pag12(){
    int h1 = YE / 3 - 150;
    cleardevice();
    clearmouseclick(WM_LBUTTONDOWN);
    setbkcolor(RGB(196,192,251));
    cleardevice();

    setcolor(RGB(65,0,36));
    settextstyle(6, 0, 17);
    outtextxy(XE / 2 - 240, 50, "Structuri elementare");//Titlu lectiei
    setcolor(RGB(60,56,153));
    settextstyle(10, 0 , 5);
    outtextxy( 50, h1, "Instructiunea declarativa");
    h1 += 50;
    text("da", "Printr-o instructiune declarativa se pot declara identificatori de un anumit tip.Identificatorii pot fi", h1);
    text("nu", "variabile, dar vom vedea mai tarziu ca pot fi si functii.", h1);
    text("da", "Sintaxa este:", h1);
    text("da", "Tip_de_date Lista_identificatori;", h1);
    text("da", "unde", h1);
    text("da", "Tip_de_date poate fi orice tip C++ corect (int, double, etc.), iar Lista_identificatori este alcatuita", h1);
    text("nu", "din cel putin un identificator. Daca sunt mai multi, se vor separa prin caracterul virgula (,).", h1);
    text("da", "Exemple:", h1);
    text("da", "int x,y,z;", h1);
    text("da", "double a;", h1);
    setcolor(RGB(60,56,153));
    settextstyle(10, 0 , 5);
    h1 += 25;
    outtextxy( 50, h1, "Instructiunea compusa");
    h1+=40;
    text("da", "Instructiunea compusa sau blocul este o grupare de declaratii si instructiuni inchise intre acolade.",h1);
    text("nu", "Ele au fost introduse cu scopul de a folosi mai multe instructiuni acolo unde sintaxa cere o singura", h1);
    text("nu", "instructiune. Instructiunea compusa sau blocul sunt echivalente sintactic cu o singura instructiune.", h1);
    text("da", "Blocul determina si un domeniu de vizibilitate pentru identificatori. Mai precis, identificatorii", h1);
    text("nu", "declarati intr-un bloc vor fi eliminati la terminarea acestuia.",h1);
    text("da", "Dupa acolada inchisa } nu se scrie ;!", h1);
    while(true){
            setcolor(WHITE);
                    settextstyle(6, 0 , 3);
                    outtextxy(XE / 2 - 100, YE - 135, "Pagina 1 din 10");
                    rectangle(XE / 2 - 105, YE - 150, XE / 2 + 113, YE - 100);
        if(pga == 0)
            pga = intoarcere();
        else
            return 1;
        //sageata dreapta
        setcolor(WHITE);
        line(XE / 2 + 158, YE - 125, XE / 2 + 133, YE - 100);
        line(XE / 2 + 158, YE - 125, XE / 2 + 133, YE - 150);
        if(!(mousex() > XE / 2 + 133 && mousex() < XE / 2 + 158 && mousey() > YE - 150 && mousey() < YE - 100) && GetAsyncKeyState(VK_LBUTTON))
            clearmouseclick(WM_LBUTTONDOWN);
        while(mousex() > XE / 2 + 133 && mousex() < XE / 2 + 158 && mousey() > YE - 150 && mousey() < YE - 100){
            if(GetAsyncKeyState(VK_LBUTTON)){
                clearmouseclick(WM_LBUTTONDOWN);
                fnc = pag22();
                if(fnc == 1){
                    fnc = 0;
                    h1 = YE / 3 - 150;
                    clearmouseclick(WM_LBUTTONDOWN);
                    setbkcolor(RGB(196,192,251));
                    cleardevice();
                    setcolor(RGB(65,0,36));
                    settextstyle(6, 0, 17);
                    outtextxy(XE / 2 - 240, 50, "Structuri elementare");//Titlu lectiei
                    setcolor(RGB(60,56,153));
                    settextstyle(10, 0 , 5);
                    outtextxy( 50, h1, "Instructiunea declarativa");
                    h1 += 50;
                    text("da", "Printr-o instructiune declarativa se pot declara identificatori de un anumit tip.Identificatorii pot fi", h1);
                    text("nu", "variabile, dar vom vedea mai tarziu ca pot fi si functii.", h1);
                    text("da", "Sintaxa este:", h1);
                    text("da", "Tip_de_date Lista_identificatori;", h1);
                    text("da", "unde", h1);
                    text("da", "Tip_de_date poate fi orice tip C++ corect (int, double, etc.), iar Lista_identificatori este alcatuita", h1);
                    text("nu", "din cel putin un identificator. Daca sunt mai multi, se vor separa prin caracterul virgula (,).", h1);
                    text("da", "Exemple:", h1);
                    text("da", "int x,y,z;", h1);
                    text("da", "double a;", h1);
                    setcolor(RGB(60,56,153));
                    settextstyle(10, 0 , 5);
                    h1+=25;
                    outtextxy( 50, h1, "Instructiunea compusa");
                    h1+=40;
                    text("da", "Instructiunea compusa sau blocul este o grupare de declaratii si instructiuni inchise intre acolade.",h1);
                    text("nu", "Ele au fost introduse cu scopul de a folosi mai multe instructiuni acolo unde sintaxa cere o singura", h1);
                    text("nu", "instructiune. Instructiunea compusa sau blocul sunt echivalente sintactic cu o singura instructiune.", h1);
                    text("da", "Blocul determina si un domeniu de vizibilitate pentru identificatori. Mai precis, identificatorii", h1);
                    text("nu", "declarati intr-un bloc vor fi eliminati la terminarea acestuia.",h1);
                    text("da", "Dupa acolada inchisa } nu se scrie ;!", h1);
                    setcolor(WHITE);
                    rectangle(XE / 2 - 105, YE - 150, XE / 2 + 113, YE - 100);
                    settextstyle(6, 0 , 3);
                    outtextxy(XE / 2 - 95, YE - 135, "Pagina 1 din 11");
                    break;
                }
                if(fnc == 2){
                    return 0;
                }
            }
            setcolor(RGB(118,47,5));
            line(XE / 2 + 158, YE - 125, XE / 2 + 133, YE - 100);
            line(XE / 2 + 158, YE - 125, XE / 2 + 133, YE - 150);
        }
        setcolor(WHITE);
    }
}

int pag66(){
    int h6 = YE / 3 - 150;
    clearmouseclick(WM_LBUTTONDOWN);
    delay(200);
    setbkcolor(RGB(196,192,251));
    cleardevice();
    setcolor(RGB(65,0,36));
    settextstyle(6, 0, 17);
    outtextxy(XE / 2 - 240, 50, "Subprograme");
    setcolor(WHITE);
    rectangle(XE / 2 - 105, YE - 150, XE / 2 + 113, YE - 100);
    settextstyle(6, 0 , 3);
    outtextxy(XE / 2 - 95, YE - 135, "Pagina 6 din 7");
    text("nu", "Variabilele locale respecta urmatoarele reguli:", h6);
    text("da", "•	li se aloca memorie in zona de stiva", h6);
    text("da", "•	sunt vizibile numai in blocul in care au fost declarate", h6);
    text("da", "•	durata de viata a lor este executia instructiunilor din blocul in care au fost declarate", h6);
    text("da", "•	sunt initializate cu valori aleatorii. Mai precis, standardul C++ nu garanteaza initializarea lor cu o anumita valoare. Asta nu inseamna ", h6);
    text("da", "ca nu este posibil ca variabilele locale sa fie initializate de exemplu cu 0 intr-o anumita anumita implementare a compilatorului, dar ", h6);
    text("da", "nu ne putem baza pe acest lucru.", h6);
    h6 += 25;
    setcolor(RGB(60,56,153));
    settextstyle(10, 0 , 5);
    outtextxy( 50, h6, "Variabile globale");
    h6 += 50;
    text("nu", "Variabilele globale se declara in afara oricarei functii. La declarare, ele sunt initializate cu 0." ,h6);
    text("nu", "#include <iostream>", h6);
    text("nu", "using namespace std;", h6);
    text("nu", "int x;", h6);
    text("nu", "void F(){", h6);
    text("nu", "    cout << x << endl;", h6);
    text("nu", "    x = 10;", h6);
    text("nu", "}", h6);
    text("nu", "int y;", h6);
    text("nu", "int main(){", h6);
    text("nu", "    cout << x << " " << y << endl;", h6);
    text("nu", "    x = 5; y = 15;", h6);
    text("nu", "    F();", h6);
    text("nu", "    cout << x << " " << y << endl;", h6);
    text("nu", "    return 0;", h6);
    text("nu", "}", h6);
    while(true){
        if(pga == 0)
           pga = intoarcere();
        if(pga == 1){
             pga = 0;
            return 2;
        }
        clearmouseclick(WM_LBUTTONDOWN);
        //sageata stanga
        line(XE / 2 - 150, YE - 125, XE / 2 - 125, YE - 100);
        line(XE / 2 - 150, YE - 125, XE / 2 - 125, YE - 150);
        if(!(mousex() > XE / 2 - 150 && mousex() < XE / 2 - 125 && mousey() > YE - 150 && mousey() < YE - 100) && GetAsyncKeyState(VK_LBUTTON))
            clearmouseclick(WM_LBUTTONDOWN);
        while(mousex() > XE / 2 - 150 && mousex() < XE / 2 - 125 && mousey() > YE - 150 && mousey() < YE - 100){
            setcolor(RGB(118,47,5));
            line(XE / 2 - 150, YE - 125, XE / 2 - 125, YE - 100);
            line(XE / 2 - 150, YE - 125, XE / 2 - 125, YE - 150);
            if(GetAsyncKeyState(VK_LBUTTON)){
                clearmouseclick(WM_LBUTTONDOWN);
                return 1;
            }
        }
        //sageata dreapta
        setcolor(WHITE);
        line(XE / 2 + 158, YE - 125, XE / 2 + 133, YE - 100);
        line(XE / 2 + 158, YE - 125, XE / 2 + 133, YE - 150);
        if(!(mousex() > XE / 2 + 133 && mousex() < XE / 2 + 158 && mousey() > YE - 150 && mousey() < YE - 100) && GetAsyncKeyState(VK_LBUTTON))
            clearmouseclick(WM_LBUTTONDOWN);
        while(mousex() > XE / 2 + 133 && mousex() < XE / 2 + 158 && mousey() > YE - 150 && mousey() < YE - 100){
            if(GetAsyncKeyState(VK_LBUTTON)){
                fnc = pag76();
                if(fnc == 1){
                    h6 = YE / 3 - 150;
                    clearmouseclick(WM_LBUTTONDOWN);
                    delay(200);
                    setbkcolor(RGB(196,192,251));
                    cleardevice();
                    setcolor(RGB(65,0,36));
                    settextstyle(6, 0, 17);
                    outtextxy(XE / 2 - 240, 50, "Subprograme");
                    setcolor(WHITE);

                    line(XE / 2 + 158, YE - 125, XE / 2 + 133, YE - 100);
                    line(XE / 2 + 158, YE - 125, XE / 2 + 133, YE - 150);

                    rectangle(XE / 2 - 105, YE - 150, XE / 2 + 113, YE - 100);
                    settextstyle(6, 0 , 3);
                    outtextxy(XE / 2 - 95, YE - 135, "Pagina 6 din 7");
                    text("nu", "Variabilele locale respecta urmatoarele reguli:", h6);
                    text("da", "•	li se aloca memorie in zona de stiva", h6);
                    text("da", "•	sunt vizibile numai in blocul in care au fost declarate", h6);
                    text("da", "•	durata de viata a lor este executia instructiunilor din blocul in care au fost declarate", h6);
                    text("da", "•	sunt initializate cu valori aleatorii. Mai precis, standardul C++ nu garanteaza initializarea lor cu o anumita valoare. Asta nu inseamna ", h6);
                    text("da", "ca nu este posibil ca variabilele locale sa fie initializate de exemplu cu 0 intr-o anumita anumita implementare a compilatorului, dar ", h6);
                    text("da", "nu ne putem baza pe acest lucru.", h6);
                    h6 += 25;
                    setcolor(RGB(60,56,153));
                    settextstyle(10, 0 , 5);
                    outtextxy( 50, h6, "Variabile globale");
                    h6 += 50;
                    text("nu", "Variabilele globale se declara in afara oricarei functii. La declarare, ele sunt initializate cu 0." ,h6);
                    text("nu", "#include <iostream>", h6);
                    text("nu", "using namespace std;", h6);
                    text("nu", "int x;", h6);
                    text("nu", "void F(){", h6);
                    text("nu", "    cout << x << endl;", h6);
                    text("nu", "    x = 10;", h6);
                    text("nu", "}", h6);
                    text("nu", "int y;", h6);
                    text("nu", "int main(){", h6);
                    text("nu", "    cout << x << " " << y << endl;", h6);
                    text("nu", "    x = 5; y = 15;", h6);
                    text("nu", "    F();", h6);
                    text("nu", "    cout << x << " " << y << endl;", h6);
                    text("nu", "    return 0;", h6);
                    text("nu", "}", h6);
                    break;
                }
                if(fnc == 2){
                    clearmouseclick(WM_LBUTTONDOWN);
                    return 2;
                }
            }
            setcolor(RGB(118,47,5));
            line(XE / 2 + 158, YE - 125, XE / 2 + 133, YE - 100);
            line(XE / 2 + 158, YE - 125, XE / 2 + 133, YE - 150);
        }
        setcolor(WHITE);
    }
}

int pag56(){
    int h5 = YE / 3 - 150;
    clearmouseclick(WM_LBUTTONDOWN);
    delay(200);
    setbkcolor(RGB(196,192,251));
    cleardevice();
    setcolor(RGB(65,0,36));
    settextstyle(6, 0, 17);
    outtextxy(XE / 2 - 240, 50, "Subprograme");
    setcolor(WHITE);
    rectangle(XE / 2 - 105, YE - 150, XE / 2 + 113, YE - 100);
    settextstyle(6, 0 , 3);
    outtextxy(XE / 2 - 95, YE - 135, "Pagina 5 din 7");
    text("nu", "Durata de viata reprezinta timpul in care variabilei ii este alocat spatiu in memorie si poate fi:", h5);
    text("da", "•	durata statica – variabila are alocat spatiu pe tot parcursul executiei programului", h5);
    text("da", "•	durata locala – variabila are alocat spatiu numai pe parcursul executiei instructiunilor dintr-un bloc", h5);
    text("da", "•	durata dinamica – variabila se creeaza (i se aloca spatiu) si se distruge de catre programator, in timpul executarii programului", h5);
    h5 += 25;
    text("nu", "In C++ variabile pot fi: locale, globale si dinamice. Variabile dinamice vor fi prezentate intr-un alt articol,  iar cele statice si dinamice in continuare.", h5);
    h5 += 25;
    setcolor(RGB(60,56,153));
    settextstyle(10, 0 , 5);
    outtextxy( 50, h5, "Variabile locale");
    h5 += 50;
    text("nu", "Variabilele locale se declara intr-un anumit bloc al programului, in corpul unei functii. Fie programul de mai jos:", h5);
    h5 += 10;
    text("nu", "#include <iostream>", h5);
    text("nu", "using namespace std;", h5);
    text("nu", "void F(){", h5);
    text("nu", "    int x;", h5);
    text("nu", "    x = 5;", h5);
    text("nu", "    cout << x << endl;", h5);
    text("nu", "}", h5);
    text("nu", "int main(){", h5);
    text("nu", "    int y = 10;", h5);
    text("nu", "    F();", h5);
    text("nu", "    cout << y << endl;", h5);
    text("nu", "    return 0;", h5);
    text("nu", "}", h5);
    text("nu", "Variabilele x si y declarate in programul de mai sus sunt locale. Variabila x poate fi utilizata numai in functie F(), iar variabila y numai  ", h5);
    text("nu", "in functia main(). Mai mult, cele doua variabile ar fi putut avea acelasi nume si nu ar fi fost nicio confuzie.", h5);
    while(true){
        if(pga == 0)
           pga = intoarcere();
        if(pga == 1){
             pga = 0;
            return 2;
        }
        clearmouseclick(WM_LBUTTONDOWN);
        //sageata stanga
        line(XE / 2 - 150, YE - 125, XE / 2 - 125, YE - 100);
        line(XE / 2 - 150, YE - 125, XE / 2 - 125, YE - 150);
        if(!(mousex() > XE / 2 - 150 && mousex() < XE / 2 - 125 && mousey() > YE - 150 && mousey() < YE - 100) && GetAsyncKeyState(VK_LBUTTON))
            clearmouseclick(WM_LBUTTONDOWN);
        while(mousex() > XE / 2 - 150 && mousex() < XE / 2 - 125 && mousey() > YE - 150 && mousey() < YE - 100){
            setcolor(RGB(118,47,5));
            line(XE / 2 - 150, YE - 125, XE / 2 - 125, YE - 100);
            line(XE / 2 - 150, YE - 125, XE / 2 - 125, YE - 150);
            if(GetAsyncKeyState(VK_LBUTTON)){
                clearmouseclick(WM_LBUTTONDOWN);
                return 1;
            }
        }
        //sageata dreapta
        setcolor(WHITE);
        line(XE / 2 + 158, YE - 125, XE / 2 + 133, YE - 100);
        line(XE / 2 + 158, YE - 125, XE / 2 + 133, YE - 150);
        if(!(mousex() > XE / 2 + 133 && mousex() < XE / 2 + 158 && mousey() > YE - 150 && mousey() < YE - 100) && GetAsyncKeyState(VK_LBUTTON))
            clearmouseclick(WM_LBUTTONDOWN);
        while(mousex() > XE / 2 + 133 && mousex() < XE / 2 + 158 && mousey() > YE - 150 && mousey() < YE - 100){
            if(GetAsyncKeyState(VK_LBUTTON)){
                fnc = pag66();
                if(fnc == 1){
                    h5 = YE / 3 - 150;
                    clearmouseclick(WM_LBUTTONDOWN);
                    delay(200);
                    setbkcolor(RGB(196,192,251));
                    cleardevice();

                    line(XE / 2 + 158, YE - 125, XE / 2 + 133, YE - 100);
                    line(XE / 2 + 158, YE - 125, XE / 2 + 133, YE - 150);

                    setcolor(RGB(65,0,36));
                    settextstyle(6, 0, 17);
                    outtextxy(XE / 2 - 240, 50, "Subprograme");
                    setcolor(WHITE);
                    rectangle(XE / 2 - 105, YE - 150, XE / 2 + 113, YE - 100);
                    settextstyle(6, 0 , 3);
                    outtextxy(XE / 2 - 95, YE - 135, "Pagina 5 din 7");
                    text("nu", "Durata de viata reprezinta timpul in care variabilei ii este alocat spatiu in memorie si poate fi:", h5);
                    text("da", "•	durata statica – variabila are alocat spatiu pe tot parcursul executiei programului", h5);
                    text("da", "•	durata locala – variabila are alocat spatiu numai pe parcursul executiei instructiunilor dintr-un bloc", h5);
                    text("da", "•	durata dinamica – variabila se creeaza (i se aloca spatiu) si se distruge de catre programator, in timpul executarii programului", h5);
                    h5 += 25;
                    text("nu", "In C++ variabile pot fi: locale, globale si dinamice. Variabile dinamice vor fi prezentate intr-un alt articol,  iar cele statice si dinamice in continuare.", h5);
                    h5 += 25;
                    setcolor(RGB(60,56,153));
                    settextstyle(10, 0 , 5);
                    outtextxy( 50, h5, "Variabile locale");
                    h5 += 50;
                    text("nu", "Variabilele locale se declara intr-un anumit bloc al programului, in corpul unei functii. Fie programul de mai jos:", h5);
                    h5 += 10;
                    text("nu", "#include <iostream>", h5);
                    text("nu", "using namespace std;", h5);
                    text("nu", "void F(){", h5);
                    text("nu", "    int x;", h5);
                    text("nu", "    x = 5;", h5);
                    text("nu", "    cout << x << endl;", h5);
                    text("nu", "}", h5);
                    text("nu", "int main(){", h5);
                    text("nu", "    int y = 10;", h5);
                    text("nu", "    F();", h5);
                    text("nu", "    cout << y << endl;", h5);
                    text("nu", "    return 0;", h5);
                    text("nu", "}", h5);
                    text("nu", "Variabilele x si y declarate in programul de mai sus sunt locale. Variabila x poate fi utilizata numai in functie F(), iar variabila y numai  ", h5);
                    text("nu", "in functia main(). Mai mult, cele doua variabile ar fi putut avea acelasi nume si nu ar fi fost nicio confuzie.", h5);

                    break;
                }
                if(fnc == 2){
                    return 2;
                }
            }
            setcolor(RGB(118,47,5));
            line(XE / 2 + 158, YE - 125, XE / 2 + 133, YE - 100);
            line(XE / 2 + 158, YE - 125, XE / 2 + 133, YE - 150);
        }
        setcolor(WHITE);
    }
}

int pag46(){
    int h4 = YE / 3 - 150;
    clearmouseclick(WM_LBUTTONDOWN);
    delay(200);
    setbkcolor(RGB(196,192,251));
    cleardevice();
    setcolor(RGB(65,0,36));
    settextstyle(6, 0, 17);
    outtextxy(XE / 2 - 240, 50, "Subprograme");
    setcolor(WHITE);
    rectangle(XE / 2 - 105, YE - 150, XE / 2 + 113, YE - 100);
    settextstyle(6, 0 , 3);
    outtextxy(XE / 2 - 95, YE - 135, "Pagina 4 din 7");

    text("nu", "Observam ca prototipul (declararea) este o instructiune C++ obisnuita, care se termina cu ;!!", h4);
    h4 += 25;
    text("nu", "Dupa cum stim, in C++ variabilele despre care am invatat pana acum trebuie declarate si odata cu declararea li se aloca in memorie spatiu ", h4);
    text("nu", "in conformitate cu tipul lor. Intrebarea este: “Unde putem declara variabile si prin ce difera acestea?”.", h4);
    h4 += 25;
    text("nu", "Sistemul de operare aloca fiecarui program, in memoria RAM, trei zone in care putem memora variabile:", h4);
    text("da", "•	zona de date", h4);
    text("da", "•	zona de stiva", h4);
    text("da", "•	zona libera(heap)", h4);
    h4 += 25;
    text("da", "O variabila se caracterizeaza prin:", h4);
    text("da", "1.	clasa de memorare", h4);
    text("da", "2.	vizibilitate", h4);
    text("da", "3.	durata de viata", h4);
    text("da", "4.	tipul variabilei", h4);
    h4 += 25;
    text("nu", "Sa nu uitam, de asemenea, identificatorul variabilei! Dar nu toate variabilele au un identificator, asa cum vom vedea candva!", h4);
    h4 += 25;
    text("nu", "Clasa de memorare reprezinta zona de memorie unde poate fi alocat spatiu pentru o variabila. Ea poate fi: zona de date, zona de stiva,", h4);
    text("nu", "heap-ul sau un registru al procesorului – o memorie speciala, de mici dimensiuni, foarte rapida existenta in procesor (CPU).", h4);
    h4 += 25;
    text("nu", "Vizibilitatea unei variabile precizeaza zona din codul sursa (liniile programului C++) unde se poate folosi respectiva variabila si poate fi:", h4);
    text("da", "•	la nivel de bloc – variabila este vizibila numai intr-un bloc al programului", h4);
    text("da", "•	la nivel de fisier – variabila este vizibila in tot fisierul sursa cu care lucram", h4);
    text("da", "•	la nivel de clasa – specific programarii orientate pe obiecte", h4);


    while(true){
        if(pga == 0)
           pga = intoarcere();
        if(pga == 1){
             pga = 0;
            return 2;
        }
        clearmouseclick(WM_LBUTTONDOWN);
        //sageata stanga
        line(XE / 2 - 150, YE - 125, XE / 2 - 125, YE - 100);
        line(XE / 2 - 150, YE - 125, XE / 2 - 125, YE - 150);
        if(!(mousex() > XE / 2 - 150 && mousex() < XE / 2 - 125 && mousey() > YE - 150 && mousey() < YE - 100) && GetAsyncKeyState(VK_LBUTTON))
            clearmouseclick(WM_LBUTTONDOWN);
        while(mousex() > XE / 2 - 150 && mousex() < XE / 2 - 125 && mousey() > YE - 150 && mousey() < YE - 100){
            setcolor(RGB(118,47,5));
            line(XE / 2 - 150, YE - 125, XE / 2 - 125, YE - 100);
            line(XE / 2 - 150, YE - 125, XE / 2 - 125, YE - 150);
            if(GetAsyncKeyState(VK_LBUTTON)){
                clearmouseclick(WM_LBUTTONDOWN);
                return 1;
            }
        }
        //sageata dreapta
        setcolor(WHITE);
        line(XE / 2 + 158, YE - 125, XE / 2 + 133, YE - 100);
        line(XE / 2 + 158, YE - 125, XE / 2 + 133, YE - 150);
        if(!(mousex() > XE / 2 + 133 && mousex() < XE / 2 + 158 && mousey() > YE - 150 && mousey() < YE - 100) && GetAsyncKeyState(VK_LBUTTON))
            clearmouseclick(WM_LBUTTONDOWN);
        while(mousex() > XE / 2 + 133 && mousex() < XE / 2 + 158 && mousey() > YE - 150 && mousey() < YE - 100){
            if(GetAsyncKeyState(VK_LBUTTON)){
                fnc = pag56();
                if(fnc == 1){
                    fnc = 0;
                    h4 = YE / 3 - 150;
                    clearmouseclick(WM_LBUTTONDOWN);
                    delay(200);
                    setbkcolor(RGB(196,192,251));
                    cleardevice();
                    setcolor(RGB(65,0,36));
                    settextstyle(6, 0, 17);
                    outtextxy(XE / 2 - 240, 50, "Subprograme");
                    setcolor(WHITE);

                    line(XE / 2 + 158, YE - 125, XE / 2 + 133, YE - 100);
                    line(XE / 2 + 158, YE - 125, XE / 2 + 133, YE - 150);

                    rectangle(XE / 2 - 105, YE - 150, XE / 2 + 113, YE - 100);
                    settextstyle(6, 0 , 3);
                    outtextxy(XE / 2 - 95, YE - 135, "Pagina 4 din 7");
                    text("nu", "Observam ca prototipul (declararea) este o instructiune C++ obisnuita, care se termina cu ;!!", h4);
                    h4 += 25;
                    text("nu", "Dupa cum stim, in C++ variabilele despre care am invatat pana acum trebuie declarate si odata cu declararea li se aloca in memorie spatiu ", h4);
                    text("nu", "in conformitate cu tipul lor. Intrebarea este: “Unde putem declara variabile si prin ce difera acestea?”.", h4);
                    h4 += 25;
                    text("nu", "Sistemul de operare aloca fiecarui program, in memoria RAM, trei zone in care putem memora variabile:", h4);
                    text("da", "•	zona de date", h4);
                    text("da", "•	zona de stiva", h4);
                    text("da", "•	zona libera(heap)", h4);
                    h4 += 25;
                    text("da", "O variabila se caracterizeaza prin:", h4);
                    text("da", "1.	clasa de memorare", h4);
                    text("da", "2.	vizibilitate", h4);
                    text("da", "3.	durata de viata", h4);
                    text("da", "4.	tipul variabilei", h4);
                    h4 += 25;
                    text("nu", "Sa nu uitam, de asemenea, identificatorul variabilei! Dar nu toate variabilele au un identificator, asa cum vom vedea candva!", h4);
                    h4 += 25;
                    text("nu", "Clasa de memorare reprezinta zona de memorie unde poate fi alocat spatiu pentru o variabila. Ea poate fi: zona de date, zona de stiva,", h4);
                    text("nu", "heap-ul sau un registru al procesorului – o memorie speciala, de mici dimensiuni, foarte rapida existenta in procesor (CPU).", h4);
                    h4 += 25;
                    text("nu", "Vizibilitatea unei variabile precizeaza zona din codul sursa (liniile programului C++) unde se poate folosi respectiva variabila si poate fi:", h4);
                    text("da", "•	la nivel de bloc – variabila este vizibila numai intr-un bloc al programului", h4);
                    text("da", "•	la nivel de fisier – variabila este vizibila in tot fisierul sursa cu care lucram", h4);
                    text("da", "•	la nivel de clasa – specific programarii orientate pe obiecte", h4);
                    break;
                }
                else if(fnc == 2){
                    return 2;
                }
            }
            setcolor(RGB(118,47,5));
            line(XE / 2 + 158, YE - 125, XE / 2 + 133, YE - 100);
            line(XE / 2 + 158, YE - 125, XE / 2 + 133, YE - 150);
        }
        setcolor(WHITE);
    }
}

int pag36(){
    int h3 = YE / 3 - 150;
    clearmouseclick(WM_LBUTTONDOWN);
    delay(200);
    setbkcolor(RGB(196,192,251));
    cleardevice();
    setcolor(RGB(65,0,36));
    settextstyle(6, 0, 17);
    outtextxy(XE / 2 - 240, 50, "Subprograme");
    setcolor(WHITE);
    rectangle(XE / 2 - 105, YE - 150, XE / 2 + 113, YE - 100);
    settextstyle(6, 0 , 3);
    outtextxy(XE / 2 - 95, YE - 135, "Pagina 3 din 7");
    text("nu",  "Programul este sintactic corect. Partea:" ,h3);
    h3 += 10;
    text("nu", "void F(){", h3);
    text("nu", "    cout << MESAJ;", h3);
    text("nu", "}", h3);
    h3 += 10;
    text("nu", "Reprezinta definirea functiei F(), dar tot aici are loc si declararea. Daca schimbam ordinea functiilor F() si main() obtinem:", h3);
    h3 += 10;
    text("nu", "#include <iostream>", h3);
    text("nu", "using namespace std;", h3);
    text("nu", "int main(){", h3);
    text("nu", "    F();", h3);
    text("nu", "    return 0;", h3);
    text("nu", "}", h3);
    text("nu", "void F(){", h3);
    text("nu", "    cout << MESAJ;", h3);
    text("nu", "}", h3);
    h3 += 10;
    text("nu", "De data aceasta programul nu mai este corect; la compilare obtinem urmatoarea eroare:", h3);
    text("nu", "Vom primi o eroare din care constatam ca identificatorul F nu este declarat. El poate fi declarat precizand prototipul functiei ",h3);
    text("nu", "inaintea functiei main() (practic, inainte de a o apela), ca mai jos:", h3);
    h3 += 10;
    text("nu", "#include <iostream>", h3);
    text("nu", "using namespace std;", h3);
    text("nu", "void F();", h3);
    text("nu", "int main(){", h3);
    text("nu", "    F();", h3);
    text("nu", "    return 0;", h3);
    text("nu", "}", h3);
    text("nu", "void F(){", h3);
    text("nu", "    cout << MESAJ;", h3);
    text("nu", "}", h3);

    while(true){
        if(pga == 0)
           pga = intoarcere();
        if(pga == 1){
             pga = 0;
            return 2;
        }
        clearmouseclick(WM_LBUTTONDOWN);
        //sageata stanga
        line(XE / 2 - 150, YE - 125, XE / 2 - 125, YE - 100);
        line(XE / 2 - 150, YE - 125, XE / 2 - 125, YE - 150);
        if(!(mousex() > XE / 2 - 150 && mousex() < XE / 2 - 125 && mousey() > YE - 150 && mousey() < YE - 100) && GetAsyncKeyState(VK_LBUTTON))
            clearmouseclick(WM_LBUTTONDOWN);
        while(mousex() > XE / 2 - 150 && mousex() < XE / 2 - 125 && mousey() > YE - 150 && mousey() < YE - 100){
            setcolor(RGB(118,47,5));
            line(XE / 2 - 150, YE - 125, XE / 2 - 125, YE - 100);
            line(XE / 2 - 150, YE - 125, XE / 2 - 125, YE - 150);
            if(GetAsyncKeyState(VK_LBUTTON)){
                clearmouseclick(WM_LBUTTONDOWN);
                return 1;
            }
        }
        //sageata dreapta
        setcolor(WHITE);
        line(XE / 2 + 158, YE - 125, XE / 2 + 133, YE - 100);
        line(XE / 2 + 158, YE - 125, XE / 2 + 133, YE - 150);
        if(!(mousex() > XE / 2 + 133 && mousex() < XE / 2 + 158 && mousey() > YE - 150 && mousey() < YE - 100) && GetAsyncKeyState(VK_LBUTTON))
            clearmouseclick(WM_LBUTTONDOWN);
        while(mousex() > XE / 2 + 133 && mousex() < XE / 2 + 158 && mousey() > YE - 150 && mousey() < YE - 100){
            if(GetAsyncKeyState(VK_LBUTTON)){
                fnc = pag46();
                if(fnc == 1){
                    h3 = YE / 3 - 150;
                    clearmouseclick(WM_LBUTTONDOWN);
                    delay(200);
                    setbkcolor(RGB(196,192,251));
                    cleardevice();
                    setcolor(RGB(65,0,36));
                    settextstyle(6, 0, 17);
                    outtextxy(XE / 2 - 240, 50, "Subprograme");
                    setcolor(WHITE);
                    line(XE / 2 + 158, YE - 125, XE / 2 + 133, YE - 100);
                    line(XE / 2 + 158, YE - 125, XE / 2 + 133, YE - 150);

                    rectangle(XE / 2 - 105, YE - 150, XE / 2 + 113, YE - 100);
                    settextstyle(6, 0 , 3);
                    outtextxy(XE / 2 - 95, YE - 135, "Pagina 3 din 7");
                    text("nu",  "Programul este sintactic corect. Partea:" ,h3);
                    h3 += 10;
                    text("nu", "void F(){", h3);
                    text("nu", "    cout << MESAJ;", h3);
                    text("nu", "}", h3);
                    h3 += 10;
                    text("nu", "Reprezinta definirea functiei F(), dar tot aici are loc si declararea. Daca schimbam ordinea functiilor F() si main() obtinem:", h3);
                    h3 += 10;
                    text("nu", "#include <iostream>", h3);
                    text("nu", "using namespace std;", h3);
                    text("nu", "int main(){", h3);
                    text("nu", "    F();", h3);
                    text("nu", "    return 0;", h3);
                    text("nu", "}", h3);
                    text("nu", "void F(){", h3);
                    text("nu", "    cout << MESAJ;", h3);
                    text("nu", "}", h3);
                    h3 += 10;
                    text("nu", "De data aceasta programul nu mai este corect; la compilare obtinem urmatoarea eroare:", h3);
                    text("nu", "Vom primi o eroare din care constatam ca identificatorul F nu este declarat. El poate fi declarat precizand prototipul functiei ",h3);
                    text("nu", "inaintea functiei main() (practic, inainte de a o apela), ca mai jos:", h3);
                    h3 += 10;
                    text("nu", "#include <iostream>", h3);
                    text("nu", "using namespace std;", h3);
                    text("nu", "void F();", h3);
                    text("nu", "int main(){", h3);
                    text("nu", "    F();", h3);
                    text("nu", "    return 0;", h3);
                    text("nu", "}", h3);
                    text("nu", "void F(){", h3);
                    text("nu", "    cout << MESAJ;", h3);
                    text("nu", "}", h3);
                    break;
                }
                else if(fnc == 2){
                    return 2;
                }
            }
            setcolor(RGB(118,47,5));
            line(XE / 2 + 158, YE - 125, XE / 2 + 133, YE - 100);
            line(XE / 2 + 158, YE - 125, XE / 2 + 133, YE - 150);
        }
        setcolor(WHITE);
    }
}

int pag26(){
    int h2 = YE / 3 - 150;
    clearmouseclick(WM_LBUTTONDOWN);
    delay(200);
    setbkcolor(RGB(196,192,251));
    cleardevice();
    setcolor(RGB(65,0,36));
    settextstyle(6, 0, 17);
    outtextxy(XE / 2 - 240, 50, "Subprograme");//Titlu lectiei
    /*setcolor(RGB(60,56,153));
    settextstyle(10, 0 , 5);
    outtextxy( 50, h2, "Tipurile reale in virgula mobila");
    h2 += 50;*/
    setcolor(WHITE);
    text("nu", "Subprogramele pot fi de doua tipuri:", h2);
    text("da", "•	functii – subprograme care determina un anumit rezultat, o anumita valoare, pornind de la anumite date de intrare. Spunem ca ", h2);
    text("da", "valoarea este returnata de catre functie, iar aceasta va fi apelata ca operand intr-o expresie, valoarea operandului in expresie fiind ", h2);
    text("da", "de fapt valoarea rezultatului functiei.", h2);
    text("da", "•	proceduri – subprograme care se folosesc intr-o instructiune de sine statatoare, nu intr-o expresie. Ele indeplinesc o sarcina, au un ", h2);
    text("da", "au un efect si nu returneaza un rezultat. De exemplu, citirea unor variabile, afisarea unor valori, transformarea unor date, etc. ", h2);
    h2 += 25;
    text("nu", "In limbajul C/C++, exista doar subprograme de tip functie. Pentru proceduri se foloseste o forma particulara a functiilor.", h2);
    h2 += 25;
    text("nu", "Una dintre regulile limbajului C/C++ este urmatoarea, si o stim foarte bine pentru variabile: Orice identificator, pentru a putea fi folosit,", h2);
    text("nu", "trebuie sa fie mai intai declarat. Aceasta regula este valabila si pentru functii, astfel ca identificam urmatoarele notiuni, aparent", h2);
    text("nu", "asemanatoare. Buna lor intelegere ne va scuti de numeroase erori!!", h2);
    text("da", "•	definirea unei functii inseamna scrierea ei in intregime; este alcatuita din antetul functiei si din corpul functiei", h2);
    text("da", "•	declararea unei functii inseamna sa-i anuntam existenta. Declararea functiei se face intr-o instructiune declarativa", h2);
    text("da", " si se mai numeste si prototip al functiei. Declararea functiei poate fi inlocuita de definirea ei.", h2);
    h2 += 25;
    text("nu", "Sa consideram urmatorul exemplu, fara insemnatate practica:", h2);
    h2 += 10;
    text("nu", "#include <iostream>", h2);
    text("nu", "using namespace std;", h2);
    text("nu", "void F(){", h2);

    text("nu", "    cout << MESAJ;", h2);
    text("nu", "}", h2);
    text("nu", "int main(){", h2);
    text("nu", "    F();", h2);
    text("nu", "    return 0;", h2);
    text("nu", "}", h2);
    h2 += 10;
    setcolor(WHITE);
    rectangle(XE / 2 - 105, YE - 150, XE / 2 + 113, YE - 100);
    settextstyle(6, 0 , 3);
    outtextxy(XE / 2 - 95, YE - 135, "Pagina 2 din 7");
    setcolor(WHITE);
    while(true){
        if(pga == 0)
           pga = intoarcere();
        if(pga == 1){
                 pga = 0;
            return 2;
        }
        //sageata stanga
        line(XE / 2 - 150, YE - 125, XE / 2 - 125, YE - 100);
        line(XE / 2 - 150, YE - 125, XE / 2 - 125, YE - 150);
        if(!(mousex() > XE / 2 - 150 && mousex() < XE / 2 - 125 && mousey() > YE - 150 && mousey() < YE - 100) && GetAsyncKeyState(VK_LBUTTON))
            clearmouseclick(WM_LBUTTONDOWN);
        while(mousex() > XE / 2 - 150 && mousex() < XE / 2 - 125 && mousey() > YE - 150 && mousey() < YE - 100){
            setcolor(RGB(118,47,5));
            line(XE / 2 - 150, YE - 125, XE / 2 - 125, YE - 100);
            line(XE / 2 - 150, YE - 125, XE / 2 - 125, YE - 150);
            if(GetAsyncKeyState(VK_LBUTTON)){
                clearmouseclick(WM_LBUTTONDOWN);
                return 1;
            }
        }
        //sageata dreapta
        setcolor(WHITE);
        line(XE / 2 + 158, YE - 125, XE / 2 + 133, YE - 100);
        line(XE / 2 + 158, YE - 125, XE / 2 + 133, YE - 150);
        if(!(mousex() > XE / 2 + 133 && mousex() < XE / 2 + 158 && mousey() > YE - 150 && mousey() < YE - 100) && GetAsyncKeyState(VK_LBUTTON))
            clearmouseclick(WM_LBUTTONDOWN);
        while(mousex() > XE / 2 + 133 && mousex() < XE / 2 + 158 && mousey() > YE - 150 && mousey() < YE - 100){
            if(GetAsyncKeyState(VK_LBUTTON)){
                fnc = pag36();
                if(fnc == 1){
                        fnc = 0;
                        delay(300);
                        h2 = YE / 3 - 150;
                        cleardevice();
                        setcolor(RGB(65,0,36));
                        settextstyle(6, 0, 17);
                        outtextxy(XE / 2 - 240, 50, "Subprograme");
                        setcolor(WHITE);
                        setcolor(WHITE);
                        line(XE / 2 + 158, YE - 125, XE / 2 + 133, YE - 100);
                        line(XE / 2 + 158, YE - 125, XE / 2 + 133, YE - 150);
                        text("nu", "Subprogramele pot fi de doua tipuri:", h2);
                        text("da", "•	functii – subprograme care determina un anumit rezultat, o anumita valoare, pornind de la anumite date de intrare. Spunem ca ", h2);
                        text("da", "valoarea este returnata de catre functie, iar aceasta va fi apelata ca operand intr-o expresie, valoarea operandului in expresie fiind ", h2);
                        text("da", "de fapt valoarea rezultatului functiei.", h2);
                        text("da", "•	proceduri – subprograme care se folosesc intr-o instructiune de sine statatoare, nu intr-o expresie. Ele indeplinesc o sarcina, au un ", h2);
                        text("da", "au un efect si nu returneaza un rezultat. De exemplu, citirea unor variabile, afisarea unor valori, transformarea unor date, etc. ", h2);
                        h2 += 25;
                        text("nu", "In limbajul C/C++, exista doar subprograme de tip functie. Pentru proceduri se foloseste o forma particulara a functiilor.", h2);
                        h2 += 25;
                        text("nu", "Una dintre regulile limbajului C/C++ este urmatoarea, si o stim foarte bine pentru variabile: Orice identificator, pentru a putea fi folosit,", h2);
                        text("nu", "trebuie sa fie mai intai declarat. Aceasta regula este valabila si pentru functii, astfel ca identificam urmatoarele notiuni, aparent", h2);
                        text("nu", "asemanatoare. Buna lor intelegere ne va scuti de numeroase erori!!", h2);
                        text("da", "•	definirea unei functii inseamna scrierea ei in intregime; este alcatuita din antetul functiei si din corpul functiei", h2);
                        text("da", "•	declararea unei functii inseamna sa-i anuntam existenta. Declararea functiei se face intr-o instructiune declarativa", h2);
                        text("da", " si se mai numeste si prototip al functiei. Declararea functiei poate fi inlocuita de definirea ei.", h2);
                        h2 += 25;
                        text("nu", "Sa consideram urmatorul exemplu, fara insemnatate practica:", h2);
                        h2 += 10;
                        text("nu", "#include <iostream>", h2);
                        text("nu", "using namespace std;", h2);
                        text("nu", "void F(){", h2);

                        text("nu", "    cout << MESAJ;", h2);
                        text("nu", "}", h2);
                        text("nu", "int main(){", h2);
                        text("nu", "    F();", h2);
                        text("nu", "    return 0;", h2);
                        text("nu", "}", h2);
                        h2 += 10;
                        setcolor(WHITE);
                        rectangle(XE / 2 - 105, YE - 150, XE / 2 + 113, YE - 100);
                        settextstyle(6, 0 , 3);
                        outtextxy(XE / 2 - 95, YE - 135, "Pagina 2 din 7");
                        setcolor(WHITE);
                        break;
                    }
                else if(fnc == 2){
                       return 2;
                }
                clearmouseclick(WM_LBUTTONDOWN);
            }
            setcolor(RGB(118,47,5));
            line(XE / 2 + 158, YE - 125, XE / 2 + 133, YE - 100);
            line(XE / 2 + 158, YE - 125, XE / 2 + 133, YE - 150);
        }
        setcolor(WHITE);
        clearmouseclick(WM_LBUTTONDOWN);

    }
}
int pag16(){
    int h1 = YE / 3 - 150;
    cleardevice();
    clearmouseclick(WM_LBUTTONDOWN);
    setbkcolor(RGB(196,192,251));
    cleardevice();

    setcolor(WHITE);
    settextstyle(6, 0 , 3);
    outtextxy(XE / 2 - 95, YE - 135, "Pagina 1 din 7");
    rectangle(XE / 2 - 105, YE - 150, XE / 2 + 113, YE - 100);

    setcolor(RGB(65,0,36));
    settextstyle(6, 0, 17);
    outtextxy(XE / 2 - 240, 50, "Subprograme");//Titlu lectiei
    setcolor(RGB(60,56,153));
    /*settextstyle(10, 0 , 5);
    outtextxy( 50, YE / 3 - 200, "Tipurile intregi");*/
    text("da", "Un subprogram este o colectie de tipuri de date, variabile, instructiuni care indeplinesc o anumita sarcina (calcule, citiri, afisari),  ", h1);
    text("nu", "atunci cand este apelat de un program sau de un alt subprogram.", h1);
    h1 += 25;
    text("nu", "Pentru a intelege conceptul de subprogram, sa consideram doua probleme:", h1);
    h1 += 25;
    text("nu", "Problema 1: Se dau doua numere naturale n si m. Sa se determine suma dintre oglinditul lui n si oglinditul lui m.", h1);
    text("nu", "Pana acum, pentru a rezolva aceasta problema, trebuia sa determinam, folosind doua secvente de program aproape identice, oglinditele", h1);
    text("nu", "celor doua numere, iar apoi sa facem suma. O solutie mai simpla este sa construim un subprogram care determina oglinditul unui numar ",h1);
    text("nu", "natural oarecare, sa-l apelam de doua ori pentru a determina oglinditul lui n si al lui m, apoi sa facem suma rezultatelor.",h1);
    h1 += 25;
    text("nu", "Problema 2: Se citeste un tablou cu n elemente, numere intregi. Sa se ordoneze crescator elementele tabloului si apoi sa se afiseze.",h1);
    h1 += 25;
    text("nu", "Putem rezolva aceasta problema, in mai multe moduri, folosind cunostinte pe care le avem deja. Daca dorim sa o rezolvam folosind ", h1);
    text("nu", "subprograme, vom construi trei subprograme:", h1);
    text("da", "•	citire – care citeste elementele vectorului", h1);
    text("da", "•	sortare – care ordoneaza elementele vectorului", h1);
    text("da", "•	afisare – care afiseaza elementele vectorului", h1);
    h1 += 25;
    text("nu", "Astfel, programul care rezolva problema consta in apelul celor trei subprograme, in odinea potrivita. Am reusit sa descompunem", h1);
    text("nu", "rezolvarea unei probleme complexe in mai multe subprobleme, mai simple, care pot fi rezolvate de mai multe persoane, daca este cazul.", h1);
    h1 += 25;
    text("nu", "Constatam ca utilizarea subprogramelor are cateva avantaje:", h1);
    text("da", "•	reutilizarea codului – dupa ce am scris un subprogram il putem apela de oricate ori este nevoie;", h1);
    text("da", "•	modularizarea programelor – subprogramele ne permit sa impartim problema data in mai multe subprobleme, mai simple;", h1);
    text("da", "•	reducerea numarului de erori care pot sa apara in scrierea unui program", h1);
    text("da", "•	depistarea cu usurinta a erorilor – fiecare subprogram va fi verificat la crearea sa, apoi verificam modul in care apelam subprogramele", h1);
    h1 += 25;


    while(true){
        if(pga == 0)
            pga = intoarcere();
        else if(pga == 1){
            pga = 0;
            return 1;
        }
        //sageata dreapta
        setcolor(WHITE);
        line(XE / 2 + 158, YE - 125, XE / 2 + 133, YE - 100);
        line(XE / 2 + 158, YE - 125, XE / 2 + 133, YE - 150);
        if(!(mousex() > XE / 2 + 133 && mousex() < XE / 2 + 158 && mousey() > YE - 150 && mousey() < YE - 100) && GetAsyncKeyState(VK_LBUTTON))
            clearmouseclick(WM_LBUTTONDOWN);
        while(mousex() > XE / 2 + 133 && mousex() < XE / 2 + 158 && mousey() > YE - 150 && mousey() < YE - 100){
            if(GetAsyncKeyState(VK_LBUTTON)){
                clearmouseclick(WM_LBUTTONDOWN);
                fnc = pag26();
                if(fnc == 1){
                    fnc = 0;
                    h1 = YE / 3 - 150;
                    cleardevice();
                    clearmouseclick(WM_LBUTTONDOWN);
                    setcolor(WHITE);
                    settextstyle(6, 0 , 3);
                    outtextxy(XE / 2 - 95, YE - 135, "Pagina 1 din 7");
                    rectangle(XE / 2 - 105, YE - 150, XE / 2 + 113, YE - 100);
                    setcolor(RGB(65,0,36));
                    settextstyle(6, 0, 17);
                    outtextxy(XE / 2 - 240, 50, "Subprograme");//Titlu lectiei
                    setcolor(RGB(60,56,153));
                    setcolor(WHITE);
                    line(XE / 2 + 158, YE - 125, XE / 2 + 133, YE - 100);
                    line(XE / 2 + 158, YE - 125, XE / 2 + 133, YE - 150);
                    text("da", "Un subprogram este o colectie de tipuri de date, variabile, instructiuni care indeplinesc o anumita sarcina (calcule, citiri, afisari),  ", h1);
                    text("nu", "atunci cand este apelat de un program sau de un alt subprogram.", h1);
                    h1 += 25;
                    text("nu", "Pentru a intelege conceptul de subprogram, sa consideram doua probleme:", h1);
                    h1 += 25;
                    text("nu", "Problema 1: Se dau doua numere naturale n si m. Sa se determine suma dintre oglinditul lui n si oglinditul lui m.", h1);
                    text("nu", "Pana acum, pentru a rezolva aceasta problema, trebuia sa determinam, folosind doua secvente de program aproape identice, oglinditele", h1);
                    text("nu", "celor doua numere, iar apoi sa facem suma. O solutie mai simpla este sa construim un subprogram care determina oglinditul unui numar ",h1);
                    text("nu", "natural oarecare, sa-l apelam de doua ori pentru a determina oglinditul lui n si al lui m, apoi sa facem suma rezultatelor.",h1);
                    h1 += 25;
                    text("nu", "Problema 2: Se citeste un tablou cu n elemente, numere intregi. Sa se ordoneze crescator elementele tabloului si apoi sa se afiseze.",h1);
                    h1 += 25;
                    text("nu", "Putem rezolva aceasta problema, in mai multe moduri, folosind cunostinte pe care le avem deja. Daca dorim sa o rezolvam folosind ", h1);
                    text("nu", "subprograme, vom construi trei subprograme:", h1);
                    text("da", "•	citire – care citeste elementele vectorului", h1);
                    text("da", "•	sortare – care ordoneaza elementele vectorului", h1);
                    text("da", "•	afisare – care afiseaza elementele vectorului", h1);
                    h1 += 25;
                    text("nu", "Astfel, programul care rezolva problema consta in apelul celor trei subprograme, in odinea potrivita. Am reusit sa descompunem", h1);
                    text("nu", "rezolvarea unei probleme complexe in mai multe subprobleme, mai simple, care pot fi rezolvate de mai multe persoane, daca este cazul.", h1);
                    h1 += 25;
                    text("nu", "Constatam ca utilizarea subprogramelor are cateva avantaje:", h1);
                    text("da", "•	reutilizarea codului – dupa ce am scris un subprogram il putem apela de oricate ori este nevoie;", h1);
                    text("da", "•	modularizarea programelor – subprogramele ne permit sa impartim problema data in mai multe subprobleme, mai simple;", h1);
                    text("da", "•	reducerea numarului de erori care pot sa apara in scrierea unui program", h1);
                    text("da", "•	depistarea cu usurinta a erorilor – fiecare subprogram va fi verificat la crearea sa, apoi verificam modul in care apelam subprogramele", h1);
                    h1 += 25;
                    break;
                }
                if(fnc == 2){
                    cleardevice();
                    return 0;
                }
            }
            setcolor(RGB(118,47,5));
            line(XE / 2 + 158, YE - 125, XE / 2 + 133, YE - 100);
            line(XE / 2 + 158, YE - 125, XE / 2 + 133, YE - 150);
        }
        setcolor(WHITE);
    }
}

int pag21(){
    int h2 = YE / 3 - 150, into;
    clearmouseclick(WM_LBUTTONDOWN);
    delay(200);
    setbkcolor(RGB(196,192,251));
    cleardevice();
    setcolor(RGB(65,0,36));
    settextstyle(6, 0, 17);
    outtextxy(XE / 2 - 240, 50, "Tipuri de date");//Titlu lectiei
    setcolor(RGB(60,56,153));
    settextstyle(10, 0 , 5);
    outtextxy( 50, h2, "Tipurile reale in virgula mobila");
    h2 += 50;
    text("da", "Memoreaza valori reale, reprezentate prin mantisa si exponent. In acest mod se pot reprezenta", h2);
    text("nu", "valori foarte mari, dar precizia reprezentarii poate fi slaba numarul de cifre semnificative memorate", h2);
    text("nu", "poate fi mult mai mic decat numarul de cifre din numar.Tipurile reale sunt:", h2);
    text("da", "-	float se reprezinta pe 4 octeti;", h2);
    text("da", "-	double se reprezinta pe 8 octeti;", h2);
    text("da", "-	long double se reprezinta pe 10 octeti;", h2);

    h2 += 50;
    setcolor(RGB(60,56,153));
    settextstyle(10, 0 , 5);
    outtextxy( 50, h2, "Tipul pointer");
    h2 += 50;
    text("da", "O data de tip pointer memoreaza o adresa de memorie,de exemplu adresa unei variabile.Informatii ", h2);
    text("nu","despre pointeri gasiti in acest articol.",h2);
    h2 += 50;
    setcolor(RGB(60,56,153));
    settextstyle(10, 0 , 5);
    outtextxy( 50, h2, "Tipul Bool");
    h2 += 50;
    text("da","Anumite operatii care se fac cu datele au ca rezultat valori de adevar: adevarat sau false.In anumite", h2);
    text("nu","limbaje de programare exista un tip de date care memoreaza exact aceste doua valori.", h2);
    text("da","In limbajul C++ exista tipul bool.Acest tip contine doua valori: literalii true si false.De fapt,acestea",h2);
    text("nu", "redenumiri ale valorilor 1 si 0.", h2);

    setcolor(WHITE);
    rectangle(XE / 2 - 105, YE - 150, XE / 2 + 113, YE - 100);
    settextstyle(6, 0 , 3);
    outtextxy(XE / 2 - 95, YE - 135, "Pagina 2 din 2");
    setcolor(WHITE);
    while(true){
        //sageata stanga
        line(XE / 2 - 150, YE - 125, XE / 2 - 125, YE - 100);
        line(XE / 2 - 150, YE - 125, XE / 2 - 125, YE - 150);
        if(!(mousex() > XE / 2 - 150 && mousex() < XE / 2 - 125 && mousey() > YE - 150 && mousey() < YE - 100) && GetAsyncKeyState(VK_LBUTTON))
            clearmouseclick(WM_LBUTTONDOWN);
        while(mousex() > XE / 2 - 150 && mousex() < XE / 2 - 125 && mousey() > YE - 150 && mousey() < YE - 100){
            setcolor(RGB(118,47,5));
            line(XE / 2 - 150, YE - 125, XE / 2 - 125, YE - 100);
            line(XE / 2 - 150, YE - 125, XE / 2 - 125, YE - 150);
            if(GetAsyncKeyState(VK_LBUTTON)){
                clearmouseclick(WM_LBUTTONDOWN);
                cleardevice();
                return 0;
            }
        }
        if(pga == 0)
            pga = intoarcere();
        else if(pga == 1){
            cleardevice();
            pga = 0;
            return 1;
        }
    }
}

int pag11(){
    clearmouseclick(WM_LBUTTONDOWN);
    int h1 = YE / 3 - 150, pgurm;
    cleardevice();
    clearmouseclick(WM_LBUTTONDOWN);
    setbkcolor(RGB(196,192,251));
    cleardevice();
    setcolor(RGB(65,0,36));
    settextstyle(6, 0, 17);
    outtextxy(XE / 2 - 240, 50, "Tipuri de date");//Titlu lectiei
    setcolor(RGB(60,56,153));
    settextstyle(10, 0 , 5);
    outtextxy( 50, YE / 3 - 200, "Tipurile intregi");
    text("da", "Tipurile intregi permit memorarea de valori intregi. O data de tip int poate memora valori intregi", h1);
    text("nu", "cuprinse intre -231 si 231-1.", h1);
    text("da", "Tipurile intregi difera prin numarul de octeti necesari pentru memorarea datei, tipul datei (cu semn", h1);
    text("nu", "sau fara semn) si implicit intervalul de valori pe care le poate lua respectiva data. Tipurile intregi sunt:", h1);
    ///pune poza aia blanao
    readimagefile("lec1.jpg", 50, h1, XE / 2, h1 + 450);
    h1 += 470;
    text("da", "Tipurile char si unsigned char memoreaza valori intregi. La afisarea unei date de acest tip nu se va", h1);
    text("nu", "afisa numarul pe care il memoreaza ci caracterul care are codul ASCII egal cu acel numar.Operatia de", h1);
    text("nu", "citire a unei date de acest tip este similara.", h1);
    h1 += 50;
    setcolor(RGB(60,56,153));
    settextstyle(10, 0 , 5);
    //page switcher
    while(true){
        //ieslec();
        setcolor(WHITE);
        settextstyle(6, 0 , 3);
        outtextxy(XE / 2 - 95, YE - 135, "Pagina 1 din 2");
        rectangle(XE / 2 - 105, YE - 150, XE / 2 + 113, YE - 100);
        setcolor(WHITE);
        //sageata dreapta
        setcolor(WHITE);
        line(XE / 2 + 158, YE - 125, XE / 2 + 133, YE - 100);
        line(XE / 2 + 158, YE - 125, XE / 2 + 133, YE - 150);
        if(!(mousex() > XE / 2 + 133 && mousex() < XE / 2 + 158 && mousey() > YE - 150 && mousey() < YE - 100) && GetAsyncKeyState(VK_LBUTTON))
            clearmouseclick(WM_LBUTTONDOWN);
        while(mousex() > XE / 2 + 133 && mousex() < XE / 2 + 158 && mousey() > YE - 150 && mousey() < YE - 100){
            if(GetAsyncKeyState(VK_LBUTTON)){
                clearmouseclick(WM_LBUTTONDOWN);
                pgurm = pag21();
            }
                if(pgurm == 1){
                    cleardevice();
                    pgurm = 0;
                    return 1;
                }
                else if(pgurm == 0){
                    pgurm = 2;
                    h1 = YE / 3 - 150;
                    setcolor(RGB(65,0,36));
                    settextstyle(6, 0, 17);
                    outtextxy(XE / 2 - 240, 50, "Tipuri de date");//Titlu lectiei
                    setcolor(RGB(60,56,153));
                    settextstyle(10, 0 , 5);
                    outtextxy( 50, YE / 3 - 200, "Tipurile intregi");
                    text("da", "Tipurile intregi permit memorarea de valori intregi. O data de tip int poate memora valori intregi", h1);
                    text("nu", "cuprinse intre -231 si 231-1.", h1);
                    text("da", "Tipurile intregi difera prin numarul de octeti necesari pentru memorarea datei, tipul datei (cu semn", h1);
                    text("nu", "sau fara semn) si implicit intervalul de valori pe care le poate lua respectiva data. Tipurile intregi sunt:", h1);
                    ///pune poza aia blanao
                    readimagefile("lec1.jpg", 50, h1, XE / 2, h1 + 450);
                    h1 += 470;
                    text("da", "Tipurile char si unsigned char memoreaza valori intregi. La afisarea unei date de acest tip nu se va", h1);
                    text("nu", "afisa numarul pe care il memoreaza ci caracterul care are codul ASCII egal cu acel numar.Operatia de", h1);
                    text("nu", "citire a unei date de acest tip este similara.", h1);
                    h1 += 50;
                    setcolor(RGB(60,56,153));
                    settextstyle(10, 0 , 5);
                }
            }
        if(pga == 0)
            pga = intoarcere();
        else if(pga == 1){
            cleardevice();
            pga = 0;
            return 1;
        }
        setcolor(WHITE);
    }//while true
}

int rosu(){
    cleardevice();
    readimagefile("eroare.jpg", XE / 2 - 350, YE / 2 - 200, XE / 2 + 350, YE / 2 + 200);
    getch();
    cleardevice();
    return 0;
}
void cul(int x){
    if(x == 0){
        setcolor(RGB(225,70,70));
    }
    else if(x == 1){
        setcolor(RGB(248,133,36));
    }
    else{
        setcolor(RGB(174,246,118));
    }
}

int exitmain(){
        setcolor(WHITE);
        rectangle(XE / 2 - 80, YE - 160, XE / 2 + 80, YE - 110); //Primul buton
        settextstyle(1, 0, 4);
        outtextxy(XE / 2 - 60, YE - 150, "Iesire");
        if(!(mousex() > XE / 2 - 80 && mousex() < XE / 2 + 80 && mousey() > YE - 160 && mousey() < YE - 110) && GetAsyncKeyState(VK_LBUTTON))
            clearmouseclick(WM_LBUTTONDOWN);
        while((mousex() > XE / 2 - 80 && mousex() < XE / 2 + 80 && mousey() > YE - 160 && mousey() < YE - 110)){
            setcolor(RGB(118,47,5));
            rectangle(XE / 2 - 80, YE - 160, XE / 2 + 80, YE - 110); //Primul buton
            settextstyle(1, 0, 4);
            outtextxy(XE / 2 - 60, YE - 150, "Iesire");
            if(GetAsyncKeyState(VK_LBUTTON)){
                mainmenu();
            }
        }
}
void lectii(){
    setbkcolor(RGB(196,192,251));
    cleardevice();
    setcolor(WHITE);
    while(true){
        clearmouseclick(WM_LBUTTONDOWN);
        setbkcolor(RGB(196,192,251));
        settextstyle(6, 0, 17);
        setcolor(RGB(65,0,36));
        outtextxy(XE / 2 - 120, 50, "Lectii");
        exitmain();
        setcolor(WHITE);
        //Tipuri date
        setcolor(RGB(60,56,153));
        settextstyle(10, 0 , 4);
        outtextxy(77, YE / 3 - 135, "Tipuri de date");

        line( 75, YE / 3 - 100, 340, YE / 3 - 100);
        setcolor(WHITE);
        rectangle(85, YE / 3 - 80, 335, YE / 3 - 30);
        settextstyle(6, 0 , 3);
        outtextxy(93, YE / 3 - 65, "Notiuni Teoretice");
        if(!(mousex() > 85 && mousex() < 335 && mousey() > YE / 3 - 80 && mousey() < YE / 3 - 30) && GetAsyncKeyState(VK_LBUTTON))
            clearmouseclick(WM_LBUTTONDOWN);
        while( (mousex() > 85 && mousex() < 335 && mousey() > YE / 3 - 80 && mousey() < YE / 3 - 30)){
            cul(a[0]);
            rectangle(85, YE / 3 - 80, 335, YE / 3 - 30);
            settextstyle(6, 0 , 3);
            outtextxy(93, YE / 3 - 65, "Notiuni Teoretice");
            if(GetAsyncKeyState(VK_LBUTTON)){
                pag11();
                cleardevice();
            }
        }
        setcolor(WHITE);
        rectangle(85 , YE / 3 - 10, 335, YE / 3 + 40);
        settextstyle(6, 0 , 3);
        outtextxy(88 , YE / 3 + 5, "Testare cunostinte");
        if(!(mousex() > 85 && mousex() < 335 && mousey() > YE / 3 - 10 && mousey() < YE / 3 + 40))
            clearmouseclick(WM_LBUTTONDOWN);
        while(mousex() > 85 && mousex() < 335 && mousey() > YE / 3 - 10 && mousey() < YE / 3 + 40){
            cul(a[0]);
            rectangle(85 , YE / 3 - 10, 335, YE / 3 + 40);
            settextstyle(6, 0 , 3);
            outtextxy(88 , YE / 3 + 5, "Testare cunostinte");
            if(GetAsyncKeyState(VK_LBUTTON)){
                    cleardevice();
                    punctaj = test(1);
                    if(punctaj == 1)
                        a[1] = 1, a[0] = 2;
                    cleardevice();
                    break;
            }
        }
        setcolor(WHITE);
        //Structuri elementare
        setcolor(RGB(60,56,153));
        settextstyle(10, 0 , 4);
        outtextxy(35, YE / 2 + 50, "Structuri elementare");
        line( 35, YE / 2 + 85, 415, YE / 2 + 85);
            setcolor(WHITE);
            rectangle(85, YE / 2 + 100, 335, YE / 2 + 150);
            settextstyle(6, 0 , 3);
            outtextxy(93, YE / 2 + 115, "Notiuni Teoretice");
            if(!(mousex() > 85 && mousex() < 335 && mousey() > YE / 2 + 100 && mousey() < YE / 2 + 150) && GetAsyncKeyState(VK_LBUTTON))
                clearmouseclick(WM_LBUTTONDOWN);

            while( (mousex() > 85 && mousex() < 335 && mousey() > YE / 2 + 100 && mousey() < YE / 2 + 150)){
                cul(a[1]);
                rectangle(85, YE / 2 + 100, 335, YE / 2 + 150);
                settextstyle(6, 0 , 3);
                outtextxy(93, YE / 2 + 115, "Notiuni Teoretice");
                if(a[1] == 0 && GetAsyncKeyState(VK_LBUTTON)){
                    rosu();
                    break;
                }
                else if(GetAsyncKeyState(VK_LBUTTON)){

                    pag12();
                    cleardevice();
                }
            }
            setcolor(WHITE);
            rectangle(85 , YE / 2 + 170, 335, YE / 2 + 220);
            settextstyle(6, 0 , 3);
            outtextxy(88 , YE / 2 + 185, "Testare cunostinte");
            if(!(mousex() > 85 && mousex() < 335 && mousey() > YE / 2 + 170 && mousey() < YE / 2 + 220))
                clearmouseclick(WM_LBUTTONDOWN);
            while(mousex() > 85 && mousex() < 335 && mousey() > YE / 2 + 170 && mousey() < YE / 2 + 220){
                cul(a[1]);
                rectangle(85 , YE / 2 + 170, 335, YE / 2 + 220);
                settextstyle(6, 0 , 3);
                outtextxy(88 , YE / 2 + 185, "Testare cunostinte");
                if(a[1] == 0 && GetAsyncKeyState(VK_LBUTTON)){
                    rosu();
                    break;
                }
                else if(GetAsyncKeyState(VK_LBUTTON)){
                    cleardevice();
                    punctaj = test(2);
                    if(punctaj == 1){
                        a[2] = 1, a[1] = 0;
                    }
                    cleardevice();
                    break;
                }
            }
            setcolor(WHITE);
        //Tablouri
        setcolor(RGB(60,56,153));
        settextstyle(10, 0 , 5);
        outtextxy(XE / 2 - 100, YE / 3, "Tablouri");
        line( XE / 2 - 100, YE / 3 + 35, XE / 2 + 100, YE / 3 + 35);
        settextstyle(10, 0 , 4);
            //vectori
            outtextxy(XE / 2 - 500, YE / 3 + 85, "Tablouri Unidimensionale");
            line(XE / 2 - 500, YE / 3 + 110, XE / 2 - 45, YE / 3 + 110);
            setcolor(WHITE);
            settextstyle(6, 0 , 3);
            rectangle(XE / 2 - 400, YE / 3 + 130, XE / 2 - 145, YE / 3 + 170);
            outtextxy(XE / 2 - 390, YE / 3 + 140, "Notiuni Teoretice");
            if(!(mousex() > XE / 2 - 400 && mousex() < XE / 2 - 145 && mousey() > YE / 3 + 130 && mousey() < YE / 3 + 170) && GetAsyncKeyState(WM_LBUTTONDOWN))
                clearmouseclick(WM_LBUTTONDOWN);
            while(mousex() > XE / 2 - 400 && mousex() < XE / 2 - 145 && mousey() > YE / 3 + 130 && mousey() < YE / 3 + 170){
                cul(a[2]);
                rectangle(XE / 2 - 400, YE / 3 + 130, XE / 2 - 145, YE / 3 + 170);
                outtextxy(XE / 2 - 390, YE / 3 + 140, "Notiuni Teoretice");
                if(a[2] == 0 && GetAsyncKeyState(VK_LBUTTON)){
                    rosu();
                    break;
                }
                else if(GetAsyncKeyState(VK_LBUTTON)){
                    pag13();
                    cleardevice();
                }
            }
            setcolor(WHITE);
            rectangle(XE / 2 - 400, YE / 3 + 200, XE / 2 - 145, YE / 3 + 240);
            outtextxy(XE / 2 - 398, YE / 3 + 210, "Testare cunostinte");
            if(!(mousex() > XE / 2 - 400 && mousex() < XE / 2 - 145 && mousey() > YE / 3 + 200 && mousey() < YE / 3 + 240) && GetAsyncKeyState(WM_LBUTTONDOWN))
                clearmouseclick(WM_LBUTTONDOWN);
            while(mousex() > XE / 2 - 400 && mousex() < XE / 2 - 145 && mousey() > YE / 3 + 200 && mousey() < YE / 3 + 240){
                cul(a[2]);
                rectangle(XE / 2 - 400, YE / 3 + 200, XE / 2 - 145, YE / 3 + 240);
                outtextxy(XE / 2 - 398, YE / 3 + 210, "Testare cunostinte");
                if(a[2] == 0 && GetAsyncKeyState(VK_LBUTTON)){
                    rosu();
                    break;
                }
                else if(GetAsyncKeyState(VK_LBUTTON)){
                    cleardevice();
                    punctaj = test(3);
                    if(punctaj == 1){
                        a[3] = 1, a[2] = 2;
                    }
                    cleardevice();
                    break;
                }
            }
            setcolor(WHITE);
            //matrice
            setcolor(RGB(60,56,153));
            settextstyle(10, 0 , 4);
            outtextxy(XE / 2 + 10, YE / 3 + 85, "Tablouri Bidimensionale");
            line(XE / 2 + 10, YE / 3 + 110, XE / 2 + 445, YE / 3 + 110);
            setcolor(WHITE);
            settextstyle(6, 0 , 3);
            rectangle(XE / 2 + 100, YE / 3 + 130, XE / 2 + 355, YE / 3 + 170);
            outtextxy(XE / 2 + 112, YE / 3 + 140, "Notiuni Teoretice");
            if(!(mousex() > XE / 2 + 100 && mousex() < XE / 2 + 355 && mousey() > YE / 3 + 130 && mousey() < YE / 3 + 170) && GetAsyncKeyState(WM_LBUTTONDOWN))
                clearmouseclick(WM_LBUTTONDOWN);
            while(mousex() > XE / 2 + 100 && mousex() < XE / 2 + 355 && mousey() > YE / 3 + 130 && mousey() < YE / 3 + 170){
                cul(a[3]);
                rectangle(XE / 2 + 100, YE / 3 + 130, XE / 2 + 355, YE / 3 + 170);
                outtextxy(XE / 2 + 112, YE / 3 + 140, "Notiuni Teoretice");
                if(a[3] == 0 && GetAsyncKeyState(VK_LBUTTON)){
                    rosu();
                    break;
                }
                else if(GetAsyncKeyState(VK_LBUTTON)){
                    pag14();
                    cleardevice();
                }
            }

            setcolor(WHITE);
            rectangle(XE / 2 + 100, YE / 3 + 200, XE / 2 + 355, YE / 3 + 240);
            outtextxy(XE / 2 + 102, YE / 3 + 210, "Testare cunostinte");
            if(!(mousex() > XE / 2 + 100 && mousex() < XE / 2 + 355 && mousey() > YE / 3 + 200 && mousey() < YE / 3 + 240) && GetAsyncKeyState(WM_LBUTTONDOWN))
                clearmouseclick(WM_LBUTTONDOWN);
            while(mousex() > XE / 2 + 100 && mousex() < XE / 2 + 355 && mousey() > YE / 3 + 200 && mousey() < YE / 3 + 240){
                cul(a[3]);
                rectangle(XE / 2 + 100, YE / 3 + 200, XE / 2 + 355, YE / 3 + 240);
                outtextxy(XE / 2 + 102, YE / 3 + 210, "Testare cunostinte");
                if(a[3] == 0 && GetAsyncKeyState(VK_LBUTTON)){
                    rosu();
                    break;
                }
                else if(GetAsyncKeyState(VK_LBUTTON)){
                    cleardevice();
                    punctaj = test(4);
                    if(punctaj == 1){
                        a[3] = 2, a[4] = 1;
                    }
                    cleardevice();
                    break;
                }

            }
            setcolor(WHITE);

        //struct
        setcolor(RGB(60,56,153));
        settextstyle(10, 0 , 4);
        outtextxy(XE - 525, YE / 3 - 135, "Tipul de date inregistrare");
        line(XE - 525, YE / 3 - 100, XE - 35, YE / 3 - 100);
            setcolor(WHITE);
            settextstyle(6, 0 , 3);
            rectangle(XE - 410, YE / 3 - 80, XE - 150, YE / 3 - 30);
            outtextxy(XE - 395, YE / 3 - 65, "Notiuni teoretice");
            if(!(mousex() > XE - 410 && mousex() < XE - 150 && mousey() > YE / 3 - 80 && mousey() < YE / 3 - 30) && GetAsyncKeyState(WM_LBUTTONDOWN))
                clearmouseclick(WM_LBUTTONDOWN);
            while(mousex() > XE - 410 && mousex() < XE - 150 && mousey() > YE / 3 - 80 && mousey() < YE / 3 - 30){
                cul(a[4]);
                rectangle(XE - 410, YE / 3 - 80, XE - 150, YE / 3 - 30);
                outtextxy(XE - 395, YE / 3 - 65, "Notiuni teoretice");
                if(a[4] == 0 && GetAsyncKeyState(VK_LBUTTON)){
                    rosu();
                    break;
                }
                else if(GetAsyncKeyState(VK_LBUTTON)){
                    pag15();
                    cleardevice();
                }
            }
            setcolor(WHITE);
            rectangle(XE - 410, YE / 3 - 10, XE - 150, YE / 3 + 40);
            outtextxy(XE - 400, YE / 3 + 5, "Testare cunostinte");
            if(!(mousex() > XE - 410 && mousex() < XE - 150 && mousey() > YE / 3 - 10 && mousey() < YE / 3 + 40) && GetAsyncKeyState(WM_LBUTTONDOWN))
                clearmouseclick(WM_LBUTTONDOWN);
            while(mousex() > XE - 410 && mousex() < XE - 150 && mousey() > YE / 3 - 10 && mousey() < YE / 3 + 40){
                cul(a[4]);
                rectangle(XE - 410, YE / 3 - 10, XE - 150, YE / 3 + 40);
                outtextxy(XE - 400, YE / 3 + 5, "Testare cunostinte");
                if(a[4] == 0 && GetAsyncKeyState(VK_LBUTTON)){
                    rosu();
                    break;
                }
                else if(GetAsyncKeyState(VK_LBUTTON)){
                    cleardevice();
                    punctaj = test(5);
                    if(punctaj == 1){
                        a[4] = 2, a[5] = 1;
                    }
                    cleardevice();
                    break;
                }
            }
            setcolor(WHITE);
        //Subprograme
        setcolor(RGB(60,56,153));
        settextstyle(10, 0 , 4);
        outtextxy(XE - 380 , YE / 2 + 50, "Subprograme");
        line( XE - 380, YE / 2 + 85, XE - 170, YE / 2 + 85);
            setcolor(WHITE);
            settextstyle(6, 0 , 3);
            outtextxy(XE - 395, YE / 2 + 115, "Notiuni Teoretice");
            rectangle(XE - 410, YE / 2 + 100, XE - 150, YE / 2 + 150);
            if(!(mousex() > XE - 410 && mousex() < XE - 150 && mousey() > YE / 2 + 100 && mousey() < YE / 2 + 150) && GetAsyncKeyState(WM_LBUTTONDOWN))
                ismouseclick(WM_LBUTTONDOWN);
            while(mousex() > XE - 410 && mousex() < XE - 150 && mousey() > YE / 2 + 100 && mousey() < YE / 2 + 150){
                cul(a[5]);
                outtextxy(XE - 395, YE / 2 + 115, "Notiuni Teoretice");
                rectangle(XE - 410, YE / 2 + 100, XE - 150, YE / 2 + 150);
                if(a[5] == 0 && GetAsyncKeyState(VK_LBUTTON)){
                    rosu();
                    break;
                }
                else if(GetAsyncKeyState(VK_LBUTTON)){
                        cleardevice();
                    pag16();
                    cleardevice();
                }
            }
            setcolor(WHITE);
            outtextxy(XE - 405, YE / 2 + 185, "Testare cunostinte");
            rectangle(XE - 410, YE / 2 + 170, XE - 150, YE / 2 + 220);
            if(!(mousex() > XE - 410 && mousex() < XE - 150 && mousey() > YE / 2 + 170 && mousey() < YE / 2 + 220) && GetAsyncKeyState(WM_LBUTTONDOWN))
                clearmouseclick(WM_LBUTTONDOWN);
            while(mousex() > XE - 410 && mousex() < XE - 150 && mousey() > YE / 2 + 170 && mousey() < YE / 2 + 220){
                cul(a[5]);
                if(a[5] == 0 && GetAsyncKeyState(VK_LBUTTON)){
                    rosu();
                    break;
                }
                else if(GetAsyncKeyState(VK_LBUTTON)){
                    cleardevice();
                    punctaj = test(6);
                    if(punctaj == 1){
                        a[5] = 2, a[6] = 1;
                    }
                    cleardevice();
                    break;
                }
                outtextxy(XE - 405, YE / 2 + 185, "Testare cunostinte");
                rectangle(XE - 410, YE / 2 + 170, XE - 150, YE / 2 + 220);
            }
            setcolor(WHITE);
    }//while true
}



void optiuni(){
    clearmouseclick(WM_LBUTTONDOWN);
    setbkcolor(RGB(196,192,251));
    cleardevice();
    settextstyle(6, 0, 17);
     setcolor(RGB(60,56,153));
    outtextxy(XE / 2 - 100, 150, "Credite");
    int hei = YE / 2 - 50;
    settextstyle(9, 0, 3);
    setcolor(WHITE);
    outtextxy(50, YE / 3 - 100, "Aceasta platforma va este oferita de echipa IDEe. Invatare placuta!");
    char bv[10];
    sprintf(bv, "%d", pct);
    settextstyle(6, 0 , 3);
    outtextxy(50, YE / 3 - 65, "Te felicitam ca ai strans un total de: ");
    outtextxy(550, YE / 3 - 65, bv);
    hei += 200;
    outtextxy(50, hei - 20, "Membrii echipei si rolul lor in acest proiect: ");
    hei += 25;
    outtextxy(50, hei, "Catana David Andrei - Interfate Grafice interactive");
    hei += 25;
    outtextxy(50, hei, "Moldoveanu Andrei Daniel - Crearea lectiilor");
    hei += 25;
    outtextxy(50, hei, "Stan Mihai Catalin - Metode de testare");

    while(true){
        exitmain();

    }
}

void mainmenu(){
    setbkcolor(RGB(196,192,251));
    cleardevice();
    settextstyle(6, 0, 17);
    setcolor(RGB(65,0,36));
    outtextxy(XE / 2 - 280, YE / 3 - 100, "Lectii Informatica");
    while(true){
        setcolor(WHITE);
        rectangle(XE / 2 - 80, YE / 4 + 225, XE / 2 + 80, YE / 4 + 275); //Primul buton
        settextstyle(1, 0, 4);
        outtextxy(XE / 2 - 65, YE / 4 + 235, "Lectii");
        if(!(mousex() > XE / 2 - 80) && (mousex() < XE / 2 + 80) && (mousey() > YE / 4 + 225) && (mousey() < YE/ 4 + 275) && GetAsyncKeyState(VK_LBUTTON))
            clearmouseclick(WM_LBUTTONDOWN);
        while( (mousex() > XE / 2 - 80) && (mousex() < XE / 2 + 80) && (mousey() > YE / 4 + 225) && (mousey() < YE/ 4 + 275)){
            setcolor(RGB(118,47,5));
            rectangle(XE / 2 - 80, YE / 4 + 225, XE / 2 + 80, YE / 4 + 275); //Primul buton
            settextstyle(1, 0, 4);
            outtextxy(XE / 2 - 65, YE / 4 + 235, "Lectii");
            if(GetAsyncKeyState(VK_LBUTTON)){
                clearmouseclick(WM_LBUTTONDOWN);
                lectii();
            }
        }
        setcolor(WHITE);
        rectangle(XE / 2 - 84, YE / 4 + 325, XE / 2 + 84, YE / 4 + 375); //Primul buton
        settextstyle(1, 0, 4);
        outtextxy(XE / 2 - 82, YE / 4 + 335, "Credite");
        if(!(mousex() > XE / 2 - 84 && mousex() < XE / 2 + 84 && mousey() > YE / 4 + 325 && mousey() < YE/ 4 + 375) && GetAsyncKeyState(VK_LBUTTON))
            clearmouseclick(WM_LBUTTONDOWN);
        while((mousex() > XE / 2 - 84 && mousex() < XE / 2 + 84 && mousey() > YE / 4 + 325 && mousey() < YE/ 4 + 375)){
            setcolor(RGB(118,47,5));
            rectangle(XE / 2 - 84, YE / 4 + 325, XE / 2 + 84, YE / 4 + 375); //Primul buton
            settextstyle(1, 0, 4);
            outtextxy(XE / 2 - 82, YE / 4 + 335, "Credite");
            if(GetAsyncKeyState(VK_LBUTTON)){
                clearmouseclick(WM_LBUTTONDOWN);
                optiuni();
            }
        }
        setcolor(WHITE);
        rectangle(XE / 2 - 80, YE / 4 + 425, XE / 2 + 80, YE / 4 + 475); //Primul buton
        settextstyle(1, 0, 4);
        outtextxy(XE / 2 - 60, YE / 4 + 435, "Iesire");
        if(!(mousex() > XE / 2 - 80 && mousex() < XE / 2 + 80 && mousey() > YE / 4 + 425 && mousey() < YE/ 4 + 475) && GetAsyncKeyState(VK_LBUTTON))
            clearmouseclick(WM_LBUTTONDOWN);
        while((mousex() > XE / 2 - 80) && (mousex() < XE / 2 + 80) && (mousey() > YE / 4 + 425) && (mousey() < YE/ 4 + 475)){
            setcolor(RGB(118,47,5));
            rectangle(XE / 2 - 80, YE / 4 + 425, XE / 2 + 80, YE / 4 + 475); //Primul buton
            settextstyle(1, 0, 4);
            outtextxy(XE / 2 - 60, YE / 4 + 435, "Iesire");
            if(GetAsyncKeyState(VK_LBUTTON)){
                exit(0);
            }
        }
    }

}
int main(){
    int window1;
    window1 = initwindow(getmaxwidth(), getmaxheight(), "Lectii de informatica");
    XE = getmaxx();
    YE = getmaxy();
    mainmenu();
    getch();
    closegraph(window1);
    return 0;
}
